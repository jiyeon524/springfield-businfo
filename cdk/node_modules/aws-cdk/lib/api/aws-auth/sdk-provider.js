"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SdkProvider = void 0;
const os = require("os");
const path = require("path");
const cxapi = require("@aws-cdk/cx-api");
const AWS = require("aws-sdk");
const fs = require("fs-extra");
const logging_1 = require("../../logging");
const functions_1 = require("../../util/functions");
const credential_plugins_1 = require("../aws-auth/credential-plugins");
const awscli_compatible_1 = require("./awscli-compatible");
const sdk_1 = require("./sdk");
// Some configuration that can only be achieved by setting
// environment variables.
process.env.AWS_STS_REGIONAL_ENDPOINTS = 'regional';
process.env.AWS_NODEJS_CONNECTION_REUSE_ENABLED = '1';
const CACHED_ACCOUNT = Symbol('cached_account');
const CACHED_DEFAULT_CREDENTIALS = Symbol('cached_default_credentials');
/**
 * Creates instances of the AWS SDK appropriate for a given account/region.
 *
 * Behavior is as follows:
 *
 * - First, a set of "base" credentials are established
 *   - If a target environment is given and the default ("current") SDK credentials are for
 *     that account, return those; otherwise
 *   - If a target environment is given, scan all credential provider plugins
 *     for credentials, and return those if found; otherwise
 *   - Return default ("current") SDK credentials, noting that they might be wrong.
 *
 * - Second, a role may optionally need to be assumed. Use the base credentials
 *   established in the previous process to assume that role.
 *   - If assuming the role fails and the base credentials are for the correct
 *     account, return those. This is a fallback for people who are trying to interact
 *     with a Default Synthesized stack and already have right credentials setup.
 *
 *     Typical cases we see in the wild:
 *     - Credential plugin setup that, although not recommended, works for them
 *     - Seeded terminal with `ReadOnly` credentials in order to do `cdk diff`--the `ReadOnly`
 *       role doesn't have `sts:AssumeRole` and will fail for no real good reason.
 */
class SdkProvider {
    constructor(defaultChain, 
    /**
     * Default region
     */
    defaultRegion, sdkOptions = {}) {
        this.defaultChain = defaultChain;
        this.defaultRegion = defaultRegion;
        this.sdkOptions = sdkOptions;
        this.plugins = new credential_plugins_1.CredentialPlugins();
    }
    /**
     * Create a new SdkProvider which gets its defaults in a way that behaves like the AWS CLI does
     *
     * The AWS SDK for JS behaves slightly differently from the AWS CLI in a number of ways; see the
     * class `AwsCliCompatible` for the details.
     */
    static async withAwsCliCompatibleDefaults(options = {}) {
        var _a;
        const sdkOptions = parseHttpOptions((_a = options.httpOptions) !== null && _a !== void 0 ? _a : {});
        const chain = await awscli_compatible_1.AwsCliCompatible.credentialChain({
            profile: options.profile,
            ec2instance: options.ec2creds,
            containerCreds: options.containerCreds,
            httpOptions: sdkOptions.httpOptions,
        });
        const region = await awscli_compatible_1.AwsCliCompatible.region({
            profile: options.profile,
            ec2instance: options.ec2creds,
        });
        return new SdkProvider(chain, region, sdkOptions);
    }
    /**
     * Return an SDK which can do operations in the given environment
     *
     * The `environment` parameter is resolved first (see `resolveEnvironment()`).
     */
    async forEnvironment(environment, mode, options) {
        const env = await this.resolveEnvironment(environment);
        const baseCreds = await this.obtainBaseCredentials(env.account, mode);
        // At this point, we need at least SOME credentials
        if (baseCreds.source === 'none') {
            throw new Error(fmtObtainCredentialsError(env.account, baseCreds));
        }
        // Simple case is if we don't need to "assumeRole" here. If so, we must now have credentials for the right
        // account.
        if ((options === null || options === void 0 ? void 0 : options.assumeRoleArn) === undefined) {
            if (baseCreds.source === 'incorrectDefault') {
                throw new Error(fmtObtainCredentialsError(env.account, baseCreds));
            }
            return { sdk: new sdk_1.SDK(baseCreds.credentials, env.region, this.sdkOptions), didAssumeRole: false };
        }
        // We will proceed to AssumeRole using whatever we've been given.
        const sdk = await this.withAssumedRole(baseCreds, options.assumeRoleArn, options.assumeRoleExternalId, env.region);
        // Exercise the AssumeRoleCredentialsProvider we've gotten at least once so
        // we can determine whether the AssumeRole call succeeds or not.
        try {
            await sdk.forceCredentialRetrieval();
            return { sdk, didAssumeRole: true };
        }
        catch (e) {
            // AssumeRole failed. Proceed and warn *if and only if* the baseCredentials were already for the right account
            // or returned from a plugin. This is to cover some current setups for people using plugins or preferring to
            // feed the CLI credentials which are sufficient by themselves. Prefer to assume the correct role if we can,
            // but if we can't then let's just try with available credentials anyway.
            if (baseCreds.source === 'correctDefault' || baseCreds.source === 'plugin') {
                logging_1.debug(e.message);
                logging_1.warning(`${fmtObtainedCredentials(baseCreds)} could not be used to assume '${options.assumeRoleArn}', but are for the right account. Proceeding anyway.`);
                return { sdk: new sdk_1.SDK(baseCreds.credentials, env.region, this.sdkOptions), didAssumeRole: false };
            }
            throw e;
        }
    }
    /**
     * Return the partition that base credentials are for
     *
     * Returns `undefined` if there are no base credentials.
     */
    async baseCredentialsPartition(environment, mode) {
        const env = await this.resolveEnvironment(environment);
        const baseCreds = await this.obtainBaseCredentials(env.account, mode);
        if (baseCreds.source === 'none') {
            return undefined;
        }
        return (await new sdk_1.SDK(baseCreds.credentials, env.region, this.sdkOptions).currentAccount()).partition;
    }
    /**
     * Resolve the environment for a stack
     *
     * Replaces the magic values `UNKNOWN_REGION` and `UNKNOWN_ACCOUNT`
     * with the defaults for the current SDK configuration (`~/.aws/config` or
     * otherwise).
     *
     * It is an error if `UNKNOWN_ACCOUNT` is used but the user hasn't configured
     * any SDK credentials.
     */
    async resolveEnvironment(env) {
        var _a;
        const region = env.region !== cxapi.UNKNOWN_REGION ? env.region : this.defaultRegion;
        const account = env.account !== cxapi.UNKNOWN_ACCOUNT ? env.account : (_a = (await this.defaultAccount())) === null || _a === void 0 ? void 0 : _a.accountId;
        if (!account) {
            throw new Error('Unable to resolve AWS account to use. It must be either configured when you define your CDK Stack, or through the environment');
        }
        return {
            region,
            account,
            name: cxapi.EnvironmentUtils.format(account, region),
        };
    }
    /**
     * The account we'd auth into if we used default credentials.
     *
     * Default credentials are the set of ambiently configured credentials using
     * one of the environment variables, or ~/.aws/credentials, or the *one*
     * profile that was passed into the CLI.
     *
     * Might return undefined if there are no default/ambient credentials
     * available (in which case the user should better hope they have
     * credential plugins configured).
     *
     * Uses a cache to avoid STS calls if we don't need 'em.
     */
    defaultAccount() {
        return functions_1.cached(this, CACHED_ACCOUNT, async () => {
            try {
                const creds = await this.defaultCredentials();
                const accessKeyId = creds.accessKeyId;
                if (!accessKeyId) {
                    throw new Error('Unable to resolve AWS credentials (setup with "aws configure")');
                }
                return await new sdk_1.SDK(creds, this.defaultRegion, this.sdkOptions).currentAccount();
            }
            catch (e) {
                logging_1.debug('Unable to determine the default AWS account:', e);
                return undefined;
            }
        });
    }
    /**
     * Get credentials for the given account ID in the given mode
     *
     * 1. Use the default credentials if the destination account matches the
     *    current credentials' account.
     * 2. Otherwise try all credential plugins.
     * 3. Fail if neither of these yield any credentials.
     * 4. Return a failure if any of them returned credentials
     */
    async obtainBaseCredentials(accountId, mode) {
        var _a;
        // First try 'current' credentials
        const defaultAccountId = (_a = (await this.defaultAccount())) === null || _a === void 0 ? void 0 : _a.accountId;
        if (defaultAccountId === accountId) {
            return { source: 'correctDefault', credentials: await this.defaultCredentials() };
        }
        // Then try the plugins
        const pluginCreds = await this.plugins.fetchCredentialsFor(accountId, mode);
        if (pluginCreds) {
            return { source: 'plugin', ...pluginCreds };
        }
        // Fall back to default credentials with a note that they're not the right ones yet
        if (defaultAccountId !== undefined) {
            return {
                source: 'incorrectDefault',
                accountId: defaultAccountId,
                credentials: await this.defaultCredentials(),
                unusedPlugins: this.plugins.availablePluginNames,
            };
        }
        // Apparently we didn't find any at all
        return {
            source: 'none',
            unusedPlugins: this.plugins.availablePluginNames,
        };
    }
    /**
     * Resolve the default chain to the first set of credentials that is available
     */
    defaultCredentials() {
        return functions_1.cached(this, CACHED_DEFAULT_CREDENTIALS, () => {
            logging_1.debug('Resolving default credentials');
            return this.defaultChain.resolvePromise();
        });
    }
    /**
     * Return an SDK which uses assumed role credentials
     *
     * The base credentials used to retrieve the assumed role credentials will be the
     * same credentials returned by obtainCredentials if an environment and mode is passed,
     * otherwise it will be the current credentials.
     */
    async withAssumedRole(masterCredentials, roleArn, externalId, region) {
        logging_1.debug(`Assuming role '${roleArn}'.`);
        region = region !== null && region !== void 0 ? region : this.defaultRegion;
        const creds = new AWS.ChainableTemporaryCredentials({
            params: {
                RoleArn: roleArn,
                ...externalId ? { ExternalId: externalId } : {},
                RoleSessionName: `aws-cdk-${safeUsername()}`,
            },
            stsConfig: {
                region,
                ...this.sdkOptions,
            },
            masterCredentials: masterCredentials.credentials,
        });
        return new sdk_1.SDK(creds, region, this.sdkOptions, {
            assumeRoleCredentialsSourceDescription: fmtObtainedCredentials(masterCredentials),
        });
    }
}
exports.SdkProvider = SdkProvider;
const DEFAULT_CONNECTION_TIMEOUT = 10000;
const DEFAULT_TIMEOUT = 300000;
/**
 * Get HTTP options for the SDK
 *
 * Read from user input or environment variables.
 *
 * Returns a complete `ConfigurationOptions` object because that's where
 * `customUserAgent` lives, but `httpOptions` is the most important attribute.
 */
function parseHttpOptions(options) {
    var _a;
    const config = {};
    config.httpOptions = {};
    config.httpOptions.connectTimeout = DEFAULT_CONNECTION_TIMEOUT;
    config.httpOptions.timeout = DEFAULT_TIMEOUT;
    let userAgent = options.userAgent;
    if (userAgent == null) {
        // Find the package.json from the main toolkit
        const pkg = JSON.parse((_a = readIfPossible(path.join(__dirname, '..', '..', '..', 'package.json'))) !== null && _a !== void 0 ? _a : '{}');
        userAgent = `${pkg.name}/${pkg.version}`;
    }
    config.customUserAgent = userAgent;
    const caBundlePath = options.caBundlePath || caBundlePathFromEnvironment();
    if (caBundlePath) {
        logging_1.debug('Using CA bundle path: %s', caBundlePath);
        config.httpOptions.ca = readIfPossible(caBundlePath);
    }
    if (options.proxyAddress) {
        logging_1.debug('Proxy server from command-line arguments: %s', options.proxyAddress);
    }
    // Configure the proxy agent. By default, this will use HTTPS?_PROXY and
    // NO_PROXY environment variables to determine which proxy to use for each
    // request.
    //
    // eslint-disable-next-line @typescript-eslint/no-require-imports
    const ProxyAgent = require('proxy-agent');
    config.httpOptions.agent = new ProxyAgent(options.proxyAddress);
    return config;
}
/**
 * Find and return a CA certificate bundle path to be passed into the SDK.
 */
function caBundlePathFromEnvironment() {
    if (process.env.aws_ca_bundle) {
        return process.env.aws_ca_bundle;
    }
    if (process.env.AWS_CA_BUNDLE) {
        return process.env.AWS_CA_BUNDLE;
    }
    return undefined;
}
/**
 * Read a file if it exists, or return undefined
 *
 * Not async because it is used in the constructor
 */
function readIfPossible(filename) {
    try {
        if (!fs.pathExistsSync(filename)) {
            return undefined;
        }
        return fs.readFileSync(filename, { encoding: 'utf-8' });
    }
    catch (e) {
        logging_1.debug(e);
        return undefined;
    }
}
/**
 * Return the username with characters invalid for a RoleSessionName removed
 *
 * @see https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html#API_AssumeRole_RequestParameters
 */
function safeUsername() {
    return os.userInfo().username.replace(/[^\w+=,.@-]/g, '@');
}
/**
 * Isolating the code that translates calculation errors into human error messages
 *
 * We cover the following cases:
 *
 * - No credentials are available at all
 * - Default credentials are for the wrong account
 */
function fmtObtainCredentialsError(targetAccountId, obtainResult) {
    const msg = [`Need to perform AWS calls for account ${targetAccountId}`];
    switch (obtainResult.source) {
        case 'incorrectDefault':
            msg.push(`but the current credentials are for ${obtainResult.accountId}`);
            break;
        case 'none':
            msg.push('but no credentials have been configured');
    }
    if (obtainResult.unusedPlugins.length > 0) {
        msg.push(`and none of these plugins found any: ${obtainResult.unusedPlugins.join(', ')}`);
    }
    return msg.join(', ');
}
/**
 * Format a message indicating where we got base credentials for the assume role
 *
 * We cover the following cases:
 *
 * - Default credentials for the right account
 * - Default credentials for the wrong account
 * - Credentials returned from a plugin
 */
function fmtObtainedCredentials(obtainResult) {
    switch (obtainResult.source) {
        case 'correctDefault':
            return 'current credentials';
        case 'plugin':
            return `credentials returned by plugin '${obtainResult.pluginName}'`;
        case 'incorrectDefault':
            const msg = [];
            msg.push(`current credentials (which are for account ${obtainResult.accountId}`);
            if (obtainResult.unusedPlugins.length > 0) {
                msg.push(`, and none of the following plugins provided credentials: ${obtainResult.unusedPlugins.join(', ')}`);
            }
            msg.push(')');
            return msg.join('');
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2RrLXByb3ZpZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2RrLXByb3ZpZGVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IseUNBQXlDO0FBQ3pDLCtCQUErQjtBQUUvQiwrQkFBK0I7QUFDL0IsMkNBQStDO0FBQy9DLG9EQUE4QztBQUM5Qyx1RUFBbUU7QUFFbkUsMkRBQXVEO0FBQ3ZELCtCQUFrQztBQUdsQywwREFBMEQ7QUFDMUQseUJBQXlCO0FBQ3pCLE9BQU8sQ0FBQyxHQUFHLENBQUMsMEJBQTBCLEdBQUcsVUFBVSxDQUFDO0FBQ3BELE9BQU8sQ0FBQyxHQUFHLENBQUMsbUNBQW1DLEdBQUcsR0FBRyxDQUFDO0FBMkR0RCxNQUFNLGNBQWMsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztBQUNoRCxNQUFNLDBCQUEwQixHQUFHLE1BQU0sQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDO0FBNkJ4RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUNILE1BQWEsV0FBVztJQTBCdEIsWUFDbUIsWUFBeUM7SUFDMUQ7O09BRUc7SUFDYSxhQUFxQixFQUNwQixhQUFtQyxFQUFFO1FBTHJDLGlCQUFZLEdBQVosWUFBWSxDQUE2QjtRQUkxQyxrQkFBYSxHQUFiLGFBQWEsQ0FBUTtRQUNwQixlQUFVLEdBQVYsVUFBVSxDQUEyQjtRQVJ2QyxZQUFPLEdBQUcsSUFBSSxzQ0FBaUIsRUFBRSxDQUFDO0lBU25ELENBQUM7SUFoQ0Q7Ozs7O09BS0c7SUFDSSxNQUFNLENBQUMsS0FBSyxDQUFDLDRCQUE0QixDQUFDLFVBQThCLEVBQUU7O1FBQy9FLE1BQU0sVUFBVSxHQUFHLGdCQUFnQixPQUFDLE9BQU8sQ0FBQyxXQUFXLG1DQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRS9ELE1BQU0sS0FBSyxHQUFHLE1BQU0sb0NBQWdCLENBQUMsZUFBZSxDQUFDO1lBQ25ELE9BQU8sRUFBRSxPQUFP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QixNQUFNLEdBQUcsR0FBRyxFQUFFLENBQUM7WUFDZixHQUFHLENBQUMsSUFBSSxDQUFDLDhDQUE4QyxZQUFZLENBQUMsU0FBUyxFQUFFLENBQUMsQ0FBQztZQUVqRixJQUFJLFlBQVksQ0FBQyxhQUFhLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtnQkFDekMsR0FBRyxDQUFDLElBQUksQ0FBQyw2REFBNkQsWUFBWSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO2FBQ2hIO1lBQ0QsR0FBRyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUVkLE9BQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztLQUN2QjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBvcyBmcm9tICdvcyc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB0eXBlIHsgQ29uZmlndXJhdGlvbk9wdGlvbnMgfSBmcm9tICdhd3Mtc2RrL2xpYi9jb25maWctYmFzZSc7XG5pbXBvcnQgKiBhcyBmcyBmcm9tICdmcy1leHRyYSc7XG5pbXBvcnQgeyBkZWJ1Zywgd2FybmluZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgY2FjaGVkIH0gZnJvbSAnLi4vLi4vdXRpbC9mdW5jdGlvbnMnO1xuaW1wb3J0IHsgQ3JlZGVudGlhbFBsdWdpbnMgfSBmcm9tICcuLi9hd3MtYXV0aC9jcmVkZW50aWFsLXBsdWdpbnMnO1xuaW1wb3J0IHsgTW9kZSB9IGZyb20gJy4uL2F3cy1hdXRoL2NyZWRlbnRpYWxzJztcbmltcG9ydCB7IEF3c0NsaUNvbXBhdGlibGUgfSBmcm9tICcuL2F3c2NsaS1jb21wYXRpYmxlJztcbmltcG9ydCB7IElTREssIFNESyB9IGZyb20gJy4vc2RrJztcblxuXG4vLyBTb21lIGNvbmZpZ3VyYXRpb24gdGhhdCBjYW4gb25seSBiZSBhY2hpZXZlZCBieSBzZXR0aW5nXG4vLyBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG5wcm9jZXNzLmVudi5BV1NfU1RTX1JFR0lPTkFMX0VORFBPSU5UUyA9ICdyZWdpb25hbCc7XG5wcm9jZXNzLmVudi5BV1NfTk9ERUpTX0NPTk5FQ1RJT05fUkVVU0VfRU5BQkxFRCA9ICcxJztcblxuLyoqXG4gKiBPcHRpb25zIGZvciB0aGUgZGVmYXVsdCBTREsgcHJvdmlkZXJcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBTZGtQcm92aWRlck9wdGlvbnMge1xuICAvKipcbiAgICogUHJvZmlsZSB0byByZWFkIGZyb20gfi8uYXdzXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gcHJvZmlsZVxuICAgKi9cbiAgcmVhZG9ubHkgcHJvZmlsZT86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBzaG91bGQgY2hlY2sgZm9yIEVDMiBjcmVkZW50aWFsc1xuICAgKlxuICAgKiBAZGVmYXVsdCAtIEF1dG9kZXRlY3RcbiAgICovXG4gIHJlYWRvbmx5IGVjMmNyZWRzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBzaG91bGQgY2hlY2sgZm9yIGNvbnRhaW5lciBjcmVkZW50aWFsc1xuICAgKlxuICAgKiBAZGVmYXVsdCAtIEF1dG9kZXRlY3RcbiAgICovXG4gIHJlYWRvbmx5IGNvbnRhaW5lckNyZWRzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSFRUUCBvcHRpb25zIGZvciBTREtcbiAgICovXG4gIHJlYWRvbmx5IGh0dHBPcHRpb25zPzogU2RrSHR0cE9wdGlvbnM7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgaW5kaXZpZHVhbCBTREtzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2RrSHR0cE9wdGlvbnMge1xuICAvKipcbiAgICogUHJveHkgYWRkcmVzcyB0byB1c2VcbiAgICpcbiAgICogQGRlZmF1bHQgTm8gcHJveHlcbiAgICovXG4gIHJlYWRvbmx5IHByb3h5QWRkcmVzcz86IHN0cmluZztcblxuICAvKipcbiAgICogQSBwYXRoIHRvIGEgY2VydGlmaWNhdGUgYnVuZGxlIHRoYXQgY29udGFpbnMgYSBjZXJ0IHRvIGJlIHRydXN0ZWQuXG4gICAqXG4gICAqIEBkZWZhdWx0IE5vIGNlcnRpZmljYXRlIGJ1bmRsZVxuICAgKi9cbiAgcmVhZG9ubHkgY2FCdW5kbGVQYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VzdG9tIHVzZXIgYWdlbnQgdG8gdXNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIDxwYWNrYWdlLW5hbWU+LzxwYWNrYWdlLXZlcnNpb24+XG4gICAqL1xuICByZWFkb25seSB1c2VyQWdlbnQ/OiBzdHJpbmc7XG59XG5cbmNvbnN0IENBQ0hFRF9BQ0NPVU5UID0gU3ltYm9sKCdjYWNoZWRfYWNjb3VudCcpO1xuY29uc3QgQ0FDSEVEX0RFRkFVTFRfQ1JFREVOVElBTFMgPSBTeW1ib2woJ2NhY2hlZF9kZWZhdWx0X2NyZWRlbnRpYWxzJyk7XG5cbi8qKlxuICogU0RLIGNvbmZpZ3VyYXRpb24gZm9yIGEgZ2l2ZW4gZW52aXJvbm1lbnRcbiAqICdmb3JFbnZpcm9ubWVudCcgd2lsbCBhdHRlbXB0IHRvIGFzc3VtZSBhIHJvbGUgYW5kIGlmIGl0XG4gKiBpcyBub3Qgc3VjY2Vzc2Z1bCwgdGhlbiBpdCB3aWxsIGVpdGhlcjpcbiAqICAgMS4gQ2hlY2sgdG8gc2VlIGlmIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzIChsb2NhbCBjcmVkZW50aWFscyB0aGUgQ0xJIHdhcyBleGVjdXRlZCB3aXRoKVxuICogICAgICBhcmUgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudC4gSWYgdGhleSBhcmUgdGhlbiByZXR1cm4gdGhvc2UuXG4gKiAgIDIuIElmIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzIGFyZSBub3QgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudCB0aGVuXG4gKiAgICAgIHRocm93IGFuIGVycm9yXG4gKlxuICogJ2RpZEFzc3VtZVJvbGUnIGFsbG93cyBjYWxsZXJzIHRvIHdoZXRoZXIgdGhleSBhcmUgcmVjZWl2aW5nIHRoZSBhc3N1bWUgcm9sZVxuICogY3JlZGVudGlhbHMgb3IgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2RrRm9yRW52aXJvbm1lbnQge1xuICAvKipcbiAgICogVGhlIFNESyBmb3IgdGhlIGdpdmVuIGVudmlyb25tZW50XG4gICAqL1xuICByZWFkb25seSBzZGs6IElTREs7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgb3Igbm90IHRoZSBhc3N1bWUgcm9sZSB3YXMgc3VjY2Vzc2Z1bC5cbiAgICogSWYgdGhlIGFzc3VtZSByb2xlIHdhcyBub3Qgc3VjY2Vzc2Z1bCAoZmFsc2UpXG4gICAqIHRoZW4gdGhhdCBtZWFucyB0aGF0IHRoZSAnc2RrJyByZXR1cm5lZCBjb250YWluc1xuICAgKiB0aGUgZGVmYXVsdCBjcmVkZW50aWFscyAobm90IHRoZSBhc3N1bWUgcm9sZSBjcmVkZW50aWFscylcbiAgICovXG4gIHJlYWRvbmx5IGRpZEFzc3VtZVJvbGU6IGJvb2xlYW47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBpbnN0YW5jZXMgb2YgdGhlIEFXUyBTREsgYXBwcm9wcmlhdGUgZm9yIGEgZ2l2ZW4gYWNjb3VudC9yZWdpb24uXG4gKlxuICogQmVoYXZpb3IgaXMgYXMgZm9sbG93czpcbiAqXG4gKiAtIEZpcnN0LCBhIHNldCBvZiBcImJhc2VcIiBjcmVkZW50aWFscyBhcmUgZXN0YWJsaXNoZWRcbiAqICAgLSBJZiBhIHRhcmdldCBlbnZpcm9ubWVudCBpcyBnaXZlbiBhbmQgdGhlIGRlZmF1bHQgKFwiY3VycmVudFwiKSBTREsgY3JlZGVudGlhbHMgYXJlIGZvclxuICogICAgIHRoYXQgYWNjb3VudCwgcmV0dXJuIHRob3NlOyBvdGhlcndpc2VcbiAqICAgLSBJZiBhIHRhcmdldCBlbnZpcm9ubWVudCBpcyBnaXZlbiwgc2NhbiBhbGwgY3JlZGVudGlhbCBwcm92aWRlciBwbHVnaW5zXG4gKiAgICAgZm9yIGNyZWRlbnRpYWxzLCBhbmQgcmV0dXJuIHRob3NlIGlmIGZvdW5kOyBvdGhlcndpc2VcbiAqICAgLSBSZXR1cm4gZGVmYXVsdCAoXCJjdXJyZW50XCIpIFNESyBjcmVkZW50aWFscywgbm90aW5nIHRoYXQgdGhleSBtaWdodCBiZSB3cm9uZy5cbiAqXG4gKiAtIFNlY29uZCwgYSByb2xlIG1heSBvcHRpb25hbGx5IG5lZWQgdG8gYmUgYXNzdW1lZC4gVXNlIHRoZSBiYXNlIGNyZWRlbnRpYWxzXG4gKiAgIGVzdGFibGlzaGVkIGluIHRoZSBwcmV2aW91cyBwcm9jZXNzIHRvIGFzc3VtZSB0aGF0IHJvbGUuXG4gKiAgIC0gSWYgYXNzdW1pbmcgdGhlIHJvbGUgZmFpbHMgYW5kIHRoZSBiYXNlIGNyZWRlbnRpYWxzIGFyZSBmb3IgdGhlIGNvcnJlY3RcbiAqICAgICBhY2NvdW50LCByZXR1cm4gdGhvc2UuIFRoaXMgaXMgYSBmYWxsYmFjayBmb3IgcGVvcGxlIHdobyBhcmUgdHJ5aW5nIHRvIGludGVyYWN0XG4gKiAgICAgd2l0aCBhIERlZmF1bHQgU3ludGhlc2l6ZWQgc3RhY2sgYW5kIGFscmVhZHkgaGF2ZSByaWdodCBjcmVkZW50aWFscyBzZXR1cC5cbiAqXG4gKiAgICAgVHlwaWNhbCBjYXNlcyB3ZSBzZWUgaW4gdGhlIHdpbGQ6XG4gKiAgICAgLSBDcmVkZW50aWFsIHBsdWdpbiBzZXR1cCB0aGF0LCBhbHRob3VnaCBub3QgcmVjb21tZW5kZWQsIHdvcmtzIGZvciB0aGVtXG4gKiAgICAgLSBTZWVkZWQgdGVybWluYWwgd2l0aCBgUmVhZE9ubHlgIGNyZWRlbnRpYWxzIGluIG9yZGVyIHRvIGRvIGBjZGsgZGlmZmAtLXRoZSBgUmVhZE9ubHlgXG4gKiAgICAgICByb2xlIGRvZXNuJ3QgaGF2ZSBgc3RzOkFzc3VtZVJvbGVgIGFuZCB3aWxsIGZhaWwgZm9yIG5vIHJlYWwgZ29vZCByZWFzb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTZGtQcm92aWRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgU2RrUHJvdmlkZXIgd2hpY2ggZ2V0cyBpdHMgZGVmYXVsdHMgaW4gYSB3YXkgdGhhdCBiZWhhdmVzIGxpa2UgdGhlIEFXUyBDTEkgZG9lc1xuICAgKlxuICAgKiBUaGUgQVdTIFNESyBmb3IgSlMgYmVoYXZlcyBzbGlnaHRseSBkaWZmZXJlbnRseSBmcm9tIHRoZSBBV1MgQ0xJIGluIGEgbnVtYmVyIG9mIHdheXM7IHNlZSB0aGVcbiAgICogY2xhc3MgYEF3c0NsaUNvbXBhdGlibGVgIGZvciB0aGUgZGV0YWlscy5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgd2l0aEF3c0NsaUNvbXBhdGlibGVEZWZhdWx0cyhvcHRpb25zOiBTZGtQcm92aWRlck9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHNka09wdGlvbnMgPSBwYXJzZUh0dHBPcHRpb25zKG9wdGlvbnMuaHR0cE9wdGlvbnMgPz8ge30pO1xuXG4gICAgY29uc3QgY2hhaW4gPSBhd2FpdCBBd3NDbGlDb21wYXRpYmxlLmNyZWRlbnRpYWxDaGFpbih7XG4gICAgICBwcm9maWxlOiBvcHRpb25zLnByb2ZpbGUsXG4gICAgICBlYzJpbnN0YW5jZTogb3B0aW9ucy5lYzJjcmVkcyxcbiAgICAgIGNvbnRhaW5lckNyZWRzOiBvcHRpb25zLmNvbnRhaW5lckNyZWRzLFxuICAgICAgaHR0cE9wdGlvbnM6IHNka09wdGlvbnMuaHR0cE9wdGlvbnMsXG4gICAgfSk7XG4gICAgY29uc3QgcmVnaW9uID0gYXdhaXQgQXdzQ2xpQ29tcGF0aWJsZS5yZWdpb24oe1xuICAgICAgcHJvZmlsZTogb3B0aW9ucy5wcm9maWxlLFxuICAgICAgZWMyaW5zdGFuY2U6IG9wdGlvbnMuZWMyY3JlZHMsXG4gICAgfSk7XG5cbiAgICByZXR1cm4gbmV3IFNka1Byb3ZpZGVyKGNoYWluLCByZWdpb24sIHNka09wdGlvbnMpO1xuICB9XG5cbiAgcHJpdmF0ZSByZWFkb25seSBwbHVnaW5zID0gbmV3IENyZWRlbnRpYWxQbHVnaW5zKCk7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdENoYWluOiBBV1MuQ3JlZGVudGlhbFByb3ZpZGVyQ2hhaW4sXG4gICAgLyoqXG4gICAgICogRGVmYXVsdCByZWdpb25cbiAgICAgKi9cbiAgICBwdWJsaWMgcmVhZG9ubHkgZGVmYXVsdFJlZ2lvbjogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2RrT3B0aW9uczogQ29uZmlndXJhdGlvbk9wdGlvbnMgPSB7fSkge1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBhbiBTREsgd2hpY2ggY2FuIGRvIG9wZXJhdGlvbnMgaW4gdGhlIGdpdmVuIGVudmlyb25tZW50XG4gICAqXG4gICAqIFRoZSBgZW52aXJvbm1lbnRgIHBhcmFtZXRlciBpcyByZXNvbHZlZCBmaXJzdCAoc2VlIGByZXNvbHZlRW52aXJvbm1lbnQoKWApLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGZvckVudmlyb25tZW50KFxuICAgIGVudmlyb25tZW50OiBjeGFwaS5FbnZpcm9ubWVudCxcbiAgICBtb2RlOiBNb2RlLFxuICAgIG9wdGlvbnM/OiBDcmVkZW50aWFsc09wdGlvbnMsXG4gICk6IFByb21pc2U8U2RrRm9yRW52aXJvbm1lbnQ+IHtcbiAgICBjb25zdCBlbnYgPSBhd2FpdCB0aGlzLnJlc29sdmVFbnZpcm9ubWVudChlbnZpcm9ubWVudCk7XG4gICAgY29uc3QgYmFzZUNyZWRzID0gYXdhaXQgdGhpcy5vYnRhaW5CYXNlQ3JlZGVudGlhbHMoZW52LmFjY291bnQsIG1vZGUpO1xuXG4gICAgLy8gQXQgdGhpcyBwb2ludCwgd2UgbmVlZCBhdCBsZWFzdCBTT01FIGNyZWRlbnRpYWxzXG4gICAgaWYgKGJhc2VDcmVkcy5zb3VyY2UgPT09ICdub25lJykgeyB0aHJvdyBuZXcgRXJyb3IoZm10T2J0YWluQ3JlZGVudGlhbHNFcnJvcihlbnYuYWNjb3VudCwgYmFzZUNyZWRzKSk7IH1cblxuICAgIC8vIFNpbXBsZSBjYXNlIGlzIGlmIHdlIGRvbid0IG5lZWQgdG8gXCJhc3N1bWVSb2xlXCIgaGVyZS4gSWYgc28sIHdlIG11c3Qgbm93IGhhdmUgY3JlZGVudGlhbHMgZm9yIHRoZSByaWdodFxuICAgIC8vIGFjY291bnQuXG4gICAgaWYgKG9wdGlvbnM/LmFzc3VtZVJvbGVBcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGJhc2VDcmVkcy5zb3VyY2UgPT09ICdpbmNvcnJlY3REZWZhdWx0JykgeyB0aHJvdyBuZXcgRXJyb3IoZm10T2J0YWluQ3JlZGVudGlhbHNFcnJvcihlbnYuYWNjb3VudCwgYmFzZUNyZWRzKSk7IH1cbiAgICAgIHJldHVybiB7IHNkazogbmV3IFNESyhiYXNlQ3JlZHMuY3JlZGVudGlhbHMsIGVudi5yZWdpb24sIHRoaXMuc2RrT3B0aW9ucyksIGRpZEFzc3VtZVJvbGU6IGZhbHNlIH07XG4gICAgfVxuXG4gICAgLy8gV2Ugd2lsbCBwcm9jZWVkIHRvIEFzc3VtZVJvbGUgdXNpbmcgd2hhdGV2ZXIgd2UndmUgYmVlbiBnaXZlbi5cbiAgICBjb25zdCBzZGsgPSBhd2FpdCB0aGlzLndpdGhBc3N1bWVkUm9sZShiYXNlQ3JlZHMsIG9wdGlvbnMuYXNzdW1lUm9sZUFybiwgb3B0aW9ucy5hc3N1bWVSb2xlRXh0ZXJuYWxJZCwgZW52LnJlZ2lvbik7XG5cbiAgICAvLyBFeGVyY2lzZSB0aGUgQXNzdW1lUm9sZUNyZWRlbnRpYWxzUHJvdmlkZXIgd2UndmUgZ290dGVuIGF0IGxlYXN0IG9uY2Ugc29cbiAgICAvLyB3ZSBjYW4gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIEFzc3VtZVJvbGUgY2FsbCBzdWNjZWVkcyBvciBub3QuXG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IHNkay5mb3JjZUNyZWRlbnRpYWxSZXRyaWV2YWwoKTtcbiAgICAgIHJldHVybiB7IHNkaywgZGlkQXNzdW1lUm9sZTogdHJ1ZSB9O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8vIEFzc3VtZVJvbGUgZmFpbGVkLiBQcm9jZWVkIGFuZCB3YXJuICppZiBhbmQgb25seSBpZiogdGhlIGJhc2VDcmVkZW50aWFscyB3ZXJlIGFscmVhZHkgZm9yIHRoZSByaWdodCBhY2NvdW50XG4gICAgICAvLyBvciByZXR1cm5lZCBmcm9tIGEgcGx1Z2luLiBUaGlzIGlzIHRvIGNvdmVyIHNvbWUgY3VycmVudCBzZXR1cHMgZm9yIHBlb3BsZSB1c2luZyBwbHVnaW5zIG9yIHByZWZlcnJpbmcgdG9cbiAgICAgIC8vIGZlZWQgdGhlIENMSSBjcmVkZW50aWFscyB3aGljaCBhcmUgc3VmZmljaWVudCBieSB0aGVtc2VsdmVzLiBQcmVmZXIgdG8gYXNzdW1lIHRoZSBjb3JyZWN0IHJvbGUgaWYgd2UgY2FuLFxuICAgICAgLy8gYnV0IGlmIHdlIGNhbid0IHRoZW4gbGV0J3MganVzdCB0cnkgd2l0aCBhdmFpbGFibGUgY3JlZGVudGlhbHMgYW55d2F5LlxuICAgICAgaWYgKGJhc2VDcmVkcy5zb3VyY2UgPT09ICdjb3JyZWN0RGVmYXVsdCcgfHwgYmFzZUNyZWRzLnNvdXJjZSA9PT0gJ3BsdWdpbicpIHtcbiAgICAgICAgZGVidWcoZS5tZXNzYWdlKTtcbiAgICAgICAgd2FybmluZyhgJHtmbXRPYnRhaW5lZENyZWRlbnRpYWxzKGJhc2VDcmVkcyl9IGNvdWxkIG5vdCBiZSB1c2VkIHRvIGFzc3VtZSAnJHtvcHRpb25zLmFzc3VtZVJvbGVBcm59JywgYnV0IGFyZSBmb3IgdGhlIHJpZ2h0IGFjY291bnQuIFByb2NlZWRpbmcgYW55d2F5LmApO1xuICAgICAgICByZXR1cm4geyBzZGs6IG5ldyBTREsoYmFzZUNyZWRzLmNyZWRlbnRpYWxzLCBlbnYucmVnaW9uLCB0aGlzLnNka09wdGlvbnMpLCBkaWRBc3N1bWVSb2xlOiBmYWxzZSB9O1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHBhcnRpdGlvbiB0aGF0IGJhc2UgY3JlZGVudGlhbHMgYXJlIGZvclxuICAgKlxuICAgKiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZXJlIGFyZSBubyBiYXNlIGNyZWRlbnRpYWxzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIGJhc2VDcmVkZW50aWFsc1BhcnRpdGlvbihlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsIG1vZGU6IE1vZGUpOiBQcm9taXNlPHN0cmluZyB8IHVuZGVmaW5lZD4ge1xuICAgIGNvbnN0IGVudiA9IGF3YWl0IHRoaXMucmVzb2x2ZUVudmlyb25tZW50KGVudmlyb25tZW50KTtcbiAgICBjb25zdCBiYXNlQ3JlZHMgPSBhd2FpdCB0aGlzLm9idGFpbkJhc2VDcmVkZW50aWFscyhlbnYuYWNjb3VudCwgbW9kZSk7XG4gICAgaWYgKGJhc2VDcmVkcy5zb3VyY2UgPT09ICdub25lJykgeyByZXR1cm4gdW5kZWZpbmVkOyB9XG4gICAgcmV0dXJuIChhd2FpdCBuZXcgU0RLKGJhc2VDcmVkcy5jcmVkZW50aWFscywgZW52LnJlZ2lvbiwgdGhpcy5zZGtPcHRpb25zKS5jdXJyZW50QWNjb3VudCgpKS5wYXJ0aXRpb247XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgZW52aXJvbm1lbnQgZm9yIGEgc3RhY2tcbiAgICpcbiAgICogUmVwbGFjZXMgdGhlIG1hZ2ljIHZhbHVlcyBgVU5LTk9XTl9SRUdJT05gIGFuZCBgVU5LTk9XTl9BQ0NPVU5UYFxuICAgKiB3aXRoIHRoZSBkZWZhdWx0cyBmb3IgdGhlIGN1cnJlbnQgU0RLIGNvbmZpZ3VyYXRpb24gKGB+Ly5hd3MvY29uZmlnYCBvclxuICAgKiBvdGhlcndpc2UpLlxuICAgKlxuICAgKiBJdCBpcyBhbiBlcnJvciBpZiBgVU5LTk9XTl9BQ0NPVU5UYCBpcyB1c2VkIGJ1dCB0aGUgdXNlciBoYXNuJ3QgY29uZmlndXJlZFxuICAgKiBhbnkgU0RLIGNyZWRlbnRpYWxzLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlc29sdmVFbnZpcm9ubWVudChlbnY6IGN4YXBpLkVudmlyb25tZW50KTogUHJvbWlzZTxjeGFwaS5FbnZpcm9ubWVudD4ge1xuICAgIGNvbnN0IHJlZ2lvbiA9IGVudi5yZWdpb24gIT09IGN4YXBpLlVOS05PV05fUkVHSU9OID8gZW52LnJlZ2lvbiA6IHRoaXMuZGVmYXVsdFJlZ2lvbjtcbiAgICBjb25zdCBhY2NvdW50ID0gZW52LmFjY291bnQgIT09IGN4YXBpLlVOS05PV05fQUNDT1VOVCA/IGVudi5hY2NvdW50IDogKGF3YWl0IHRoaXMuZGVmYXVsdEFjY291bnQoKSk/LmFjY291bnRJZDtcblxuICAgIGlmICghYWNjb3VudCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVzb2x2ZSBBV1MgYWNjb3VudCB0byB1c2UuIEl0IG11c3QgYmUgZWl0aGVyIGNvbmZpZ3VyZWQgd2hlbiB5b3UgZGVmaW5lIHlvdXIgQ0RLIFN0YWNrLCBvciB0aHJvdWdoIHRoZSBlbnZpcm9ubWVudCcpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICByZWdpb24sXG4gICAgICBhY2NvdW50LFxuICAgICAgbmFtZTogY3hhcGkuRW52aXJvbm1lbnRVdGlscy5mb3JtYXQoYWNjb3VudCwgcmVnaW9uKSxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBhY2NvdW50IHdlJ2QgYXV0aCBpbnRvIGlmIHdlIHVzZWQgZGVmYXVsdCBjcmVkZW50aWFscy5cbiAgICpcbiAgICogRGVmYXVsdCBjcmVkZW50aWFscyBhcmUgdGhlIHNldCBvZiBhbWJpZW50bHkgY29uZmlndXJlZCBjcmVkZW50aWFscyB1c2luZ1xuICAgKiBvbmUgb2YgdGhlIGVudmlyb25tZW50IHZhcmlhYmxlcywgb3Igfi8uYXdzL2NyZWRlbnRpYWxzLCBvciB0aGUgKm9uZSpcbiAgICogcHJvZmlsZSB0aGF0IHdhcyBwYXNzZWQgaW50byB0aGUgQ0xJLlxuICAgKlxuICAgKiBNaWdodCByZXR1cm4gdW5kZWZpbmVkIGlmIHRoZXJlIGFyZSBubyBkZWZhdWx0L2FtYmllbnQgY3JlZGVudGlhbHNcbiAgICogYXZhaWxhYmxlIChpbiB3aGljaCBjYXNlIHRoZSB1c2VyIHNob3VsZCBiZXR0ZXIgaG9wZSB0aGV5IGhhdmVcbiAgICogY3JlZGVudGlhbCBwbHVnaW5zIGNvbmZpZ3VyZWQpLlxuICAgKlxuICAgKiBVc2VzIGEgY2FjaGUgdG8gYXZvaWQgU1RTIGNhbGxzIGlmIHdlIGRvbid0IG5lZWQgJ2VtLlxuICAgKi9cbiAgcHVibGljIGRlZmF1bHRBY2NvdW50KCk6IFByb21pc2U8QWNjb3VudCB8IHVuZGVmaW5lZD4ge1xuICAgIHJldHVybiBjYWNoZWQodGhpcywgQ0FDSEVEX0FDQ09VTlQsIGFzeW5jICgpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNyZWRzID0gYXdhaXQgdGhpcy5kZWZhdWx0Q3JlZGVudGlhbHMoKTtcblxuICAgICAgICBjb25zdCBhY2Nlc3NLZXlJZCA9IGNyZWRzLmFjY2Vzc0tleUlkO1xuICAgICAgICBpZiAoIWFjY2Vzc0tleUlkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gcmVzb2x2ZSBBV1MgY3JlZGVudGlhbHMgKHNldHVwIHdpdGggXCJhd3MgY29uZmlndXJlXCIpJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYXdhaXQgbmV3IFNESyhjcmVkcywgdGhpcy5kZWZhdWx0UmVnaW9uLCB0aGlzLnNka09wdGlvbnMpLmN1cnJlbnRBY2NvdW50KCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGRlYnVnKCdVbmFibGUgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IEFXUyBhY2NvdW50OicsIGUpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBjcmVkZW50aWFscyBmb3IgdGhlIGdpdmVuIGFjY291bnQgSUQgaW4gdGhlIGdpdmVuIG1vZGVcbiAgICpcbiAgICogMS4gVXNlIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzIGlmIHRoZSBkZXN0aW5hdGlvbiBhY2NvdW50IG1hdGNoZXMgdGhlXG4gICAqICAgIGN1cnJlbnQgY3JlZGVudGlhbHMnIGFjY291bnQuXG4gICAqIDIuIE90aGVyd2lzZSB0cnkgYWxsIGNyZWRlbnRpYWwgcGx1Z2lucy5cbiAgICogMy4gRmFpbCBpZiBuZWl0aGVyIG9mIHRoZXNlIHlpZWxkIGFueSBjcmVkZW50aWFscy5cbiAgICogNC4gUmV0dXJuIGEgZmFpbHVyZSBpZiBhbnkgb2YgdGhlbSByZXR1cm5lZCBjcmVkZW50aWFsc1xuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBvYnRhaW5CYXNlQ3JlZGVudGlhbHMoYWNjb3VudElkOiBzdHJpbmcsIG1vZGU6IE1vZGUpOiBQcm9taXNlPE9idGFpbkJhc2VDcmVkZW50aWFsc1Jlc3VsdD4ge1xuICAgIC8vIEZpcnN0IHRyeSAnY3VycmVudCcgY3JlZGVudGlhbHNcbiAgICBjb25zdCBkZWZhdWx0QWNjb3VudElkID0gKGF3YWl0IHRoaXMuZGVmYXVsdEFjY291bnQoKSk/LmFjY291bnRJZDtcbiAgICBpZiAoZGVmYXVsdEFjY291bnRJZCA9PT0gYWNjb3VudElkKSB7XG4gICAgICByZXR1cm4geyBzb3VyY2U6ICdjb3JyZWN0RGVmYXVsdCcsIGNyZWRlbnRpYWxzOiBhd2FpdCB0aGlzLmRlZmF1bHRDcmVkZW50aWFscygpIH07XG4gICAgfVxuXG4gICAgLy8gVGhlbiB0cnkgdGhlIHBsdWdpbnNcbiAgICBjb25zdCBwbHVnaW5DcmVkcyA9IGF3YWl0IHRoaXMucGx1Z2lucy5mZXRjaENyZWRlbnRpYWxzRm9yKGFjY291bnRJZCwgbW9kZSk7XG4gICAgaWYgKHBsdWdpbkNyZWRzKSB7XG4gICAgICByZXR1cm4geyBzb3VyY2U6ICdwbHVnaW4nLCAuLi5wbHVnaW5DcmVkcyB9O1xuICAgIH1cblxuICAgIC8vIEZhbGwgYmFjayB0byBkZWZhdWx0IGNyZWRlbnRpYWxzIHdpdGggYSBub3RlIHRoYXQgdGhleSdyZSBub3QgdGhlIHJpZ2h0IG9uZXMgeWV0XG4gICAgaWYgKGRlZmF1bHRBY2NvdW50SWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc291cmNlOiAnaW5jb3JyZWN0RGVmYXVsdCcsXG4gICAgICAgIGFjY291bnRJZDogZGVmYXVsdEFjY291bnRJZCxcbiAgICAgICAgY3JlZGVudGlhbHM6IGF3YWl0IHRoaXMuZGVmYXVsdENyZWRlbnRpYWxzKCksXG4gICAgICAgIHVudXNlZFBsdWdpbnM6IHRoaXMucGx1Z2lucy5hdmFpbGFibGVQbHVnaW5OYW1lcyxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQXBwYXJlbnRseSB3ZSBkaWRuJ3QgZmluZCBhbnkgYXQgYWxsXG4gICAgcmV0dXJuIHtcbiAgICAgIHNvdXJjZTogJ25vbmUnLFxuICAgICAgdW51c2VkUGx1Z2luczogdGhpcy5wbHVnaW5zLmF2YWlsYWJsZVBsdWdpbk5hbWVzLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZSB0aGUgZGVmYXVsdCBjaGFpbiB0byB0aGUgZmlyc3Qgc2V0IG9mIGNyZWRlbnRpYWxzIHRoYXQgaXMgYXZhaWxhYmxlXG4gICAqL1xuICBwcml2YXRlIGRlZmF1bHRDcmVkZW50aWFscygpOiBQcm9taXNlPEFXUy5DcmVkZW50aWFscz4ge1xuICAgIHJldHVybiBjYWNoZWQodGhpcywgQ0FDSEVEX0RFRkFVTFRfQ1JFREVOVElBTFMsICgpID0+IHtcbiAgICAgIGRlYnVnKCdSZXNvbHZpbmcgZGVmYXVsdCBjcmVkZW50aWFscycpO1xuICAgICAgcmV0dXJuIHRoaXMuZGVmYXVsdENoYWluLnJlc29sdmVQcm9taXNlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGFuIFNESyB3aGljaCB1c2VzIGFzc3VtZWQgcm9sZSBjcmVkZW50aWFsc1xuICAgKlxuICAgKiBUaGUgYmFzZSBjcmVkZW50aWFscyB1c2VkIHRvIHJldHJpZXZlIHRoZSBhc3N1bWVkIHJvbGUgY3JlZGVudGlhbHMgd2lsbCBiZSB0aGVcbiAgICogc2FtZSBjcmVkZW50aWFscyByZXR1cm5lZCBieSBvYnRhaW5DcmVkZW50aWFscyBpZiBhbiBlbnZpcm9ubWVudCBhbmQgbW9kZSBpcyBwYXNzZWQsXG4gICAqIG90aGVyd2lzZSBpdCB3aWxsIGJlIHRoZSBjdXJyZW50IGNyZWRlbnRpYWxzLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB3aXRoQXNzdW1lZFJvbGUoXG4gICAgbWFzdGVyQ3JlZGVudGlhbHM6IEV4Y2x1ZGU8T2J0YWluQmFzZUNyZWRlbnRpYWxzUmVzdWx0LCB7IHNvdXJjZTogJ25vbmUnIH0+LFxuICAgIHJvbGVBcm46IHN0cmluZyxcbiAgICBleHRlcm5hbElkOiBzdHJpbmcgfCB1bmRlZmluZWQsXG4gICAgcmVnaW9uOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBkZWJ1ZyhgQXNzdW1pbmcgcm9sZSAnJHtyb2xlQXJufScuYCk7XG5cbiAgICByZWdpb24gPSByZWdpb24gPz8gdGhpcy5kZWZhdWx0UmVnaW9uO1xuXG4gICAgY29uc3QgY3JlZHMgPSBuZXcgQVdTLkNoYWluYWJsZVRlbXBvcmFyeUNyZWRlbnRpYWxzKHtcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBSb2xlQXJuOiByb2xlQXJuLFxuICAgICAgICAuLi5leHRlcm5hbElkID8geyBFeHRlcm5hbElkOiBleHRlcm5hbElkIH0gOiB7fSxcbiAgICAgICAgUm9sZVNlc3Npb25OYW1lOiBgYXdzLWNkay0ke3NhZmVVc2VybmFtZSgpfWAsXG4gICAgICB9LFxuICAgICAgc3RzQ29uZmlnOiB7XG4gICAgICAgIHJlZ2lvbixcbiAgICAgICAgLi4udGhpcy5zZGtPcHRpb25zLFxuICAgICAgfSxcbiAgICAgIG1hc3RlckNyZWRlbnRpYWxzOiBtYXN0ZXJDcmVkZW50aWFscy5jcmVkZW50aWFscyxcbiAgICB9KTtcblxuICAgIHJldHVybiBuZXcgU0RLKGNyZWRzLCByZWdpb24sIHRoaXMuc2RrT3B0aW9ucywge1xuICAgICAgYXNzdW1lUm9sZUNyZWRlbnRpYWxzU291cmNlRGVzY3JpcHRpb246IGZtdE9idGFpbmVkQ3JlZGVudGlhbHMobWFzdGVyQ3JlZGVudGlhbHMpLFxuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQW4gQVdTIGFjY291bnRcbiAqXG4gKiBBbiBBV1MgYWNjb3VudCBhbHdheXMgZXhpc3RzIGluIG9ubHkgb25lIHBhcnRpdGlvbi4gVXN1YWxseSB3ZSBkb24ndCBjYXJlIGFib3V0XG4gKiB0aGUgcGFydGl0aW9uLCBidXQgd2hlbiB3ZSBuZWVkIHRvIGZvcm0gQVJOcyB3ZSBkby5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBBY2NvdW50IHtcbiAgLyoqXG4gICAqIFRoZSBhY2NvdW50IG51bWJlclxuICAgKi9cbiAgcmVhZG9ubHkgYWNjb3VudElkOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBwYXJ0aXRpb24gKCdhd3MnIG9yICdhd3MtY24nIG9yIG90aGVyd2lzZSlcbiAgICovXG4gIHJlYWRvbmx5IHBhcnRpdGlvbjogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX0NPTk5FQ1RJT05fVElNRU9VVCA9IDEwMDAwO1xuY29uc3QgREVGQVVMVF9USU1FT1VUID0gMzAwMDAwO1xuXG4vKipcbiAqIEdldCBIVFRQIG9wdGlvbnMgZm9yIHRoZSBTREtcbiAqXG4gKiBSZWFkIGZyb20gdXNlciBpbnB1dCBvciBlbnZpcm9ubWVudCB2YXJpYWJsZXMuXG4gKlxuICogUmV0dXJucyBhIGNvbXBsZXRlIGBDb25maWd1cmF0aW9uT3B0aW9uc2Agb2JqZWN0IGJlY2F1c2UgdGhhdCdzIHdoZXJlXG4gKiBgY3VzdG9tVXNlckFnZW50YCBsaXZlcywgYnV0IGBodHRwT3B0aW9uc2AgaXMgdGhlIG1vc3QgaW1wb3J0YW50IGF0dHJpYnV0ZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VIdHRwT3B0aW9ucyhvcHRpb25zOiBTZGtIdHRwT3B0aW9ucykge1xuICBjb25zdCBjb25maWc6IENvbmZpZ3VyYXRpb25PcHRpb25zID0ge307XG4gIGNvbmZpZy5odHRwT3B0aW9ucyA9IHt9O1xuXG4gIGNvbmZpZy5odHRwT3B0aW9ucy5jb25uZWN0VGltZW91dCA9IERFRkFVTFRfQ09OTkVDVElPTl9USU1FT1VUO1xuICBjb25maWcuaHR0cE9wdGlvbnMudGltZW91dCA9IERFRkFVTFRfVElNRU9VVDtcblxuICBsZXQgdXNlckFnZW50ID0gb3B0aW9ucy51c2VyQWdlbnQ7XG4gIGlmICh1c2VyQWdlbnQgPT0gbnVsbCkge1xuICAgIC8vIEZpbmQgdGhlIHBhY2thZ2UuanNvbiBmcm9tIHRoZSBtYWluIHRvb2xraXRcbiAgICBjb25zdCBwa2cgPSBKU09OLnBhcnNlKHJlYWRJZlBvc3NpYmxlKHBhdGguam9pbihfX2Rpcm5hbWUsICcuLicsICcuLicsICcuLicsICdwYWNrYWdlLmpzb24nKSkgPz8gJ3t9Jyk7XG4gICAgdXNlckFnZW50ID0gYCR7cGtnLm5hbWV9LyR7cGtnLnZlcnNpb259YDtcbiAgfVxuICBjb25maWcuY3VzdG9tVXNlckFnZW50ID0gdXNlckFnZW50O1xuXG4gIGNvbnN0IGNhQnVuZGxlUGF0aCA9IG9wdGlvbnMuY2FCdW5kbGVQYXRoIHx8IGNhQnVuZGxlUGF0aEZyb21FbnZpcm9ubWVudCgpO1xuICBpZiAoY2FCdW5kbGVQYXRoKSB7XG4gICAgZGVidWcoJ1VzaW5nIENBIGJ1bmRsZSBwYXRoOiAlcycsIGNhQnVuZGxlUGF0aCk7XG4gICAgKGNvbmZpZy5odHRwT3B0aW9ucyBhcyBhbnkpLmNhID0gcmVhZElmUG9zc2libGUoY2FCdW5kbGVQYXRoKTtcbiAgfVxuXG4gIGlmIChvcHRpb25zLnByb3h5QWRkcmVzcykge1xuICAgIGRlYnVnKCdQcm94eSBzZXJ2ZXIgZnJvbSBjb21tYW5kLWxpbmUgYXJndW1lbnRzOiAlcycsIG9wdGlvbnMucHJveHlBZGRyZXNzKTtcbiAgfVxuXG4gIC8vIENvbmZpZ3VyZSB0aGUgcHJveHkgYWdlbnQuIEJ5IGRlZmF1bHQsIHRoaXMgd2lsbCB1c2UgSFRUUFM/X1BST1hZIGFuZFxuICAvLyBOT19QUk9YWSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdG8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IHRvIHVzZSBmb3IgZWFjaFxuICAvLyByZXF1ZXN0LlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuICBjb25zdCBQcm94eUFnZW50ID0gcmVxdWlyZSgncHJveHktYWdlbnQnKTtcbiAgY29uZmlnLmh0dHBPcHRpb25zLmFnZW50ID0gbmV3IFByb3h5QWdlbnQob3B0aW9ucy5wcm94eUFkZHJlc3MpO1xuXG4gIHJldHVybiBjb25maWc7XG59XG5cbi8qKlxuICogRmluZCBhbmQgcmV0dXJuIGEgQ0EgY2VydGlmaWNhdGUgYnVuZGxlIHBhdGggdG8gYmUgcGFzc2VkIGludG8gdGhlIFNESy5cbiAqL1xuZnVuY3Rpb24gY2FCdW5kbGVQYXRoRnJvbUVudmlyb25tZW50KCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGlmIChwcm9jZXNzLmVudi5hd3NfY2FfYnVuZGxlKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52LmF3c19jYV9idW5kbGU7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52LkFXU19DQV9CVU5ETEUpIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuQVdTX0NBX0JVTkRMRTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFJlYWQgYSBmaWxlIGlmIGl0IGV4aXN0cywgb3IgcmV0dXJuIHVuZGVmaW5lZFxuICpcbiAqIE5vdCBhc3luYyBiZWNhdXNlIGl0IGlzIHVzZWQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIHJlYWRJZlBvc3NpYmxlKGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICB0cnkge1xuICAgIGlmICghZnMucGF0aEV4aXN0c1N5bmMoZmlsZW5hbWUpKSB7IHJldHVybiB1bmRlZmluZWQ7IH1cbiAgICByZXR1cm4gZnMucmVhZEZpbGVTeW5jKGZpbGVuYW1lLCB7IGVuY29kaW5nOiAndXRmLTgnIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgZGVidWcoZSk7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgdXNlcm5hbWUgd2l0aCBjaGFyYWN0ZXJzIGludmFsaWQgZm9yIGEgUm9sZVNlc3Npb25OYW1lIHJlbW92ZWRcbiAqXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9TVFMvbGF0ZXN0L0FQSVJlZmVyZW5jZS9BUElfQXNzdW1lUm9sZS5odG1sI0FQSV9Bc3N1bWVSb2xlX1JlcXVlc3RQYXJhbWV0ZXJzXG4gKi9cbmZ1bmN0aW9uIHNhZmVVc2VybmFtZSgpIHtcbiAgcmV0dXJuIG9zLnVzZXJJbmZvKCkudXNlcm5hbWUucmVwbGFjZSgvW15cXHcrPSwuQC1dL2csICdAJyk7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3Igb2J0YWluaW5nIGNyZWRlbnRpYWxzIGZvciBhbiBlbnZpcm9ubWVudFxuICovXG5leHBvcnQgaW50ZXJmYWNlIENyZWRlbnRpYWxzT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBUaGUgQVJOIG9mIHRoZSByb2xlIHRoYXQgbmVlZHMgdG8gYmUgYXNzdW1lZCwgaWYgYW55XG4gICAqL1xuICByZWFkb25seSBhc3N1bWVSb2xlQXJuPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBFeHRlcm5hbCBJRCByZXF1aXJlZCB0byBhc3N1bWUgdGhlIGdpdmVuIHJvbGUuXG4gICAqL1xuICByZWFkb25seSBhc3N1bWVSb2xlRXh0ZXJuYWxJZD86IHN0cmluZztcbn1cblxuLyoqXG4gKiBSZXN1bHQgb2Ygb2J0YWluaW5nIGJhc2UgY3JlZGVudGlhbHNcbiAqL1xudHlwZSBPYnRhaW5CYXNlQ3JlZGVudGlhbHNSZXN1bHQgPVxuICB7IHNvdXJjZTogJ2NvcnJlY3REZWZhdWx0JzsgY3JlZGVudGlhbHM6IEFXUy5DcmVkZW50aWFscyB9XG4gIHwgeyBzb3VyY2U6ICdwbHVnaW4nOyBwbHVnaW5OYW1lOiBzdHJpbmcsIGNyZWRlbnRpYWxzOiBBV1MuQ3JlZGVudGlhbHMgfVxuICB8IHsgc291cmNlOiAnaW5jb3JyZWN0RGVmYXVsdCc7IGNyZWRlbnRpYWxzOiBBV1MuQ3JlZGVudGlhbHM7IGFjY291bnRJZDogc3RyaW5nOyB1bnVzZWRQbHVnaW5zOiBzdHJpbmdbXSB9XG4gIHwgeyBzb3VyY2U6ICdub25lJzsgdW51c2VkUGx1Z2luczogc3RyaW5nW10gfTtcblxuLyoqXG4gKiBJc29sYXRpbmcgdGhlIGNvZGUgdGhhdCB0cmFuc2xhdGVzIGNhbGN1bGF0aW9uIGVycm9ycyBpbnRvIGh1bWFuIGVycm9yIG1lc3NhZ2VzXG4gKlxuICogV2UgY292ZXIgdGhlIGZvbGxvd2luZyBjYXNlczpcbiAqXG4gKiAtIE5vIGNyZWRlbnRpYWxzIGFyZSBhdmFpbGFibGUgYXQgYWxsXG4gKiAtIERlZmF1bHQgY3JlZGVudGlhbHMgYXJlIGZvciB0aGUgd3JvbmcgYWNjb3VudFxuICovXG5mdW5jdGlvbiBmbXRPYnRhaW5DcmVkZW50aWFsc0Vycm9yKHRhcmdldEFjY291bnRJZDogc3RyaW5nLCBvYnRhaW5SZXN1bHQ6IE9idGFpbkJhc2VDcmVkZW50aWFsc1Jlc3VsdCAmIHsgc291cmNlOiAnbm9uZScgfCAnaW5jb3JyZWN0RGVmYXVsdCcgfSk6IHN0cmluZyB7XG4gIGNvbnN0IG1zZyA9IFtgTmVlZCB0byBwZXJmb3JtIEFXUyBjYWxscyBmb3IgYWNjb3VudCAke3RhcmdldEFjY291bnRJZH1gXTtcbiAgc3dpdGNoIChvYnRhaW5SZXN1bHQuc291cmNlKSB7XG4gICAgY2FzZSAnaW5jb3JyZWN0RGVmYXVsdCc6XG4gICAgICBtc2cucHVzaChgYnV0IHRoZSBjdXJyZW50IGNyZWRlbnRpYWxzIGFyZSBmb3IgJHtvYnRhaW5SZXN1bHQuYWNjb3VudElkfWApO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbm9uZSc6XG4gICAgICBtc2cucHVzaCgnYnV0IG5vIGNyZWRlbnRpYWxzIGhhdmUgYmVlbiBjb25maWd1cmVkJyk7XG4gIH1cbiAgaWYgKG9idGFpblJlc3VsdC51bnVzZWRQbHVnaW5zLmxlbmd0aCA+IDApIHtcbiAgICBtc2cucHVzaChgYW5kIG5vbmUgb2YgdGhlc2UgcGx1Z2lucyBmb3VuZCBhbnk6ICR7b2J0YWluUmVzdWx0LnVudXNlZFBsdWdpbnMuam9pbignLCAnKX1gKTtcbiAgfVxuICByZXR1cm4gbXNnLmpvaW4oJywgJyk7XG59XG5cbi8qKlxuICogRm9ybWF0IGEgbWVzc2FnZSBpbmRpY2F0aW5nIHdoZXJlIHdlIGdvdCBiYXNlIGNyZWRlbnRpYWxzIGZvciB0aGUgYXNzdW1lIHJvbGVcbiAqXG4gKiBXZSBjb3ZlciB0aGUgZm9sbG93aW5nIGNhc2VzOlxuICpcbiAqIC0gRGVmYXVsdCBjcmVkZW50aWFscyBmb3IgdGhlIHJpZ2h0IGFjY291bnRcbiAqIC0gRGVmYXVsdCBjcmVkZW50aWFscyBmb3IgdGhlIHdyb25nIGFjY291bnRcbiAqIC0gQ3JlZGVudGlhbHMgcmV0dXJuZWQgZnJvbSBhIHBsdWdpblxuICovXG5mdW5jdGlvbiBmbXRPYnRhaW5lZENyZWRlbnRpYWxzKFxuICBvYnRhaW5SZXN1bHQ6IEV4Y2x1ZGU8T2J0YWluQmFzZUNyZWRlbnRpYWxzUmVzdWx0LCB7IHNvdXJjZTogJ25vbmUnIH0+KTogc3RyaW5nIHtcbiAgc3dpdGNoIChvYnRhaW5SZXN1bHQuc291cmNlKSB7XG4gICAgY2FzZSAnY29ycmVjdERlZmF1bHQnOlxuICAgICAgcmV0dXJuICdjdXJyZW50IGNyZWRlbnRpYWxzJztcbiAgICBjYXNlICdwbHVnaW4nOlxuICAgICAgcmV0dXJuIGBjcmVkZW50aWFscyByZXR1cm5lZCBieSBwbHVnaW4gJyR7b2J0YWluUmVzdWx0LnBsdWdpbk5hbWV9J2A7XG4gICAgY2FzZSAnaW5jb3JyZWN0RGVmYXVsdCc6XG4gICAgICBjb25zdCBtc2cgPSBbXTtcbiAgICAgIG1zZy5wdXNoKGBjdXJyZW50IGNyZWRlbnRpYWxzICh3aGljaCBhcmUgZm9yIGFjY291bnQgJHtvYnRhaW5SZXN1bHQuYWNjb3VudElkfWApO1xuXG4gICAgICBpZiAob2J0YWluUmVzdWx0LnVudXNlZFBsdWdpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBtc2cucHVzaChgLCBhbmQgbm9uZSBvZiB0aGUgZm9sbG93aW5nIHBsdWdpbnMgcHJvdmlkZWQgY3JlZGVudGlhbHM6ICR7b2J0YWluUmVzdWx0LnVudXNlZFBsdWdpbnMuam9pbignLCAnKX1gKTtcbiAgICAgIH1cbiAgICAgIG1zZy5wdXNoKCcpJyk7XG5cbiAgICAgIHJldHVybiBtc2cuam9pbignJyk7XG4gIH1cbn1cbiJdfQ==