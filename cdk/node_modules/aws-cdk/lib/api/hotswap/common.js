"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.lowerCaseFirstCharacter = exports.transformObjectKeys = exports.HotswappableChangeCandidate = exports.ChangeHotswapImpact = exports.ICON = void 0;
exports.ICON = 'âœ¨';
/**
 * An enum that represents the result of detection whether a given change can be hotswapped.
 */
var ChangeHotswapImpact;
(function (ChangeHotswapImpact) {
    /**
     * This result means that the given change cannot be hotswapped,
     * and requires a full deployment.
     */
    ChangeHotswapImpact["REQUIRES_FULL_DEPLOYMENT"] = "requires-full-deployment";
    /**
     * This result means that the given change can be safely be ignored when determining
     * whether the given Stack can be hotswapped or not
     * (for example, it's a change to the CDKMetadata resource).
     */
    ChangeHotswapImpact["IRRELEVANT"] = "irrelevant";
})(ChangeHotswapImpact = exports.ChangeHotswapImpact || (exports.ChangeHotswapImpact = {}));
/**
 * Represents a change that can be hotswapped.
 */
class HotswappableChangeCandidate {
    constructor(newValue, propertyUpdates) {
        this.newValue = newValue;
        this.propertyUpdates = propertyUpdates;
    }
}
exports.HotswappableChangeCandidate = HotswappableChangeCandidate;
/**
 * This function transforms all keys (recursively) in the provided `val` object.
 *
 * @param val The object whose keys need to be transformed.
 * @param transform The function that will be applied to each key.
 * @returns A new object with the same values as `val`, but with all keys transformed according to `transform`.
 */
function transformObjectKeys(val, transform) {
    if (val == null || typeof val !== 'object') {
        return val;
    }
    if (Array.isArray(val)) {
        return val.map((input) => transformObjectKeys(input, transform));
    }
    const ret = {};
    for (const [k, v] of Object.entries(val)) {
        ret[transform(k)] = transformObjectKeys(v, transform);
    }
    return ret;
}
exports.transformObjectKeys = transformObjectKeys;
/**
 * This function lower cases the first character of the string provided.
 */
function lowerCaseFirstCharacter(str) {
    return str.length > 0 ? `${str[0].toLowerCase()}${str.substr(1)}` : str;
}
exports.lowerCaseFirstCharacter = lowerCaseFirstCharacter;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUdhLFFBQUEsSUFBSSxHQUFHLEdBQUcsQ0FBQztBQW9CeEI7O0dBRUc7QUFDSCxJQUFZLG1CQWFYO0FBYkQsV0FBWSxtQkFBbUI7SUFDN0I7OztPQUdHO0lBQ0gsNEVBQXFELENBQUE7SUFFckQ7Ozs7T0FJRztJQUNILGdEQUF5QixDQUFBO0FBQzNCLENBQUMsRUFiVyxtQkFBbUIsR0FBbkIsMkJBQW1CLEtBQW5CLDJCQUFtQixRQWE5QjtBQUlEOztHQUVHO0FBQ0gsTUFBYSwyQkFBMkI7SUFXdEMsWUFBbUIsUUFBMkIsRUFBRSxlQUFvRTtRQUNsSCxJQUFJLENBQUMsUUFBUSxHQUFHLFFBQVEsQ0FBQztRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLGVBQWUsQ0FBQztJQUN6QyxDQUFDO0NBQ0Y7QUFmRCxrRUFlQztBQUVEOzs7Ozs7R0FNRztBQUNILFNBQWdCLG1CQUFtQixDQUFDLEdBQVEsRUFBRSxTQUFrQztJQUM5RSxJQUFJLEdBQUcsSUFBSSxJQUFJLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxFQUFFO1FBQzFDLE9BQU8sR0FBRyxDQUFDO0tBQ1o7SUFDRCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDdEIsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsS0FBVSxFQUFFLEVBQUUsQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBQztLQUN2RTtJQUNELE1BQU0sR0FBRyxHQUEwQixFQUFFLENBQUM7SUFDdEMsS0FBSyxNQUFNLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDeEMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLG1CQUFtQixDQUFDLENBQUMsRUFBRSxTQUFTLENBQUMsQ0FBQztLQUN2RDtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ2IsQ0FBQztBQVpELGtEQVlDO0FBRUQ7O0dBRUc7QUFDSCxTQUFnQix1QkFBdUIsQ0FBQyxHQUFXO0lBQ2pELE9BQU8sR0FBRyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDO0FBQzFFLENBQUM7QUFGRCwwREFFQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNmbl9kaWZmIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkZm9ybWF0aW9uLWRpZmYnO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4uL2F3cy1hdXRoJztcblxuZXhwb3J0IGNvbnN0IElDT04gPSAn4pyoJztcblxuLyoqXG4gKiBBbiBpbnRlcmZhY2UgdGhhdCByZXByZXNlbnRzIGEgY2hhbmdlIHRoYXQgY2FuIGJlIGRlcGxveWVkIGluIGEgc2hvcnQtY2lyY3VpdCBtYW5uZXIuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSG90c3dhcE9wZXJhdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgc2VydmljZSBiZWluZyBob3Rzd2FwcGVkLlxuICAgKiBVc2VkIHRvIHNldCBhIGN1c3RvbSBVc2VyLUFnZW50IGZvciBTREsgY2FsbHMuXG4gICAqL1xuICByZWFkb25seSBzZXJ2aWNlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lcyBvZiB0aGUgcmVzb3VyY2VzIGJlaW5nIGhvdHN3YXBwZWQuXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZU5hbWVzOiBzdHJpbmdbXTtcblxuICBhcHBseShzZGs6IElTREspOiBQcm9taXNlPGFueT47XG59XG5cbi8qKlxuICogQW4gZW51bSB0aGF0IHJlcHJlc2VudHMgdGhlIHJlc3VsdCBvZiBkZXRlY3Rpb24gd2hldGhlciBhIGdpdmVuIGNoYW5nZSBjYW4gYmUgaG90c3dhcHBlZC5cbiAqL1xuZXhwb3J0IGVudW0gQ2hhbmdlSG90c3dhcEltcGFjdCB7XG4gIC8qKlxuICAgKiBUaGlzIHJlc3VsdCBtZWFucyB0aGF0IHRoZSBnaXZlbiBjaGFuZ2UgY2Fubm90IGJlIGhvdHN3YXBwZWQsXG4gICAqIGFuZCByZXF1aXJlcyBhIGZ1bGwgZGVwbG95bWVudC5cbiAgICovXG4gIFJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVCA9ICdyZXF1aXJlcy1mdWxsLWRlcGxveW1lbnQnLFxuXG4gIC8qKlxuICAgKiBUaGlzIHJlc3VsdCBtZWFucyB0aGF0IHRoZSBnaXZlbiBjaGFuZ2UgY2FuIGJlIHNhZmVseSBiZSBpZ25vcmVkIHdoZW4gZGV0ZXJtaW5pbmdcbiAgICogd2hldGhlciB0aGUgZ2l2ZW4gU3RhY2sgY2FuIGJlIGhvdHN3YXBwZWQgb3Igbm90XG4gICAqIChmb3IgZXhhbXBsZSwgaXQncyBhIGNoYW5nZSB0byB0aGUgQ0RLTWV0YWRhdGEgcmVzb3VyY2UpLlxuICAgKi9cbiAgSVJSRUxFVkFOVCA9ICdpcnJlbGV2YW50Jyxcbn1cblxuZXhwb3J0IHR5cGUgQ2hhbmdlSG90c3dhcFJlc3VsdCA9IEhvdHN3YXBPcGVyYXRpb24gfCBDaGFuZ2VIb3Rzd2FwSW1wYWN0O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBjaGFuZ2UgdGhhdCBjYW4gYmUgaG90c3dhcHBlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSB7XG4gIC8qKlxuICAgKiBUaGUgdmFsdWUgdGhlIHJlc291cmNlIGlzIGJlaW5nIHVwZGF0ZWQgdG8uXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgbmV3VmFsdWU6IGNmbl9kaWZmLlJlc291cmNlO1xuXG4gIC8qKlxuICAgKiBUaGUgY2hhbmdlcyBtYWRlIHRvIHRoZSByZXNvdXJjZSBwcm9wZXJ0aWVzLlxuICAgKi9cbiAgcHVibGljIHJlYWRvbmx5IHByb3BlcnR5VXBkYXRlczogeyBba2V5OiBzdHJpbmddOiBjZm5fZGlmZi5Qcm9wZXJ0eURpZmZlcmVuY2U8YW55PiB9O1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcihuZXdWYWx1ZTogY2ZuX2RpZmYuUmVzb3VyY2UsIHByb3BlcnR5VXBkYXRlczogeyBba2V5OiBzdHJpbmddOiBjZm5fZGlmZi5Qcm9wZXJ0eURpZmZlcmVuY2U8YW55PiB9KSB7XG4gICAgdGhpcy5uZXdWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIHRoaXMucHJvcGVydHlVcGRhdGVzID0gcHJvcGVydHlVcGRhdGVzO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiB0cmFuc2Zvcm1zIGFsbCBrZXlzIChyZWN1cnNpdmVseSkgaW4gdGhlIHByb3ZpZGVkIGB2YWxgIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gdmFsIFRoZSBvYmplY3Qgd2hvc2Uga2V5cyBuZWVkIHRvIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHRyYW5zZm9ybSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWQgdG8gZWFjaCBrZXkuXG4gKiBAcmV0dXJucyBBIG5ldyBvYmplY3Qgd2l0aCB0aGUgc2FtZSB2YWx1ZXMgYXMgYHZhbGAsIGJ1dCB3aXRoIGFsbCBrZXlzIHRyYW5zZm9ybWVkIGFjY29yZGluZyB0byBgdHJhbnNmb3JtYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyYW5zZm9ybU9iamVjdEtleXModmFsOiBhbnksIHRyYW5zZm9ybTogKHN0cjogc3RyaW5nKSA9PiBzdHJpbmcpOiBhbnkge1xuICBpZiAodmFsID09IG51bGwgfHwgdHlwZW9mIHZhbCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gdmFsO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICByZXR1cm4gdmFsLm1hcCgoaW5wdXQ6IGFueSkgPT4gdHJhbnNmb3JtT2JqZWN0S2V5cyhpbnB1dCwgdHJhbnNmb3JtKSk7XG4gIH1cbiAgY29uc3QgcmV0OiB7IFtrOiBzdHJpbmddOiBhbnk7IH0gPSB7fTtcbiAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXModmFsKSkge1xuICAgIHJldFt0cmFuc2Zvcm0oayldID0gdHJhbnNmb3JtT2JqZWN0S2V5cyh2LCB0cmFuc2Zvcm0pO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBsb3dlciBjYXNlcyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIHRoZSBzdHJpbmcgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb3dlckNhc2VGaXJzdENoYXJhY3RlcihzdHI6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiBzdHIubGVuZ3RoID4gMCA/IGAke3N0clswXS50b0xvd2VyQ2FzZSgpfSR7c3RyLnN1YnN0cigxKX1gIDogc3RyO1xufVxuIl19