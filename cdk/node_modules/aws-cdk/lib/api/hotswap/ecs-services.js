"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = void 0;
const AWS = require("aws-sdk");
const common_1 = require("./common");
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate) {
    // the only resource change we should allow is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    for (const updatedPropName in change.propertyUpdates) {
        // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
        // it contains the image and environment variables, so seems like a safe bet for now.
        // We might revisit this decision in the future though!
        if (updatedPropName !== 'ContainerDefinitions') {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
        const containerDefinitionsDifference = (change.propertyUpdates)[updatedPropName];
        if (containerDefinitionsDifference.newValue === undefined) {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    // at this point, we know the TaskDefinition can be hotswapped
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter(r => r.Type === 'AWS::ECS::Service');
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0 ||
        resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if there are either no resources referencing the TaskDefinition,
        // or something besides an ECS Service is referencing it,
        // hotswap is not possible
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    const taskDefinitionResource = change.newValue.Properties;
    // first, let's get the name of the family
    const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, taskDefinitionResource === null || taskDefinitionResource === void 0 ? void 0 : taskDefinitionResource.Family);
    if (!familyNameOrArn) {
        // if the Family property has not bee provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
        // so, take the 6th element, at index 5, and split it on '/'
        ? familyNameOrArnParts[5].split('/')[1]
        // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
        : familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    const evaluatedTaskDef = {
        ...await evaluateCfnTemplate.evaluateCfnExpression({
            ...(taskDefinitionResource !== null && taskDefinitionResource !== void 0 ? taskDefinitionResource : {}),
            Family: undefined,
        }),
        Family: family,
    };
    return new EcsServiceHotswapOperation(evaluatedTaskDef, ecsServicesReferencingTaskDef);
}
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
class EcsServiceHotswapOperation {
    constructor(taskDefinitionResource, servicesReferencingTaskDef) {
        this.taskDefinitionResource = taskDefinitionResource;
        this.servicesReferencingTaskDef = servicesReferencingTaskDef;
        this.service = 'ecs-service';
        this.resourceNames = [];
        this.resourceNames = servicesReferencingTaskDef.map(ecsService => `ECS Service '${ecsService.serviceArn.split('/')[2]}'`);
    }
    async apply(sdk) {
        var _a;
        // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
        // we need to lowercase the evaluated TaskDef from CloudFormation,
        // as the AWS SDK uses lowercase property names for these
        const lowercasedTaskDef = common_1.transformObjectKeys(this.taskDefinitionResource, common_1.lowerCaseFirstCharacter);
        const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef).promise();
        const taskDefRevArn = (_a = registerTaskDefResponse.taskDefinition) === null || _a === void 0 ? void 0 : _a.taskDefinitionArn;
        // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
        const servicePerClusterUpdates = {};
        for (const ecsService of this.servicesReferencingTaskDef) {
            const clusterName = ecsService.serviceArn.split('/')[1];
            const existingClusterPromises = servicePerClusterUpdates[clusterName];
            let clusterPromises;
            if (existingClusterPromises) {
                clusterPromises = existingClusterPromises;
            }
            else {
                clusterPromises = [];
                servicePerClusterUpdates[clusterName] = clusterPromises;
            }
            clusterPromises.push({
                promise: sdk.ecs().updateService({
                    service: ecsService.serviceArn,
                    taskDefinition: taskDefRevArn,
                    cluster: clusterName,
                    forceNewDeployment: true,
                    deploymentConfiguration: {
                        minimumHealthyPercent: 0,
                    },
                }).promise(),
                ecsService: ecsService,
            });
        }
        await Promise.all(Object.values(servicePerClusterUpdates)
            .map(clusterUpdates => {
            return Promise.all(clusterUpdates.map(serviceUpdate => serviceUpdate.promise));
        }));
        // Step 3 - wait for the service deployments triggered in Step 2 to finish
        // configure a custom Waiter
        sdk.ecs().api.waiters.deploymentToFinish = {
            name: 'DeploymentToFinish',
            operation: 'describeServices',
            delay: 10,
            maxAttempts: 60,
            acceptors: [
                {
                    matcher: 'pathAny',
                    argument: 'failures[].reason',
                    expected: 'MISSING',
                    state: 'failure',
                },
                {
                    matcher: 'pathAny',
                    argument: 'services[].status',
                    expected: 'DRAINING',
                    state: 'failure',
                },
                {
                    matcher: 'pathAny',
                    argument: 'services[].status',
                    expected: 'INACTIVE',
                    state: 'failure',
                },
                {
                    matcher: 'path',
                    argument: "length(services[].deployments[? status == 'PRIMARY' && runningCount < desiredCount][]) == `0`",
                    expected: true,
                    state: 'success',
                },
            ],
        };
        // create a custom Waiter that uses the deploymentToFinish configuration added above
        const deploymentWaiter = new AWS.ResourceWaiter(sdk.ecs(), 'deploymentToFinish');
        // wait for all of the waiters to finish
        return Promise.all(Object.entries(servicePerClusterUpdates).map(([clusterName, serviceUpdates]) => {
            return deploymentWaiter.wait({
                cluster: clusterName,
                services: serviceUpdates.map(serviceUpdate => serviceUpdate.ecsService.serviceArn),
            }).promise();
        }));
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUcvQixxQ0FBaUs7QUFFMUosS0FBSyxVQUFVLDhCQUE4QixDQUNsRCxTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1EO0lBRTNHLG9FQUFvRTtJQUNwRSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLDBCQUEwQixFQUFFO1FBQ3ZELE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7S0FDckQ7SUFFRCxLQUFLLE1BQU0sZUFBZSxJQUFJLE1BQU0sQ0FBQyxlQUFlLEVBQUU7UUFDcEQscUZBQXFGO1FBQ3JGLHFGQUFxRjtRQUNyRix1REFBdUQ7UUFDdkQsSUFBSSxlQUFlLEtBQUssc0JBQXNCLEVBQUU7WUFDOUMsT0FBTyw0QkFBbUIsQ0FBQyx3QkFBd0IsQ0FBQztTQUNyRDtRQUNELE1BQU0sOEJBQThCLEdBQUcsQ0FBQyxNQUFNLENBQUMsZUFBZSxDQUFDLENBQUMsZUFBZSxDQUFDLENBQUM7UUFDakYsSUFBSSw4QkFBOEIsQ0FBQyxRQUFRLEtBQUssU0FBUyxFQUFFO1lBQ3pELE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7U0FDckQ7S0FDRjtJQUNELDhEQUE4RDtJQUU5RCx1RUFBdUU7SUFDdkUsTUFBTSwyQkFBMkIsR0FBRyxtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRixNQUFNLHFDQUFxQyxHQUFHLDJCQUEyQixDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssbUJBQW1CLENBQUMsQ0FBQztJQUN0SCxNQUFNLDZCQUE2QixHQUFHLElBQUksS0FBSyxFQUFjLENBQUM7SUFDOUQsS0FBSyxNQUFNLGtCQUFrQixJQUFJLHFDQUFxQyxFQUFFO1FBQ3RFLE1BQU0sVUFB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QUFhLENBQUMsRUFBRSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsVUFBVSxDQUFDO2FBQ25GLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUNmLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDTixDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlIH0gZnJvbSAnLi4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuaW1wb3J0IHsgQ2hhbmdlSG90c3dhcEltcGFjdCwgQ2hhbmdlSG90c3dhcFJlc3VsdCwgSG90c3dhcE9wZXJhdGlvbiwgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBsb3dlckNhc2VGaXJzdENoYXJhY3RlciwgdHJhbnNmb3JtT2JqZWN0S2V5cyB9IGZyb20gJy4vY29tbW9uJztcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGlzSG90c3dhcHBhYmxlRWNzU2VydmljZUNoYW5nZShcbiAgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPENoYW5nZUhvdHN3YXBSZXN1bHQ+IHtcbiAgLy8gdGhlIG9ubHkgcmVzb3VyY2UgY2hhbmdlIHdlIHNob3VsZCBhbGxvdyBpcyBhbiBFQ1MgVGFza0RlZmluaXRpb25cbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlICE9PSAnQVdTOjpFQ1M6OlRhc2tEZWZpbml0aW9uJykge1xuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuXG4gIGZvciAoY29uc3QgdXBkYXRlZFByb3BOYW1lIGluIGNoYW5nZS5wcm9wZXJ0eVVwZGF0ZXMpIHtcbiAgICAvLyBXZSBvbmx5IGFsbG93IGEgY2hhbmdlIGluIHRoZSBDb250YWluZXJEZWZpbml0aW9ucyBvZiB0aGUgVGFza0RlZmluaXRpb24gZm9yIG5vdyAtXG4gICAgLy8gaXQgY29udGFpbnMgdGhlIGltYWdlIGFuZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHNvIHNlZW1zIGxpa2UgYSBzYWZlIGJldCBmb3Igbm93LlxuICAgIC8vIFdlIG1pZ2h0IHJldmlzaXQgdGhpcyBkZWNpc2lvbiBpbiB0aGUgZnV0dXJlIHRob3VnaCFcbiAgICBpZiAodXBkYXRlZFByb3BOYW1lICE9PSAnQ29udGFpbmVyRGVmaW5pdGlvbnMnKSB7XG4gICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRhaW5lckRlZmluaXRpb25zRGlmZmVyZW5jZSA9IChjaGFuZ2UucHJvcGVydHlVcGRhdGVzKVt1cGRhdGVkUHJvcE5hbWVdO1xuICAgIGlmIChjb250YWluZXJEZWZpbml0aW9uc0RpZmZlcmVuY2UubmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICAgIH1cbiAgfVxuICAvLyBhdCB0aGlzIHBvaW50LCB3ZSBrbm93IHRoZSBUYXNrRGVmaW5pdGlvbiBjYW4gYmUgaG90c3dhcHBlZFxuXG4gIC8vIGZpbmQgYWxsIEVDUyBTZXJ2aWNlcyB0aGF0IHJlZmVyZW5jZSB0aGUgVGFza0RlZmluaXRpb24gdGhhdCBjaGFuZ2VkXG4gIGNvbnN0IHJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZiA9IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyhsb2dpY2FsSWQpO1xuICBjb25zdCBlY3NTZXJ2aWNlUmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmZpbHRlcihyID0+IHIuVHlwZSA9PT0gJ0FXUzo6RUNTOjpTZXJ2aWNlJyk7XG4gIGNvbnN0IGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gbmV3IEFycmF5PEVjc1NlcnZpY2U+KCk7XG4gIGZvciAoY29uc3QgZWNzU2VydmljZVJlc291cmNlIG9mIGVjc1NlcnZpY2VSZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYpIHtcbiAgICBjb25zdCBzZXJ2aWNlQXJuID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUGh5c2ljYWxOYW1lRm9yKGVjc1NlcnZpY2VSZXNvdXJjZS5Mb2dpY2FsSWQpO1xuICAgIGlmIChzZXJ2aWNlQXJuKSB7XG4gICAgICBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZi5wdXNoKHsgc2VydmljZUFybiB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmxlbmd0aCA9PT0gMCB8fFxuICAgICAgcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmxlbmd0aCA+IGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmxlbmd0aCkge1xuICAgIC8vIGlmIHRoZXJlIGFyZSBlaXRoZXIgbm8gcmVzb3VyY2VzIHJlZmVyZW5jaW5nIHRoZSBUYXNrRGVmaW5pdGlvbixcbiAgICAvLyBvciBzb21ldGhpbmcgYmVzaWRlcyBhbiBFQ1MgU2VydmljZSBpcyByZWZlcmVuY2luZyBpdCxcbiAgICAvLyBob3Rzd2FwIGlzIG5vdCBwb3NzaWJsZVxuICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgfVxuXG4gIGNvbnN0IHRhc2tEZWZpbml0aW9uUmVzb3VyY2UgPSBjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcztcbiAgLy8gZmlyc3QsIGxldCdzIGdldCB0aGUgbmFtZSBvZiB0aGUgZmFtaWx5XG4gIGNvbnN0IGZhbWlseU5hbWVPckFybiA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXN0YWJsaXNoUmVzb3VyY2VQaHlzaWNhbE5hbWUobG9naWNhbElkLCB0YXNrRGVmaW5pdGlvblJlc291cmNlPy5GYW1pbHkpO1xuICBpZiAoIWZhbWlseU5hbWVPckFybikge1xuICAgIC8vIGlmIHRoZSBGYW1pbHkgcHJvcGVydHkgaGFzIG5vdCBiZWUgcHJvdmlkZWQsIGFuZCB3ZSBjYW4ndCBmaW5kIGl0IGluIHRoZSBjdXJyZW50IFN0YWNrLFxuICAgIC8vIHRoaXMgbWVhbnMgaG90c3dhcHBpbmcgaXMgbm90IHBvc3NpYmxlXG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG4gIC8vIHRoZSBwaHlzaWNhbCBuYW1lIG9mIHRoZSBUYXNrIERlZmluaXRpb24gaW4gQ2xvdWRGb3JtYXRpb24gaW5jbHVkZXMgaXRzIGN1cnJlbnQgcmV2aXNpb24gbnVtYmVyIGF0IHRoZSBlbmQsXG4gIC8vIHJlbW92ZSBpdCBpZiBuZWVkZWRcbiAgY29uc3QgZmFtaWx5TmFtZU9yQXJuUGFydHMgPSBmYW1pbHlOYW1lT3JBcm4uc3BsaXQoJzonKTtcbiAgY29uc3QgZmFtaWx5ID0gZmFtaWx5TmFtZU9yQXJuUGFydHMubGVuZ3RoID4gMVxuICAgIC8vIGZhbWlseU5hbWVPckFybiBpcyBhY3R1YWxseSBhbiBBUk4sIG9mIHRoZSBmb3JtYXQgJ2Fybjphd3M6ZWNzOnJlZ2lvbjphY2NvdW50OnRhc2stZGVmaW5pdGlvbi88ZmFtaWx5LW5hbWU+OjxyZXZpc2lvbi1ucj4nXG4gICAgLy8gc28sIHRha2UgdGhlIDZ0aCBlbGVtZW50LCBhdCBpbmRleCA1LCBhbmQgc3BsaXQgaXQgb24gJy8nXG4gICAgPyBmYW1pbHlOYW1lT3JBcm5QYXJ0c1s1XS5zcGxpdCgnLycpWzFdXG4gICAgLy8gb3RoZXJ3aXNlLCBmYW1pbHlOYW1lT3JBcm4gaXMganVzdCB0aGUgc2ltcGxlIG5hbWUgZXZhbHVhdGVkIGZyb20gdGhlIENsb3VkRm9ybWF0aW9uIHRlbXBsYXRlXG4gICAgOiBmYW1pbHlOYW1lT3JBcm47XG4gIC8vIHRoZW4sIGxldCdzIGV2YWx1YXRlIHRoZSBib2R5IG9mIHRoZSByZW1haW5kZXIgb2YgdGhlIFRhc2tEZWYgKHdpdGhvdXQgdGhlIEZhbWlseSBwcm9wZXJ0eSlcbiAgY29uc3QgZXZhbHVhdGVkVGFza0RlZiA9IHtcbiAgICAuLi5hd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih7XG4gICAgICAuLi4odGFza0RlZmluaXRpb25SZXNvdXJjZSA/PyB7fSksXG4gICAgICBGYW1pbHk6IHVuZGVmaW5lZCxcbiAgICB9KSxcbiAgICBGYW1pbHk6IGZhbWlseSxcbiAgfTtcbiAgcmV0dXJuIG5ldyBFY3NTZXJ2aWNlSG90c3dhcE9wZXJhdGlvbihldmFsdWF0ZWRUYXNrRGVmLCBlY3NTZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZik7XG59XG5cbmludGVyZmFjZSBFY3NTZXJ2aWNlIHtcbiAgcmVhZG9ubHkgc2VydmljZUFybjogc3RyaW5nO1xufVxuXG5jbGFzcyBFY3NTZXJ2aWNlSG90c3dhcE9wZXJhdGlvbiBpbXBsZW1lbnRzIEhvdHN3YXBPcGVyYXRpb24ge1xuICBwdWJsaWMgcmVhZG9ubHkgc2VydmljZSA9ICdlY3Mtc2VydmljZSc7XG4gIHB1YmxpYyByZWFkb25seSByZXNvdXJjZU5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgdGFza0RlZmluaXRpb25SZXNvdXJjZTogYW55LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgc2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWY6IEVjc1NlcnZpY2VbXSxcbiAgKSB7XG4gICAgdGhpcy5yZXNvdXJjZU5hbWVzID0gc2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubWFwKGVjc1NlcnZpY2UgPT5cbiAgICAgIGBFQ1MgU2VydmljZSAnJHtlY3NTZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsyXX0nYCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYXBwbHkoc2RrOiBJU0RLKTogUHJvbWlzZTxhbnk+IHtcbiAgICAvLyBTdGVwIDEgLSB1cGRhdGUgdGhlIGNoYW5nZWQgVGFza0RlZmluaXRpb24sIGNyZWF0aW5nIGEgbmV3IFRhc2tEZWZpbml0aW9uIFJldmlzaW9uXG4gICAgLy8gd2UgbmVlZCB0byBsb3dlcmNhc2UgdGhlIGV2YWx1YXRlZCBUYXNrRGVmIGZyb20gQ2xvdWRGb3JtYXRpb24sXG4gICAgLy8gYXMgdGhlIEFXUyBTREsgdXNlcyBsb3dlcmNhc2UgcHJvcGVydHkgbmFtZXMgZm9yIHRoZXNlXG4gICAgY29uc3QgbG93ZXJjYXNlZFRhc2tEZWYgPSB0cmFuc2Zvcm1PYmplY3RLZXlzKHRoaXMudGFza0RlZmluaXRpb25SZXNvdXJjZSwgbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXIpO1xuICAgIGNvbnN0IHJlZ2lzdGVyVGFza0RlZlJlc3BvbnNlID0gYXdhaXQgc2RrLmVjcygpLnJlZ2lzdGVyVGFza0RlZmluaXRpb24obG93ZXJjYXNlZFRhc2tEZWYpLnByb21pc2UoKTtcbiAgICBjb25zdCB0YXNrRGVmUmV2QXJuID0gcmVnaXN0ZXJUYXNrRGVmUmVzcG9uc2UudGFza0RlZmluaXRpb24/LnRhc2tEZWZpbml0aW9uQXJuO1xuXG4gICAgLy8gU3RlcCAyIC0gdXBkYXRlIHRoZSBzZXJ2aWNlcyB1c2luZyB0aGF0IFRhc2tEZWZpbml0aW9uIHRvIHBvaW50IHRvIHRoZSBuZXcgVGFza0RlZmluaXRpb24gUmV2aXNpb25cbiAgICBjb25zdCBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXM6IHsgW2NsdXN0ZXI6IHN0cmluZ106IEFycmF5PHsgcHJvbWlzZTogUHJvbWlzZTxhbnk+LCBlY3NTZXJ2aWNlOiBFY3NTZXJ2aWNlIH0+IH0gPSB7fTtcbiAgICBmb3IgKGNvbnN0IGVjc1NlcnZpY2Ugb2YgdGhpcy5zZXJ2aWNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgICAgY29uc3QgY2x1c3Rlck5hbWUgPSBlY3NTZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsxXTtcblxuICAgICAgY29uc3QgZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXMgPSBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXNbY2x1c3Rlck5hbWVdO1xuICAgICAgbGV0IGNsdXN0ZXJQcm9taXNlczogQXJyYXk8eyBwcm9taXNlOiBQcm9taXNlPGFueT4sIGVjc1NlcnZpY2U6IEVjc1NlcnZpY2UgfT47XG4gICAgICBpZiAoZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXMpIHtcbiAgICAgICAgY2x1c3RlclByb21pc2VzID0gZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbHVzdGVyUHJvbWlzZXMgPSBbXTtcbiAgICAgICAgc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzW2NsdXN0ZXJOYW1lXSA9IGNsdXN0ZXJQcm9taXNlcztcbiAgICAgIH1cblxuICAgICAgY2x1c3RlclByb21pc2VzLnB1c2goe1xuICAgICAgICBwcm9taXNlOiBzZGsuZWNzKCkudXBkYXRlU2VydmljZSh7XG4gICAgICAgICAgc2VydmljZTogZWNzU2VydmljZS5zZXJ2aWNlQXJuLFxuICAgICAgICAgIHRhc2tEZWZpbml0aW9uOiB0YXNrRGVmUmV2QXJuLFxuICAgICAgICAgIGNsdXN0ZXI6IGNsdXN0ZXJOYW1lLFxuICAgICAgICAgIGZvcmNlTmV3RGVwbG95bWVudDogdHJ1ZSxcbiAgICAgICAgICBkZXBsb3ltZW50Q29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgbWluaW11bUhlYWx0aHlQZXJjZW50OiAwLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0pLnByb21pc2UoKSxcbiAgICAgICAgZWNzU2VydmljZTogZWNzU2VydmljZSxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QudmFsdWVzKHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlcylcbiAgICAgIC5tYXAoY2x1c3RlclVwZGF0ZXMgPT4ge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoY2x1c3RlclVwZGF0ZXMubWFwKHNlcnZpY2VVcGRhdGUgPT4gc2VydmljZVVwZGF0ZS5wcm9taXNlKSk7XG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgLy8gU3RlcCAzIC0gd2FpdCBmb3IgdGhlIHNlcnZpY2UgZGVwbG95bWVudHMgdHJpZ2dlcmVkIGluIFN0ZXAgMiB0byBmaW5pc2hcbiAgICAvLyBjb25maWd1cmUgYSBjdXN0b20gV2FpdGVyXG4gICAgKHNkay5lY3MoKSBhcyBhbnkpLmFwaS53YWl0ZXJzLmRlcGxveW1lbnRUb0ZpbmlzaCA9IHtcbiAgICAgIG5hbWU6ICdEZXBsb3ltZW50VG9GaW5pc2gnLFxuICAgICAgb3BlcmF0aW9uOiAnZGVzY3JpYmVTZXJ2aWNlcycsXG4gICAgICBkZWxheTogMTAsXG4gICAgICBtYXhBdHRlbXB0czogNjAsXG4gICAgICBhY2NlcHRvcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXI6ICdwYXRoQW55JyxcbiAgICAgICAgICBhcmd1bWVudDogJ2ZhaWx1cmVzW10ucmVhc29uJyxcbiAgICAgICAgICBleHBlY3RlZDogJ01JU1NJTkcnLFxuICAgICAgICAgIHN0YXRlOiAnZmFpbHVyZScsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgYXJndW1lbnQ6ICdzZXJ2aWNlc1tdLnN0YXR1cycsXG4gICAgICAgICAgZXhwZWN0ZWQ6ICdEUkFJTklORycsXG4gICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXI6ICdwYXRoQW55JyxcbiAgICAgICAgICBhcmd1bWVudDogJ3NlcnZpY2VzW10uc3RhdHVzJyxcbiAgICAgICAgICBleHBlY3RlZDogJ0lOQUNUSVZFJyxcbiAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcjogJ3BhdGgnLFxuICAgICAgICAgIGFyZ3VtZW50OiBcImxlbmd0aChzZXJ2aWNlc1tdLmRlcGxveW1lbnRzWz8gc3RhdHVzID09ICdQUklNQVJZJyAmJiBydW5uaW5nQ291bnQgPCBkZXNpcmVkQ291bnRdW10pID09IGAwYFwiLFxuICAgICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICAgIHN0YXRlOiAnc3VjY2VzcycsXG4gICAgICAgIH0sXG4gICAgICBdLFxuICAgIH07XG4gICAgLy8gY3JlYXRlIGEgY3VzdG9tIFdhaXRlciB0aGF0IHVzZXMgdGhlIGRlcGxveW1lbnRUb0ZpbmlzaCBjb25maWd1cmF0aW9uIGFkZGVkIGFib3ZlXG4gICAgY29uc3QgZGVwbG95bWVudFdhaXRlciA9IG5ldyAoQVdTIGFzIGFueSkuUmVzb3VyY2VXYWl0ZXIoc2RrLmVjcygpLCAnZGVwbG95bWVudFRvRmluaXNoJyk7XG4gICAgLy8gd2FpdCBmb3IgYWxsIG9mIHRoZSB3YWl0ZXJzIHRvIGZpbmlzaFxuICAgIHJldHVybiBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyhzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXMpLm1hcCgoW2NsdXN0ZXJOYW1lLCBzZXJ2aWNlVXBkYXRlc10pID0+IHtcbiAgICAgIHJldHVybiBkZXBsb3ltZW50V2FpdGVyLndhaXQoe1xuICAgICAgICBjbHVzdGVyOiBjbHVzdGVyTmFtZSxcbiAgICAgICAgc2VydmljZXM6IHNlcnZpY2VVcGRhdGVzLm1hcChzZXJ2aWNlVXBkYXRlID0+IHNlcnZpY2VVcGRhdGUuZWNzU2VydmljZS5zZXJ2aWNlQXJuKSxcbiAgICAgIH0pLnByb21pc2UoKTtcbiAgICB9KSk7XG4gIH1cbn1cbiJdfQ==