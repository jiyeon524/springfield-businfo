"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SSMContextProviderPlugin = void 0;
const cxapi = require("@aws-cdk/cx-api");
const credentials_1 = require("../api/aws-auth/credentials");
const logging_1 = require("../logging");
/**
 * Plugin to read arbitrary SSM parameter names
 */
class SSMContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(args) {
        const region = args.region;
        const account = args.account;
        if (!('parameterName' in args)) {
            throw new Error('parameterName must be provided in props for SSMContextProviderPlugin');
        }
        const parameterName = args.parameterName;
        logging_1.debug(`Reading SSM parameter ${account}:${region}:${parameterName}`);
        const response = await this.getSsmParameterValue(account, region, parameterName, args.lookupRoleArn);
        if (!response.Parameter || response.Parameter.Value === undefined) {
            throw new Error(`SSM parameter not available in account ${account}, region ${region}: ${parameterName}`);
        }
        return response.Parameter.Value;
    }
    /**
     * Gets the value of an SSM Parameter, while not throwin if the parameter does not exist.
     * @param account       the account in which the SSM Parameter is expected to be.
     * @param region        the region in which the SSM Parameter is expected to be.
     * @param parameterName the name of the SSM Parameter
     * @param lookupRoleArn the ARN of the lookup role.
     *
     * @returns the result of the ``GetParameter`` operation.
     *
     * @throws Error if a service error (other than ``ParameterNotFound``) occurs.
     */
    async getSsmParameterValue(account, region, parameterName, lookupRoleArn) {
        const options = { assumeRoleArn: lookupRoleArn };
        const ssm = (await this.aws.forEnvironment(cxapi.EnvironmentUtils.make(account, region), credentials_1.Mode.ForReading, options)).sdk.ssm();
        try {
            return await ssm.getParameter({ Name: parameterName }).promise();
        }
        catch (e) {
            if (e.code === 'ParameterNotFound') {
                return {};
            }
            throw e;
        }
    }
}
exports.SSMContextProviderPlugin = SSMContextProviderPlugin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3NtLXBhcmFtZXRlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzc20tcGFyYW1ldGVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFDQSx5Q0FBeUM7QUFFekMsNkRBQW1EO0FBRW5ELHdDQUFtQztBQUduQzs7R0FFRztBQUNILE1BQWEsd0JBQXdCO0lBQ25DLFlBQTZCLEdBQWdCO1FBQWhCLFFBQUcsR0FBSCxHQUFHLENBQWE7SUFDN0MsQ0FBQztJQUVNLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBdUM7UUFDM0QsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUMzQixNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQzdCLElBQUksQ0FBQyxDQUFDLGVBQWUsSUFBSSxJQUFJLENBQUMsRUFBRTtZQUM5QixNQUFNLElBQUksS0FBSyxDQUFDLHNFQUFzRSxDQUFDLENBQUM7U0FDekY7UUFDRCxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDO1FBQ3pDLGVBQUssQ0FBQyx5QkFBeUIsT0FBTyxJQUFJLE1BQU0sSUFBSSxhQUFhLEVBQUUsQ0FBQyxDQUFDO1FBRXJFLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLG9CQUFvQixDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhLENBQUMsQ0FBQztRQUNyRyxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsSUFBSSxRQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxTQUFTLEVBQUU7WUFDakUsTUFBTSxJQUFJLEtBQUssQ0FBQywwQ0FBMEMsT0FBTyxZQUFZLE1BQU0sS0FBSyxhQUFhLEVBQUUsQ0FBQyxDQUFDO1NBQzFHO1FBQ0QsT0FBTyxRQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNLLEtBQUssQ0FBQyxvQkFBb0IsQ0FBQyxPQUFlLEVBQUUsTUFBYyxFQUFFLGFBQXFCLEVBQUUsYUFBc0I7UUFFL0csTUFBTSxPQUFPLEdBQUcsRUFBRSxhQUFhLEVBQUUsYUFBYSxFQUFFLENBQUM7UUFDakQsTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxHQUFHLENBQUMsY0FBYyxDQUFDLEtBQUssQ0FBQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFLE1BQU0sQ0FBQyxFQUFFLGtCQUFJLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzlILElBQUk7WUFDRixPQUFPLE1BQU0sR0FBRyxDQUFDLFlBQVksQ0FBQyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO1NBQ2xFO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssbUJBQW1CLEVBQUU7Z0JBQ2xDLE9BQU8sRUFBRSxDQUFDO2FBQ1g7WUFDRCxNQUFNLENBQUMsQ0FBQztTQUNUO0lBQ0gsQ0FBQztDQUNGO0FBNUNELDREQTRDQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgQVdTIGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0IHsgTW9kZSB9IGZyb20gJy4uL2FwaS9hd3MtYXV0aC9jcmVkZW50aWFscyc7XG5pbXBvcnQgeyBTZGtQcm92aWRlciB9IGZyb20gJy4uL2FwaS9hd3MtYXV0aC9zZGstcHJvdmlkZXInO1xuaW1wb3J0IHsgZGVidWcgfSBmcm9tICcuLi9sb2dnaW5nJztcbmltcG9ydCB7IENvbnRleHRQcm92aWRlclBsdWdpbiB9IGZyb20gJy4vcHJvdmlkZXInO1xuXG4vKipcbiAqIFBsdWdpbiB0byByZWFkIGFyYml0cmFyeSBTU00gcGFyYW1ldGVyIG5hbWVzXG4gKi9cbmV4cG9ydCBjbGFzcyBTU01Db250ZXh0UHJvdmlkZXJQbHVnaW4gaW1wbGVtZW50cyBDb250ZXh0UHJvdmlkZXJQbHVnaW4ge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGF3czogU2RrUHJvdmlkZXIpIHtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRWYWx1ZShhcmdzOiBjeHNjaGVtYS5TU01QYXJhbWV0ZXJDb250ZXh0UXVlcnkpIHtcbiAgICBjb25zdCByZWdpb24gPSBhcmdzLnJlZ2lvbjtcbiAgICBjb25zdCBhY2NvdW50ID0gYXJncy5hY2NvdW50O1xuICAgIGlmICghKCdwYXJhbWV0ZXJOYW1lJyBpbiBhcmdzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJhbWV0ZXJOYW1lIG11c3QgYmUgcHJvdmlkZWQgaW4gcHJvcHMgZm9yIFNTTUNvbnRleHRQcm92aWRlclBsdWdpbicpO1xuICAgIH1cbiAgICBjb25zdCBwYXJhbWV0ZXJOYW1lID0gYXJncy5wYXJhbWV0ZXJOYW1lO1xuICAgIGRlYnVnKGBSZWFkaW5nIFNTTSBwYXJhbWV0ZXIgJHthY2NvdW50fToke3JlZ2lvbn06JHtwYXJhbWV0ZXJOYW1lfWApO1xuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFNzbVBhcmFtZXRlclZhbHVlKGFjY291bnQsIHJlZ2lvbiwgcGFyYW1ldGVyTmFtZSwgYXJncy5sb29rdXBSb2xlQXJuKTtcbiAgICBpZiAoIXJlc3BvbnNlLlBhcmFtZXRlciB8fCByZXNwb25zZS5QYXJhbWV0ZXIuVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBTU00gcGFyYW1ldGVyIG5vdCBhdmFpbGFibGUgaW4gYWNjb3VudCAke2FjY291bnR9LCByZWdpb24gJHtyZWdpb259OiAke3BhcmFtZXRlck5hbWV9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5QYXJhbWV0ZXIuVmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgdmFsdWUgb2YgYW4gU1NNIFBhcmFtZXRlciwgd2hpbGUgbm90IHRocm93aW4gaWYgdGhlIHBhcmFtZXRlciBkb2VzIG5vdCBleGlzdC5cbiAgICogQHBhcmFtIGFjY291bnQgICAgICAgdGhlIGFjY291bnQgaW4gd2hpY2ggdGhlIFNTTSBQYXJhbWV0ZXIgaXMgZXhwZWN0ZWQgdG8gYmUuXG4gICAqIEBwYXJhbSByZWdpb24gICAgICAgIHRoZSByZWdpb24gaW4gd2hpY2ggdGhlIFNTTSBQYXJhbWV0ZXIgaXMgZXhwZWN0ZWQgdG8gYmUuXG4gICAqIEBwYXJhbSBwYXJhbWV0ZXJOYW1lIHRoZSBuYW1lIG9mIHRoZSBTU00gUGFyYW1ldGVyXG4gICAqIEBwYXJhbSBsb29rdXBSb2xlQXJuIHRoZSBBUk4gb2YgdGhlIGxvb2t1cCByb2xlLlxuICAgKlxuICAgKiBAcmV0dXJucyB0aGUgcmVzdWx0IG9mIHRoZSBgYEdldFBhcmFtZXRlcmBgIG9wZXJhdGlvbi5cbiAgICpcbiAgICogQHRocm93cyBFcnJvciBpZiBhIHNlcnZpY2UgZXJyb3IgKG90aGVyIHRoYW4gYGBQYXJhbWV0ZXJOb3RGb3VuZGBgKSBvY2N1cnMuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIGdldFNzbVBhcmFtZXRlclZhbHVlKGFjY291bnQ6IHN0cmluZywgcmVnaW9uOiBzdHJpbmcsIHBhcmFtZXRlck5hbWU6IHN0cmluZywgbG9va3VwUm9sZUFybj86IHN0cmluZylcbiAgICA6IFByb21pc2U8QVdTLlNTTS5HZXRQYXJhbWV0ZXJSZXN1bHQ+IHtcbiAgICBjb25zdCBvcHRpb25zID0geyBhc3N1bWVSb2xlQXJuOiBsb29rdXBSb2xlQXJuIH07XG4gICAgY29uc3Qgc3NtID0gKGF3YWl0IHRoaXMuYXdzLmZvckVudmlyb25tZW50KGN4YXBpLkVudmlyb25tZW50VXRpbHMubWFrZShhY2NvdW50LCByZWdpb24pLCBNb2RlLkZvclJlYWRpbmcsIG9wdGlvbnMpKS5zZGsuc3NtKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBzc20uZ2V0UGFyYW1ldGVyKHsgTmFtZTogcGFyYW1ldGVyTmFtZSB9KS5wcm9taXNlKCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUuY29kZSA9PT0gJ1BhcmFtZXRlck5vdEZvdW5kJykge1xuICAgICAgICByZXR1cm4ge307XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfVxufVxuIl19