"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bootstrapper = void 0;
const console_1 = require("console");
const path = require("path");
const logging_1 = require("../../logging");
const serialize_1 = require("../../serialize");
const directories_1 = require("../../util/directories");
const deploy_bootstrap_1 = require("./deploy-bootstrap");
const legacy_template_1 = require("./legacy-template");
class Bootstrapper {
    constructor(source) {
        this.source = source;
    }
    bootstrapEnvironment(environment, sdkProvider, options = {}) {
        switch (this.source.source) {
            case 'legacy':
                return this.legacyBootstrap(environment, sdkProvider, options);
            case 'default':
                return this.modernBootstrap(environment, sdkProvider, options);
            case 'custom':
                return this.customBootstrap(environment, sdkProvider, options);
        }
    }
    async showTemplate() {
        const template = await this.loadTemplate();
        process.stdout.write(`${serialize_1.toYAML(template)}\n`);
    }
    /**
     * Deploy legacy bootstrap stack
     *
     */
    async legacyBootstrap(environment, sdkProvider, options = {}) {
        var _a, _b, _c, _d;
        const params = (_a = options.parameters) !== null && _a !== void 0 ? _a : {};
        if ((_b = params.trustedAccounts) === null || _b === void 0 ? void 0 : _b.length) {
            throw new Error('--trust can only be passed for the modern bootstrap experience.');
        }
        if ((_c = params.cloudFormationExecutionPolicies) === null || _c === void 0 ? void 0 : _c.length) {
            throw new Error('--cloudformation-execution-policies can only be passed for the modern bootstrap experience.');
        }
        if (params.createCustomerMasterKey !== undefined) {
            throw new Error('--bootstrap-customer-key can only be passed for the modern bootstrap experience.');
        }
        if (params.qualifier) {
            throw new Error('--qualifier can only be passed for the modern bootstrap experience.');
        }
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, options.toolkitStackName);
        return current.update(await this.loadTemplate(params), {}, {
            ...options,
            terminationProtection: (_d = options.terminationProtection) !== null && _d !== void 0 ? _d : current.terminationProtection,
        });
    }
    /**
     * Deploy CI/CD-ready bootstrap stack from template
     *
     */
    async modernBootstrap(environment, sdkProvider, options = {}) {
        var _a, _b, _c, _d, _e, _f;
        const params = (_a = options.parameters) !== null && _a !== void 0 ? _a : {};
        const bootstrapTemplate = await this.loadTemplate();
        const current = await deploy_bootstrap_1.BootstrapStack.lookup(sdkProvider, environment, options.toolkitStackName);
        if (params.createCustomerMasterKey !== undefined && params.kmsKeyId) {
            throw new Error('You cannot pass \'--bootstrap-kms-key-id\' and \'--bootstrap-customer-key\' together. Specify one or the other');
        }
        // If people re-bootstrap, existing parameter values are reused so that people don't accidentally change the configuration
        // on their bootstrap stack (this happens automatically in deployStack). However, to do proper validation on the
        // combined arguments (such that if --trust has been given, --cloudformation-execution-policies is necessary as well)
        // we need to take this parameter reuse into account.
        //
        // Ideally we'd do this inside the template, but the `Rules` section of CFN
        // templates doesn't seem to be able to express the conditions that we need
        // (can't use Fn::Join or reference Conditions) so we do it here instead.
        const trustedAccounts = (_b = params.trustedAccounts) !== null && _b !== void 0 ? _b : splitCfnArray(current.parameters.TrustedAccounts);
        console_1.info(`Trusted accounts for deployment: ${trustedAccounts.length > 0 ? trustedAccounts.join(', ') : '(none)'}`);
        const trustedAccountsForLookup = (_c = params.trustedAccountsForLookup) !== null && _c !== void 0 ? _c : splitCfnArray(current.parameters.TrustedAccountsForLookup);
        console_1.info(`Trusted accounts for lookup: ${trustedAccountsForLookup.length > 0 ? trustedAccountsForLookup.join(', ') : '(none)'}`);
        const cloudFormationExecutionPolicies = (_d = params.cloudFormationExecutionPolicies) !== null && _d !== void 0 ? _d : splitCfnArray(current.parameters.CloudFormationExecutionPolicies);
        if (trustedAccounts.length === 0 && cloudFormationExecutionPolicies.length === 0) {
            // For self-trust it's okay to default to AdministratorAccess, and it improves the usability of bootstrapping a lot.
            //
            // We don't actually make the implicity policy a physical parameter. The template will infer it instead,
            // we simply do the UI advertising that behavior here.
            //
            // If we DID make it an explicit parameter, we wouldn't be able to tell the difference between whether
            // we inferred it or whether the user told us, and the sequence:
            //
            // $ cdk bootstrap
            // $ cdk bootstrap --trust 1234
            //
            // Would leave AdministratorAccess policies with a trust relationship, without the user explicitly
            // approving the trust policy.
            const implicitPolicy = `arn:${await current.partition()}:iam::aws:policy/AdministratorAccess`;
            logging_1.warning(`Using default execution policy of '${implicitPolicy}'. Pass '--cloudformation-execution-policies' to customize.`);
        }
        else if (cloudFormationExecutionPolicies.length === 0) {
            throw new Error('Please pass \'--cloudformation-execution-policies\' when using \'--trust\' to specify deployment permissions. Try a managed policy of the form \'arn:aws:iam::aws:policy/<PolicyName>\'.');
        }
        else {
            // Remind people what the current settings are
            console_1.info(`Execution policies: ${cloudFormationExecutionPolicies.join(', ')}`);
        }
        // * If an ARN is given, that ARN. Otherwise:
        //   * '-' if customerKey = false
        //   * '' if customerKey = true
        //   * if customerKey is also not given
        //     * undefined if we already had a value in place (reusing what we had)
        //     * '-' if this is the first time we're deploying this stack (or upgrading from old to new bootstrap)
        const currentKmsKeyId = current.parameters.FileAssetsBucketKmsKeyId;
        const kmsKeyId = (_e = params.kmsKeyId) !== null && _e !== void 0 ? _e : (params.createCustomerMasterKey === true ? CREATE_NEW_KEY :
            params.createCustomerMasterKey === false || currentKmsKeyId === undefined ? USE_AWS_MANAGED_KEY :
                undefined);
        return current.update(bootstrapTemplate, {
            FileAssetsBucketName: params.bucketName,
            FileAssetsBucketKmsKeyId: kmsKeyId,
            // Empty array becomes empty string
            TrustedAccounts: trustedAccounts.join(','),
            TrustedAccountsForLookup: trustedAccountsForLookup.join(','),
            CloudFormationExecutionPolicies: cloudFormationExecutionPolicies.join(','),
            Qualifier: params.qualifier,
            PublicAccessBlockConfiguration: params.publicAccessBlockConfiguration || params.publicAccessBlockConfiguration === undefined ? 'true' : 'false',
        }, {
            ...options,
            terminationProtection: (_f = options.terminationProtection) !== null && _f !== void 0 ? _f : current.terminationProtection,
        });
    }
    async customBootstrap(environment, sdkProvider, options = {}) {
        // Look at the template, decide whether it's most likely a legacy or modern bootstrap
        // template, and use the right bootstrapper for that.
        const version = deploy_bootstrap_1.bootstrapVersionFromTemplate(await this.loadTemplate());
        if (version === 0) {
            return this.legacyBootstrap(environment, sdkProvider, options);
        }
        else {
            return this.modernBootstrap(environment, sdkProvider, options);
        }
    }
    async loadTemplate(params = {}) {
        switch (this.source.source) {
            case 'custom':
                return serialize_1.loadStructuredFile(this.source.templateFile);
            case 'default':
                return serialize_1.loadStructuredFile(path.join(directories_1.rootDir(), 'lib', 'api', 'bootstrap', 'bootstrap-template.yaml'));
            case 'legacy':
                return legacy_template_1.legacyBootstrapTemplate(params);
        }
    }
}
exports.Bootstrapper = Bootstrapper;
/**
 * Magic parameter value that will cause the bootstrap-template.yml to NOT create a CMK but use the default keyo
 */
const USE_AWS_MANAGED_KEY = 'AWS_MANAGED_KEY';
/**
 * Magic parameter value that will cause the bootstrap-template.yml to create a CMK
 */
const CREATE_NEW_KEY = '';
/**
 * Split an array-like CloudFormation parameter on ,
 *
 * An empty string is the empty array (instead of `['']`).
 */
function splitCfnArray(xs) {
    if (xs === '' || xs === undefined) {
        return [];
    }
    return xs.split(',');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYm9vdHN0cmFwLWVudmlyb25tZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYm9vdHN0cmFwLWVudmlyb25tZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLHFDQUErQjtBQUMvQiw2QkFBNkI7QUFFN0IsMkNBQXdDO0FBQ3hDLCtDQUE2RDtBQUM3RCx3REFBaUQ7QUFJakQseURBQWtGO0FBQ2xGLHVEQUE0RDtBQVU1RCxNQUFhLFlBQVk7SUFDdkIsWUFBNkIsTUFBdUI7UUFBdkIsV0FBTSxHQUFOLE1BQU0sQ0FBaUI7SUFDcEQsQ0FBQztJQUVNLG9CQUFvQixDQUFDLFdBQThCLEVBQUUsV0FBd0IsRUFBRSxVQUF1QyxFQUFFO1FBQzdILFFBQVEsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDMUIsS0FBSyxRQUFRO2dCQUNYLE9BQU8sSUFBSSxDQUFDLGVBQWUsQ0FBQyxXQUFXLEVBQUUsV0FBVyxFQUFFLE9BQU8sQ0FBQyxDQUFDO1lBQ2pFLEtBQUssU0FBUztnQkFDWixPQUFPLElBQUksQ0FBQyxlQUFlLENBQUMsV0FBVyxFQUFFLFdBQVcsRUFBRSxPQUFPLENBQUMsQ0FBQztZQUNqRSxLQUFLLFFBQVE7Z0JBQ1gsT0FBTyxJQUFJLENBQUMsZUFBZSxDQUFDLFdBQVcsRUFBRSxXQUFXLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDbEU7SUFDSCxDQUFDO0lBRU0sS0FBSyxDQUFDLFlBQVk7UUFDdkIsTUFBTSxRQUFRLEdBQUcsTUFBTSxJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDM0MsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxrQkFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUNoRCxDQUFDO0lBRUQ7OztPQUdHO0lBQ0ssS0FBSyxDQUFDLGVBQWUsQ0FBQyxXQUE4QixFQUFFLFdBQXdCLEVBQUUsVUFBdUMsRUFBRTs7UUFDL0gsTUFBTSxNQUFNLFNBQUcsT0FBTyxD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cUJBQU8sRUFBRSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLHlCQUF5QixDQUFDLENBQUMsQ0FBQztZQUN4RyxLQUFLLFFBQVE7Z0JBQ1gsT0FBTyx5Q0FBdUIsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMxQztJQUNILENBQUM7Q0FDRjtBQTlKRCxvQ0E4SkM7QUFFRDs7R0FFRztBQUNILE1BQU0sbUJBQW1CLEdBQUcsaUJBQWlCLENBQUM7QUFFOUM7O0dBRUc7QUFDSCxNQUFNLGNBQWMsR0FBRyxFQUFFLENBQUM7QUFFMUI7Ozs7R0FJRztBQUNILFNBQVMsYUFBYSxDQUFDLEVBQXNCO0lBQzNDLElBQUksRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLEtBQUssU0FBUyxFQUFFO1FBQUUsT0FBTyxFQUFFLENBQUM7S0FBRTtJQUNqRCxPQUFPLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDdkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGluZm8gfSBmcm9tICdjb25zb2xlJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgd2FybmluZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgbG9hZFN0cnVjdHVyZWRGaWxlLCB0b1lBTUwgfSBmcm9tICcuLi8uLi9zZXJpYWxpemUnO1xuaW1wb3J0IHsgcm9vdERpciB9IGZyb20gJy4uLy4uL3V0aWwvZGlyZWN0b3JpZXMnO1xuaW1wb3J0IHsgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBEZXBsb3lTdGFja1Jlc3VsdCB9IGZyb20gJy4uL2RlcGxveS1zdGFjayc7XG5pbXBvcnQgeyBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMsIEJvb3RzdHJhcHBpbmdQYXJhbWV0ZXJzIH0gZnJvbSAnLi9ib290c3RyYXAtcHJvcHMnO1xuaW1wb3J0IHsgQm9vdHN0cmFwU3RhY2ssIGJvb3RzdHJhcFZlcnNpb25Gcm9tVGVtcGxhdGUgfSBmcm9tICcuL2RlcGxveS1ib290c3RyYXAnO1xuaW1wb3J0IHsgbGVnYWN5Qm9vdHN0cmFwVGVtcGxhdGUgfSBmcm9tICcuL2xlZ2FjeS10ZW1wbGF0ZSc7XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cblxuZXhwb3J0IHR5cGUgQm9vdHN0cmFwU291cmNlID1cbiAgeyBzb3VyY2U6ICdsZWdhY3knIH1cbiAgfCB7IHNvdXJjZTogJ2RlZmF1bHQnIH1cbiAgfCB7IHNvdXJjZTogJ2N1c3RvbSc7IHRlbXBsYXRlRmlsZTogc3RyaW5nIH07XG5cblxuZXhwb3J0IGNsYXNzIEJvb3RzdHJhcHBlciB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgc291cmNlOiBCb290c3RyYXBTb3VyY2UpIHtcbiAgfVxuXG4gIHB1YmxpYyBib290c3RyYXBFbnZpcm9ubWVudChlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlciwgb3B0aW9uczogQm9vdHN0cmFwRW52aXJvbm1lbnRPcHRpb25zID0ge30pOiBQcm9taXNlPERlcGxveVN0YWNrUmVzdWx0PiB7XG4gICAgc3dpdGNoICh0aGlzLnNvdXJjZS5zb3VyY2UpIHtcbiAgICAgIGNhc2UgJ2xlZ2FjeSc6XG4gICAgICAgIHJldHVybiB0aGlzLmxlZ2FjeUJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgICAgY2FzZSAnZGVmYXVsdCc6XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVybkJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgICAgY2FzZSAnY3VzdG9tJzpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VzdG9tQm9vdHN0cmFwKGVudmlyb25tZW50LCBzZGtQcm92aWRlciwgb3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHNob3dUZW1wbGF0ZSgpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IGF3YWl0IHRoaXMubG9hZFRlbXBsYXRlKCk7XG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoYCR7dG9ZQU1MKHRlbXBsYXRlKX1cXG5gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXBsb3kgbGVnYWN5IGJvb3RzdHJhcCBzdGFja1xuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBsZWdhY3lCb290c3RyYXAoZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LCBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXIsIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMucGFyYW1ldGVycyA/PyB7fTtcblxuICAgIGlmIChwYXJhbXMudHJ1c3RlZEFjY291bnRzPy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignLS10cnVzdCBjYW4gb25seSBiZSBwYXNzZWQgZm9yIHRoZSBtb2Rlcm4gYm9vdHN0cmFwIGV4cGVyaWVuY2UuJyk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMuY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcz8ubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJy0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzIGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG4gICAgaWYgKHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJy0tYm9vdHN0cmFwLWN1c3RvbWVyLWtleSBjYW4gb25seSBiZSBwYXNzZWQgZm9yIHRoZSBtb2Rlcm4gYm9vdHN0cmFwIGV4cGVyaWVuY2UuJyk7XG4gICAgfVxuICAgIGlmIChwYXJhbXMucXVhbGlmaWVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJy0tcXVhbGlmaWVyIGNhbiBvbmx5IGJlIHBhc3NlZCBmb3IgdGhlIG1vZGVybiBib290c3RyYXAgZXhwZXJpZW5jZS4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBjdXJyZW50ID0gYXdhaXQgQm9vdHN0cmFwU3RhY2subG9va3VwKHNka1Byb3ZpZGVyLCBlbnZpcm9ubWVudCwgb3B0aW9ucy50b29sa2l0U3RhY2tOYW1lKTtcbiAgICByZXR1cm4gY3VycmVudC51cGRhdGUoYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUocGFyYW1zKSwge30sIHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0ZXJtaW5hdGlvblByb3RlY3Rpb246IG9wdGlvbnMudGVybWluYXRpb25Qcm90ZWN0aW9uID8/IGN1cnJlbnQudGVybWluYXRpb25Qcm90ZWN0aW9uLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcGxveSBDSS9DRC1yZWFkeSBib290c3RyYXAgc3RhY2sgZnJvbSB0ZW1wbGF0ZVxuICAgKlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBtb2Rlcm5Cb290c3RyYXAoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcixcbiAgICBvcHRpb25zOiBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgPSB7fSk6IFByb21pc2U8RGVwbG95U3RhY2tSZXN1bHQ+IHtcblxuICAgIGNvbnN0IHBhcmFtcyA9IG9wdGlvbnMucGFyYW1ldGVycyA/PyB7fTtcblxuICAgIGNvbnN0IGJvb3RzdHJhcFRlbXBsYXRlID0gYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUoKTtcblxuICAgIGNvbnN0IGN1cnJlbnQgPSBhd2FpdCBCb290c3RyYXBTdGFjay5sb29rdXAoc2RrUHJvdmlkZXIsIGVudmlyb25tZW50LCBvcHRpb25zLnRvb2xraXRTdGFja05hbWUpO1xuXG4gICAgaWYgKHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSAhPT0gdW5kZWZpbmVkICYmIHBhcmFtcy5rbXNLZXlJZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgY2Fubm90IHBhc3MgXFwnLS1ib290c3RyYXAta21zLWtleS1pZFxcJyBhbmQgXFwnLS1ib290c3RyYXAtY3VzdG9tZXIta2V5XFwnIHRvZ2V0aGVyLiBTcGVjaWZ5IG9uZSBvciB0aGUgb3RoZXInKTtcbiAgICB9XG5cbiAgICAvLyBJZiBwZW9wbGUgcmUtYm9vdHN0cmFwLCBleGlzdGluZyBwYXJhbWV0ZXIgdmFsdWVzIGFyZSByZXVzZWQgc28gdGhhdCBwZW9wbGUgZG9uJ3QgYWNjaWRlbnRhbGx5IGNoYW5nZSB0aGUgY29uZmlndXJhdGlvblxuICAgIC8vIG9uIHRoZWlyIGJvb3RzdHJhcCBzdGFjayAodGhpcyBoYXBwZW5zIGF1dG9tYXRpY2FsbHkgaW4gZGVwbG95U3RhY2spLiBIb3dldmVyLCB0byBkbyBwcm9wZXIgdmFsaWRhdGlvbiBvbiB0aGVcbiAgICAvLyBjb21iaW5lZCBhcmd1bWVudHMgKHN1Y2ggdGhhdCBpZiAtLXRydXN0IGhhcyBiZWVuIGdpdmVuLCAtLWNsb3VkZm9ybWF0aW9uLWV4ZWN1dGlvbi1wb2xpY2llcyBpcyBuZWNlc3NhcnkgYXMgd2VsbClcbiAgICAvLyB3ZSBuZWVkIHRvIHRha2UgdGhpcyBwYXJhbWV0ZXIgcmV1c2UgaW50byBhY2NvdW50LlxuICAgIC8vXG4gICAgLy8gSWRlYWxseSB3ZSdkIGRvIHRoaXMgaW5zaWRlIHRoZSB0ZW1wbGF0ZSwgYnV0IHRoZSBgUnVsZXNgIHNlY3Rpb24gb2YgQ0ZOXG4gICAgLy8gdGVtcGxhdGVzIGRvZXNuJ3Qgc2VlbSB0byBiZSBhYmxlIHRvIGV4cHJlc3MgdGhlIGNvbmRpdGlvbnMgdGhhdCB3ZSBuZWVkXG4gICAgLy8gKGNhbid0IHVzZSBGbjo6Sm9pbiBvciByZWZlcmVuY2UgQ29uZGl0aW9ucykgc28gd2UgZG8gaXQgaGVyZSBpbnN0ZWFkLlxuICAgIGNvbnN0IHRydXN0ZWRBY2NvdW50cyA9IHBhcmFtcy50cnVzdGVkQWNjb3VudHMgPz8gc3BsaXRDZm5BcnJheShjdXJyZW50LnBhcmFtZXRlcnMuVHJ1c3RlZEFjY291bnRzKTtcbiAgICBpbmZvKGBUcnVzdGVkIGFjY291bnRzIGZvciBkZXBsb3ltZW50OiAke3RydXN0ZWRBY2NvdW50cy5sZW5ndGggPiAwID8gdHJ1c3RlZEFjY291bnRzLmpvaW4oJywgJykgOiAnKG5vbmUpJ31gKTtcblxuICAgIGNvbnN0IHRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cCA9IHBhcmFtcy50cnVzdGVkQWNjb3VudHNGb3JMb29rdXAgPz8gc3BsaXRDZm5BcnJheShjdXJyZW50LnBhcmFtZXRlcnMuVHJ1c3RlZEFjY291bnRzRm9yTG9va3VwKTtcbiAgICBpbmZvKGBUcnVzdGVkIGFjY291bnRzIGZvciBsb29rdXA6ICR7dHJ1c3RlZEFjY291bnRzRm9yTG9va3VwLmxlbmd0aCA+IDAgPyB0cnVzdGVkQWNjb3VudHNGb3JMb29rdXAuam9pbignLCAnKSA6ICcobm9uZSknfWApO1xuXG4gICAgY29uc3QgY2xvdWRGb3JtYXRpb25FeGVjdXRpb25Qb2xpY2llcyA9IHBhcmFtcy5jbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblBvbGljaWVzID8/IHNwbGl0Q2ZuQXJyYXkoY3VycmVudC5wYXJhbWV0ZXJzLkNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMpO1xuICAgIGlmICh0cnVzdGVkQWNjb3VudHMubGVuZ3RoID09PSAwICYmIGNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAvLyBGb3Igc2VsZi10cnVzdCBpdCdzIG9rYXkgdG8gZGVmYXVsdCB0byBBZG1pbmlzdHJhdG9yQWNjZXNzLCBhbmQgaXQgaW1wcm92ZXMgdGhlIHVzYWJpbGl0eSBvZiBib290c3RyYXBwaW5nIGEgbG90LlxuICAgICAgLy9cbiAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IG1ha2UgdGhlIGltcGxpY2l0eSBwb2xpY3kgYSBwaHlzaWNhbCBwYXJhbWV0ZXIuIFRoZSB0ZW1wbGF0ZSB3aWxsIGluZmVyIGl0IGluc3RlYWQsXG4gICAgICAvLyB3ZSBzaW1wbHkgZG8gdGhlIFVJIGFkdmVydGlzaW5nIHRoYXQgYmVoYXZpb3IgaGVyZS5cbiAgICAgIC8vXG4gICAgICAvLyBJZiB3ZSBESUQgbWFrZSBpdCBhbiBleHBsaWNpdCBwYXJhbWV0ZXIsIHdlIHdvdWxkbid0IGJlIGFibGUgdG8gdGVsbCB0aGUgZGlmZmVyZW5jZSBiZXR3ZWVuIHdoZXRoZXJcbiAgICAgIC8vIHdlIGluZmVycmVkIGl0IG9yIHdoZXRoZXIgdGhlIHVzZXIgdG9sZCB1cywgYW5kIHRoZSBzZXF1ZW5jZTpcbiAgICAgIC8vXG4gICAgICAvLyAkIGNkayBib290c3RyYXBcbiAgICAgIC8vICQgY2RrIGJvb3RzdHJhcCAtLXRydXN0IDEyMzRcbiAgICAgIC8vXG4gICAgICAvLyBXb3VsZCBsZWF2ZSBBZG1pbmlzdHJhdG9yQWNjZXNzIHBvbGljaWVzIHdpdGggYSB0cnVzdCByZWxhdGlvbnNoaXAsIHdpdGhvdXQgdGhlIHVzZXIgZXhwbGljaXRseVxuICAgICAgLy8gYXBwcm92aW5nIHRoZSB0cnVzdCBwb2xpY3kuXG4gICAgICBjb25zdCBpbXBsaWNpdFBvbGljeSA9IGBhcm46JHthd2FpdCBjdXJyZW50LnBhcnRpdGlvbigpfTppYW06OmF3czpwb2xpY3kvQWRtaW5pc3RyYXRvckFjY2Vzc2A7XG4gICAgICB3YXJuaW5nKGBVc2luZyBkZWZhdWx0IGV4ZWN1dGlvbiBwb2xpY3kgb2YgJyR7aW1wbGljaXRQb2xpY3l9Jy4gUGFzcyAnLS1jbG91ZGZvcm1hdGlvbi1leGVjdXRpb24tcG9saWNpZXMnIHRvIGN1c3RvbWl6ZS5gKTtcbiAgICB9IGVsc2UgaWYgKGNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBwYXNzIFxcJy0tY2xvdWRmb3JtYXRpb24tZXhlY3V0aW9uLXBvbGljaWVzXFwnIHdoZW4gdXNpbmcgXFwnLS10cnVzdFxcJyB0byBzcGVjaWZ5IGRlcGxveW1lbnQgcGVybWlzc2lvbnMuIFRyeSBhIG1hbmFnZWQgcG9saWN5IG9mIHRoZSBmb3JtIFxcJ2Fybjphd3M6aWFtOjphd3M6cG9saWN5LzxQb2xpY3lOYW1lPlxcJy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtaW5kIHBlb3BsZSB3aGF0IHRoZSBjdXJyZW50IHNldHRpbmdzIGFyZVxuICAgICAgaW5mbyhgRXhlY3V0aW9uIHBvbGljaWVzOiAke2Nsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMuam9pbignLCAnKX1gKTtcbiAgICB9XG5cbiAgICAvLyAqIElmIGFuIEFSTiBpcyBnaXZlbiwgdGhhdCBBUk4uIE90aGVyd2lzZTpcbiAgICAvLyAgICogJy0nIGlmIGN1c3RvbWVyS2V5ID0gZmFsc2VcbiAgICAvLyAgICogJycgaWYgY3VzdG9tZXJLZXkgPSB0cnVlXG4gICAgLy8gICAqIGlmIGN1c3RvbWVyS2V5IGlzIGFsc28gbm90IGdpdmVuXG4gICAgLy8gICAgICogdW5kZWZpbmVkIGlmIHdlIGFscmVhZHkgaGFkIGEgdmFsdWUgaW4gcGxhY2UgKHJldXNpbmcgd2hhdCB3ZSBoYWQpXG4gICAgLy8gICAgICogJy0nIGlmIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgd2UncmUgZGVwbG95aW5nIHRoaXMgc3RhY2sgKG9yIHVwZ3JhZGluZyBmcm9tIG9sZCB0byBuZXcgYm9vdHN0cmFwKVxuICAgIGNvbnN0IGN1cnJlbnRLbXNLZXlJZCA9IGN1cnJlbnQucGFyYW1ldGVycy5GaWxlQXNzZXRzQnVja2V0S21zS2V5SWQ7XG4gICAgY29uc3Qga21zS2V5SWQgPSBwYXJhbXMua21zS2V5SWQgPz9cbiAgICAgIChwYXJhbXMuY3JlYXRlQ3VzdG9tZXJNYXN0ZXJLZXkgPT09IHRydWUgPyBDUkVBVEVfTkVXX0tFWSA6XG4gICAgICAgIHBhcmFtcy5jcmVhdGVDdXN0b21lck1hc3RlcktleSA9PT0gZmFsc2UgfHwgY3VycmVudEttc0tleUlkID09PSB1bmRlZmluZWQgPyBVU0VfQVdTX01BTkFHRURfS0VZIDpcbiAgICAgICAgICB1bmRlZmluZWQpO1xuXG4gICAgcmV0dXJuIGN1cnJlbnQudXBkYXRlKFxuICAgICAgYm9vdHN0cmFwVGVtcGxhdGUsXG4gICAgICB7XG4gICAgICAgIEZpbGVBc3NldHNCdWNrZXROYW1lOiBwYXJhbXMuYnVja2V0TmFtZSxcbiAgICAgICAgRmlsZUFzc2V0c0J1Y2tldEttc0tleUlkOiBrbXNLZXlJZCxcbiAgICAgICAgLy8gRW1wdHkgYXJyYXkgYmVjb21lcyBlbXB0eSBzdHJpbmdcbiAgICAgICAgVHJ1c3RlZEFjY291bnRzOiB0cnVzdGVkQWNjb3VudHMuam9pbignLCcpLFxuICAgICAgICBUcnVzdGVkQWNjb3VudHNGb3JMb29rdXA6IHRydXN0ZWRBY2NvdW50c0Zvckxvb2t1cC5qb2luKCcsJyksXG4gICAgICAgIENsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXM6IGNsb3VkRm9ybWF0aW9uRXhlY3V0aW9uUG9saWNpZXMuam9pbignLCcpLFxuICAgICAgICBRdWFsaWZpZXI6IHBhcmFtcy5xdWFsaWZpZXIsXG4gICAgICAgIFB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvbjogcGFyYW1zLnB1YmxpY0FjY2Vzc0Jsb2NrQ29uZmlndXJhdGlvbiB8fCBwYXJhbXMucHVibGljQWNjZXNzQmxvY2tDb25maWd1cmF0aW9uID09PSB1bmRlZmluZWQgPyAndHJ1ZScgOiAnZmFsc2UnLFxuICAgICAgfSwge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB0ZXJtaW5hdGlvblByb3RlY3Rpb246IG9wdGlvbnMudGVybWluYXRpb25Qcm90ZWN0aW9uID8/IGN1cnJlbnQudGVybWluYXRpb25Qcm90ZWN0aW9uLFxuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGN1c3RvbUJvb3RzdHJhcChcbiAgICBlbnZpcm9ubWVudDogY3hhcGkuRW52aXJvbm1lbnQsXG4gICAgc2RrUHJvdmlkZXI6IFNka1Byb3ZpZGVyLFxuICAgIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyA9IHt9KTogUHJvbWlzZTxEZXBsb3lTdGFja1Jlc3VsdD4ge1xuXG4gICAgLy8gTG9vayBhdCB0aGUgdGVtcGxhdGUsIGRlY2lkZSB3aGV0aGVyIGl0J3MgbW9zdCBsaWtlbHkgYSBsZWdhY3kgb3IgbW9kZXJuIGJvb3RzdHJhcFxuICAgIC8vIHRlbXBsYXRlLCBhbmQgdXNlIHRoZSByaWdodCBib290c3RyYXBwZXIgZm9yIHRoYXQuXG4gICAgY29uc3QgdmVyc2lvbiA9IGJvb3RzdHJhcFZlcnNpb25Gcm9tVGVtcGxhdGUoYXdhaXQgdGhpcy5sb2FkVGVtcGxhdGUoKSk7XG4gICAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmxlZ2FjeUJvb3RzdHJhcChlbnZpcm9ubWVudCwgc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5tb2Rlcm5Cb290c3RyYXAoZW52aXJvbm1lbnQsIHNka1Byb3ZpZGVyLCBvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIGxvYWRUZW1wbGF0ZShwYXJhbXM6IEJvb3RzdHJhcHBpbmdQYXJhbWV0ZXJzID0ge30pOiBQcm9taXNlPGFueT4ge1xuICAgIHN3aXRjaCAodGhpcy5zb3VyY2Uuc291cmNlKSB7XG4gICAgICBjYXNlICdjdXN0b20nOlxuICAgICAgICByZXR1cm4gbG9hZFN0cnVjdHVyZWRGaWxlKHRoaXMuc291cmNlLnRlbXBsYXRlRmlsZSk7XG4gICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgcmV0dXJuIGxvYWRTdHJ1Y3R1cmVkRmlsZShwYXRoLmpvaW4ocm9vdERpcigpLCAnbGliJywgJ2FwaScsICdib290c3RyYXAnLCAnYm9vdHN0cmFwLXRlbXBsYXRlLnlhbWwnKSk7XG4gICAgICBjYXNlICdsZWdhY3knOlxuICAgICAgICByZXR1cm4gbGVnYWN5Qm9vdHN0cmFwVGVtcGxhdGUocGFyYW1zKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBNYWdpYyBwYXJhbWV0ZXIgdmFsdWUgdGhhdCB3aWxsIGNhdXNlIHRoZSBib290c3RyYXAtdGVtcGxhdGUueW1sIHRvIE5PVCBjcmVhdGUgYSBDTUsgYnV0IHVzZSB0aGUgZGVmYXVsdCBrZXlvXG4gKi9cbmNvbnN0IFVTRV9BV1NfTUFOQUdFRF9LRVkgPSAnQVdTX01BTkFHRURfS0VZJztcblxuLyoqXG4gKiBNYWdpYyBwYXJhbWV0ZXIgdmFsdWUgdGhhdCB3aWxsIGNhdXNlIHRoZSBib290c3RyYXAtdGVtcGxhdGUueW1sIHRvIGNyZWF0ZSBhIENNS1xuICovXG5jb25zdCBDUkVBVEVfTkVXX0tFWSA9ICcnO1xuXG4vKipcbiAqIFNwbGl0IGFuIGFycmF5LWxpa2UgQ2xvdWRGb3JtYXRpb24gcGFyYW1ldGVyIG9uICxcbiAqXG4gKiBBbiBlbXB0eSBzdHJpbmcgaXMgdGhlIGVtcHR5IGFycmF5IChpbnN0ZWFkIG9mIGBbJyddYCkuXG4gKi9cbmZ1bmN0aW9uIHNwbGl0Q2ZuQXJyYXkoeHM6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZ1tdIHtcbiAgaWYgKHhzID09PSAnJyB8fCB4cyA9PT0gdW5kZWZpbmVkKSB7IHJldHVybiBbXTsgfVxuICByZXR1cm4geHMuc3BsaXQoJywnKTtcbn1cbiJdfQ==