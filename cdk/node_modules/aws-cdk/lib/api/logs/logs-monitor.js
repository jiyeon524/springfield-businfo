"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudWatchLogEventMonitor = void 0;
const util = require("util");
const chalk = require("chalk");
const logging_1 = require("../../logging");
const arrays_1 = require("../../util/arrays");
/**
 * After reading events from all CloudWatch log groups
 * how long should we wait to read more events.
 *
 * If there is some error with reading events (i.e. Throttle)
 * then this is also how long we wait until we try again
 */
const SLEEP = 2000;
class CloudWatchLogEventMonitor {
    constructor(startTime) {
        var _a;
        /**
         * Map of environment (account:region) to LogGroupsAccessSettings
         */
        this.envsLogGroupsAccessSettings = new Map();
        this.active = false;
        this.startTime = (_a = startTime === null || startTime === void 0 ? void 0 : startTime.getTime()) !== null && _a !== void 0 ? _a : Date.now();
    }
    /**
     * resume reading/printing events
     */
    activate() {
        this.active = true;
        this.scheduleNextTick(0);
    }
    /**
     * deactivates the monitor so no new events are read
     * use case for this is when we are in the middle of performing a deployment
     * and don't want to interweave all the logs together with the CFN
     * deployment logs
     *
     * Also resets the start time to be when the new deployment was triggered
     * and clears the list of tracked log groups
     */
    deactivate() {
        this.active = false;
        this.startTime = Date.now();
        this.envsLogGroupsAccessSettings.clear();
    }
    /**
     * Adds CloudWatch log groups to read log events from.
     * Since we could be watching multiple stacks that deploy to
     * multiple environments (account+region), we need to store a list of log groups
     * per env along with the SDK object that has access to read from
     * that environment.
     */
    addLogGroups(env, sdk, logGroupNames) {
        var _a;
        const awsEnv = `${env.account}:${env.region}`;
        const logGroupsStartTimes = logGroupNames.reduce((acc, groupName) => {
            acc[groupName] = this.startTime;
            return acc;
        }, {});
        this.envsLogGroupsAccessSettings.set(awsEnv, {
            sdk,
            logGroupsStartTimes: {
                ...(_a = this.envsLogGroupsAccessSettings.get(awsEnv)) === null || _a === void 0 ? void 0 : _a.logGroupsStartTimes,
                ...logGroupsStartTimes,
            },
        });
    }
    scheduleNextTick(sleep) {
        setTimeout(() => void (this.tick()), sleep);
    }
    async tick() {
        if (!this.active) {
            return;
        }
        try {
            const events = arrays_1.flatten(await this.readNewEvents());
            events.forEach(event => {
                this.print(event);
            });
        }
        catch (e) {
            logging_1.error('Error occurred while monitoring logs: %s', e);
        }
        this.scheduleNextTick(SLEEP);
    }
    /**
     * Reads all new log events from a set of CloudWatch Log Groups
     * in parallel
     */
    async readNewEvents() {
        const promises = [];
        for (const settings of this.envsLogGroupsAccessSettings.values()) {
            for (const group of Object.keys(settings.logGroupsStartTimes)) {
                promises.push(this.readEventsFromLogGroup(settings, group));
            }
        }
        return Promise.all(promises);
    }
    /**
     * Print out a cloudwatch event
     */
    print(event) {
        logging_1.print(util.format('[%s] %s %s', chalk.blue(event.logGroupName), chalk.yellow(event.timestamp.toLocaleTimeString()), event.message.trim()));
    }
    /**
     * Reads all new log events from a CloudWatch Log Group
     * starting at either the time the hotswap was triggered or
     * when the last event was read on the previous tick
     */
    async readEventsFromLogGroup(logGroupsAccessSettings, logGroupName) {
        var _a, _b;
        const events = [];
        // log events from some service are ingested faster than others
        // so we need to track the start/end time for each log group individually
        // to make sure that we process all events from each log group
        const startTime = (_a = logGroupsAccessSettings.logGroupsStartTimes[logGroupName]) !== null && _a !== void 0 ? _a : this.startTime;
        let endTime = startTime;
        try {
            const response = await logGroupsAccessSettings.sdk.cloudWatchLogs().filterLogEvents({
                logGroupName: logGroupName,
                limit: 100,
                startTime: startTime,
            }).promise();
            const filteredEvents = (_b = response.events) !== null && _b !== void 0 ? _b : [];
            for (const event of filteredEvents) {
                if (event.message) {
                    events.push({
                        message: event.message,
                        logGroupName,
                        timestamp: event.timestamp ? new Date(event.timestamp) : new Date(),
                    });
                    if (event.timestamp && endTime < event.timestamp) {
                        endTime = event.timestamp;
                    }
                }
            }
            // As long as there are _any_ events in the log group `filterLogEvents` will return a nextToken.
            // This is true even if these events are before `startTime`. So if we have 100 events and a nextToken
            // then assume that we have hit the limit and let the user know some messages have been supressed.
            // We are essentially showing them a sampling (10000 events printed out is not very useful)
            if (filteredEvents.length === 100 && response.nextToken) {
                events.push({
                    message: '>>> `watch` shows only the first 100 log messages - the rest have been truncated...',
                    logGroupName,
                    timestamp: new Date(endTime),
                });
            }
        }
        catch (e) {
            // with Lambda functions the CloudWatch is not created
            // until something is logged, so just keep polling until
            // there is somthing to find
            if (e.code === 'ResourceNotFoundException') {
                return [];
            }
            throw e;
        }
        logGroupsAccessSettings.logGroupsStartTimes[logGroupName] = endTime + 1;
        return events;
    }
}
exports.CloudWatchLogEventMonitor = CloudWatchLogEventMonitor;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ncy1tb25pdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibG9ncy1tb25pdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDZCQUE2QjtBQUU3QiwrQkFBK0I7QUFDL0IsMkNBQTZDO0FBQzdDLDhDQUE0QztBQUc1Qzs7Ozs7O0dBTUc7QUFDSCxNQUFNLEtBQUssR0FBRyxJQUFLLENBQUM7QUEwQ3BCLE1BQWEseUJBQXlCO0lBYXBDLFlBQVksU0FBZ0I7O1FBUDVCOztXQUVHO1FBQ2MsZ0NBQTJCLEdBQUcsSUFBSSxHQUFHLEVBQW1DLENBQUM7UUFFbEYsV0FBTSxHQUFHLEtBQUssQ0FBQztRQUdyQixJQUFJLENBQUMsU0FBUyxTQUFHLFNBQVMsYUFBVCxTQUFTLHVCQUFULFNBQVMsQ0FBRSxPQUFPLHFDQUFNLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztJQUN0RCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxRQUFRO1FBQ2IsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDbkIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzNCLENBQUM7SUFFRDs7Ozs7Ozs7T0FRRztJQUNJLFVBQVU7UUFDZixJQUFJLENBQUMsTUFBTSxHQUFHLEtBQUssQ0FBQztRQUNwQixJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUM1QixJQUFJLENBQUMsMkJBQTJCLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7Ozs7T0FNRztJQUNJLFlBQVksQ0FBQyxHQUFzQixFQUFFLEdBQVMsRUFBRSxhQUF1Qjs7UUFDNUUsTUFBTSxNQUFNLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUM5QyxNQUFNLG1CQUFtQixHQUFHLGFBQWEsQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLEVB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O1FBQ3hFLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7Q0FDRjtBQXZLRCw4REF1S0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyB1dGlsIGZyb20gJ3V0aWwnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IHByaW50LCBlcnJvciB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgZmxhdHRlbiB9IGZyb20gJy4uLy4uL3V0aWwvYXJyYXlzJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5cbi8qKlxuICogQWZ0ZXIgcmVhZGluZyBldmVudHMgZnJvbSBhbGwgQ2xvdWRXYXRjaCBsb2cgZ3JvdXBzXG4gKiBob3cgbG9uZyBzaG91bGQgd2Ugd2FpdCB0byByZWFkIG1vcmUgZXZlbnRzLlxuICpcbiAqIElmIHRoZXJlIGlzIHNvbWUgZXJyb3Igd2l0aCByZWFkaW5nIGV2ZW50cyAoaS5lLiBUaHJvdHRsZSlcbiAqIHRoZW4gdGhpcyBpcyBhbHNvIGhvdyBsb25nIHdlIHdhaXQgdW50aWwgd2UgdHJ5IGFnYWluXG4gKi9cbmNvbnN0IFNMRUVQID0gMl8wMDA7XG5cbi8qKlxuICogUmVwcmVzZW50cyBhIENsb3VkV2F0Y2ggTG9nIEV2ZW50IHRoYXQgd2lsbCBiZVxuICogcHJpbnRlZCB0byB0aGUgdGVybWluYWxcbiAqL1xuaW50ZXJmYWNlIENsb3VkV2F0Y2hMb2dFdmVudCB7XG4gIC8qKlxuICAgKiBUaGUgbG9nIGV2ZW50IG1lc3NhZ2VcbiAgICovXG4gIHJlYWRvbmx5IG1lc3NhZ2U6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGxvZyBncm91cFxuICAgKi9cbiAgcmVhZG9ubHkgbG9nR3JvdXBOYW1lOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBldmVudCBvY2N1cnJlZFxuICAgKi9cbiAgcmVhZG9ubHkgdGltZXN0YW1wOiBEYXRlO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gdHJhY2tpbmcgaW5mb3JtYXRpb24gb24gdGhlIGxvZyBncm91cHMgdGhhdCBhcmVcbiAqIGJlaW5nIG1vbml0b3JlZFxuICovXG5pbnRlcmZhY2UgTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3Mge1xuICAvKipcbiAgICogVGhlIFNESyBmb3IgYSBnaXZlbiBlbnZpcm9ubWVudCAoYWNjb3VudC9yZWdpb24pXG4gICAqL1xuICByZWFkb25seSBzZGs6IElTREs7XG5cbiAgLyoqXG4gICAqIEEgbWFwIG9mIGxvZyBncm91cHMgYW5kIGFzc29jaWF0ZWQgc3RhcnRUaW1lIGluIGEgZ2l2ZW4gYWNjb3VudC5cbiAgICpcbiAgICogVGhlIG1vbml0b3Igd2lsbCByZWFkIGV2ZW50cyBmcm9tIHRoZSBsb2cgZ3JvdXAgc3RhcnRpbmcgYXQgdGhlXG4gICAqIGFzc29jaWF0ZWQgc3RhcnRUaW1lXG4gICAqL1xuICByZWFkb25seSBsb2dHcm91cHNTdGFydFRpbWVzOiB7IFtsb2dHcm91cE5hbWU6IHN0cmluZ106IG51bWJlciB9O1xufVxuXG5leHBvcnQgY2xhc3MgQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvciB7XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoaWNoIGV2ZW50cyBub3QgdG8gZGlzcGxheVxuICAgKi9cbiAgcHJpdmF0ZSBzdGFydFRpbWU6IG51bWJlcjtcblxuICAvKipcbiAgICogTWFwIG9mIGVudmlyb25tZW50IChhY2NvdW50OnJlZ2lvbikgdG8gTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3NcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZW52c0xvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzID0gbmV3IE1hcDxzdHJpbmcsIExvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzPigpO1xuXG4gIHByaXZhdGUgYWN0aXZlID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3Ioc3RhcnRUaW1lPzogRGF0ZSkge1xuICAgIHRoaXMuc3RhcnRUaW1lID0gc3RhcnRUaW1lPy5nZXRUaW1lKCkgPz8gRGF0ZS5ub3coKTtcbiAgfVxuXG4gIC8qKlxuICAgKiByZXN1bWUgcmVhZGluZy9wcmludGluZyBldmVudHNcbiAgICovXG4gIHB1YmxpYyBhY3RpdmF0ZSgpOiB2b2lkIHtcbiAgICB0aGlzLmFjdGl2ZSA9IHRydWU7XG4gICAgdGhpcy5zY2hlZHVsZU5leHRUaWNrKDApO1xuICB9XG5cbiAgLyoqXG4gICAqIGRlYWN0aXZhdGVzIHRoZSBtb25pdG9yIHNvIG5vIG5ldyBldmVudHMgYXJlIHJlYWRcbiAgICogdXNlIGNhc2UgZm9yIHRoaXMgaXMgd2hlbiB3ZSBhcmUgaW4gdGhlIG1pZGRsZSBvZiBwZXJmb3JtaW5nIGEgZGVwbG95bWVudFxuICAgKiBhbmQgZG9uJ3Qgd2FudCB0byBpbnRlcndlYXZlIGFsbCB0aGUgbG9ncyB0b2dldGhlciB3aXRoIHRoZSBDRk5cbiAgICogZGVwbG95bWVudCBsb2dzXG4gICAqXG4gICAqIEFsc28gcmVzZXRzIHRoZSBzdGFydCB0aW1lIHRvIGJlIHdoZW4gdGhlIG5ldyBkZXBsb3ltZW50IHdhcyB0cmlnZ2VyZWRcbiAgICogYW5kIGNsZWFycyB0aGUgbGlzdCBvZiB0cmFja2VkIGxvZyBncm91cHNcbiAgICovXG4gIHB1YmxpYyBkZWFjdGl2YXRlKCk6IHZvaWQge1xuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIHRoaXMuZW52c0xvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLmNsZWFyKCk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBDbG91ZFdhdGNoIGxvZyBncm91cHMgdG8gcmVhZCBsb2cgZXZlbnRzIGZyb20uXG4gICAqIFNpbmNlIHdlIGNvdWxkIGJlIHdhdGNoaW5nIG11bHRpcGxlIHN0YWNrcyB0aGF0IGRlcGxveSB0b1xuICAgKiBtdWx0aXBsZSBlbnZpcm9ubWVudHMgKGFjY291bnQrcmVnaW9uKSwgd2UgbmVlZCB0byBzdG9yZSBhIGxpc3Qgb2YgbG9nIGdyb3Vwc1xuICAgKiBwZXIgZW52IGFsb25nIHdpdGggdGhlIFNESyBvYmplY3QgdGhhdCBoYXMgYWNjZXNzIHRvIHJlYWQgZnJvbVxuICAgKiB0aGF0IGVudmlyb25tZW50LlxuICAgKi9cbiAgcHVibGljIGFkZExvZ0dyb3VwcyhlbnY6IGN4YXBpLkVudmlyb25tZW50LCBzZGs6IElTREssIGxvZ0dyb3VwTmFtZXM6IHN0cmluZ1tdKTogdm9pZCB7XG4gICAgY29uc3QgYXdzRW52ID0gYCR7ZW52LmFjY291bnR9OiR7ZW52LnJlZ2lvbn1gO1xuICAgIGNvbnN0IGxvZ0dyb3Vwc1N0YXJ0VGltZXMgPSBsb2dHcm91cE5hbWVzLnJlZHVjZSgoYWNjLCBncm91cE5hbWUpID0+IHtcbiAgICAgIGFjY1tncm91cE5hbWVdID0gdGhpcy5zdGFydFRpbWU7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9IGFzIHsgW2xvZ0dyb3VwTmFtZTogc3RyaW5nXTogbnVtYmVyIH0pO1xuICAgIHRoaXMuZW52c0xvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLnNldChhd3NFbnYsIHtcbiAgICAgIHNkayxcbiAgICAgIGxvZ0dyb3Vwc1N0YXJ0VGltZXM6IHtcbiAgICAgICAgLi4udGhpcy5lbnZzTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MuZ2V0KGF3c0Vudik/LmxvZ0dyb3Vwc1N0YXJ0VGltZXMsXG4gICAgICAgIC4uLmxvZ0dyb3Vwc1N0YXJ0VGltZXMsXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzY2hlZHVsZU5leHRUaWNrKHNsZWVwOiBudW1iZXIpOiB2b2lkIHtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHZvaWQodGhpcy50aWNrKCkpLCBzbGVlcCk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHRpY2soKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKCF0aGlzLmFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgZXZlbnRzID0gZmxhdHRlbihhd2FpdCB0aGlzLnJlYWROZXdFdmVudHMoKSk7XG4gICAgICBldmVudHMuZm9yRWFjaChldmVudCA9PiB7XG4gICAgICAgIHRoaXMucHJpbnQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3IoJ0Vycm9yIG9jY3VycmVkIHdoaWxlIG1vbml0b3JpbmcgbG9nczogJXMnLCBlKTtcbiAgICB9XG5cbiAgICB0aGlzLnNjaGVkdWxlTmV4dFRpY2soU0xFRVApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGFsbCBuZXcgbG9nIGV2ZW50cyBmcm9tIGEgc2V0IG9mIENsb3VkV2F0Y2ggTG9nIEdyb3Vwc1xuICAgKiBpbiBwYXJhbGxlbFxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyByZWFkTmV3RXZlbnRzKCk6IFByb21pc2U8QXJyYXk8QXJyYXk8Q2xvdWRXYXRjaExvZ0V2ZW50Pj4+IHtcbiAgICBjb25zdCBwcm9taXNlczogQXJyYXk8UHJvbWlzZTxBcnJheTxDbG91ZFdhdGNoTG9nRXZlbnQ+Pj4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNldHRpbmdzIG9mIHRoaXMuZW52c0xvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLnZhbHVlcygpKSB7XG4gICAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIE9iamVjdC5rZXlzKHNldHRpbmdzLmxvZ0dyb3Vwc1N0YXJ0VGltZXMpKSB7XG4gICAgICAgIHByb21pc2VzLnB1c2godGhpcy5yZWFkRXZlbnRzRnJvbUxvZ0dyb3VwKHNldHRpbmdzLCBncm91cCkpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaW50IG91dCBhIGNsb3Vkd2F0Y2ggZXZlbnRcbiAgICovXG4gIHByaXZhdGUgcHJpbnQoZXZlbnQ6IENsb3VkV2F0Y2hMb2dFdmVudCk6IHZvaWQge1xuICAgIHByaW50KHV0aWwuZm9ybWF0KCdbJXNdICVzICVzJyxcbiAgICAgIGNoYWxrLmJsdWUoZXZlbnQubG9nR3JvdXBOYW1lKSxcbiAgICAgIGNoYWxrLnllbGxvdyhldmVudC50aW1lc3RhbXAudG9Mb2NhbGVUaW1lU3RyaW5nKCkpLFxuICAgICAgZXZlbnQubWVzc2FnZS50cmltKCkpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBhbGwgbmV3IGxvZyBldmVudHMgZnJvbSBhIENsb3VkV2F0Y2ggTG9nIEdyb3VwXG4gICAqIHN0YXJ0aW5nIGF0IGVpdGhlciB0aGUgdGltZSB0aGUgaG90c3dhcCB3YXMgdHJpZ2dlcmVkIG9yXG4gICAqIHdoZW4gdGhlIGxhc3QgZXZlbnQgd2FzIHJlYWQgb24gdGhlIHByZXZpb3VzIHRpY2tcbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcmVhZEV2ZW50c0Zyb21Mb2dHcm91cChcbiAgICBsb2dHcm91cHNBY2Nlc3NTZXR0aW5nczogTG9nR3JvdXBzQWNjZXNzU2V0dGluZ3MsXG4gICAgbG9nR3JvdXBOYW1lOiBzdHJpbmcsXG4gICk6IFByb21pc2U8QXJyYXk8Q2xvdWRXYXRjaExvZ0V2ZW50Pj4ge1xuICAgIGNvbnN0IGV2ZW50czogQ2xvdWRXYXRjaExvZ0V2ZW50W10gPSBbXTtcblxuICAgIC8vIGxvZyBldmVudHMgZnJvbSBzb21lIHNlcnZpY2UgYXJlIGluZ2VzdGVkIGZhc3RlciB0aGFuIG90aGVyc1xuICAgIC8vIHNvIHdlIG5lZWQgdG8gdHJhY2sgdGhlIHN0YXJ0L2VuZCB0aW1lIGZvciBlYWNoIGxvZyBncm91cCBpbmRpdmlkdWFsbHlcbiAgICAvLyB0byBtYWtlIHN1cmUgdGhhdCB3ZSBwcm9jZXNzIGFsbCBldmVudHMgZnJvbSBlYWNoIGxvZyBncm91cFxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGxvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLmxvZ0dyb3Vwc1N0YXJ0VGltZXNbbG9nR3JvdXBOYW1lXSA/PyB0aGlzLnN0YXJ0VGltZTtcbiAgICBsZXQgZW5kVGltZSA9IHN0YXJ0VGltZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsb2dHcm91cHNBY2Nlc3NTZXR0aW5ncy5zZGsuY2xvdWRXYXRjaExvZ3MoKS5maWx0ZXJMb2dFdmVudHMoe1xuICAgICAgICBsb2dHcm91cE5hbWU6IGxvZ0dyb3VwTmFtZSxcbiAgICAgICAgbGltaXQ6IDEwMCxcbiAgICAgICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgICB9KS5wcm9taXNlKCk7XG4gICAgICBjb25zdCBmaWx0ZXJlZEV2ZW50cyA9IHJlc3BvbnNlLmV2ZW50cyA/PyBbXTtcblxuICAgICAgZm9yIChjb25zdCBldmVudCBvZiBmaWx0ZXJlZEV2ZW50cykge1xuICAgICAgICBpZiAoZXZlbnQubWVzc2FnZSkge1xuICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UsXG4gICAgICAgICAgICBsb2dHcm91cE5hbWUsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IGV2ZW50LnRpbWVzdGFtcCA/IG5ldyBEYXRlKGV2ZW50LnRpbWVzdGFtcCkgOiBuZXcgRGF0ZSgpLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKGV2ZW50LnRpbWVzdGFtcCAmJiBlbmRUaW1lIDwgZXZlbnQudGltZXN0YW1wKSB7XG4gICAgICAgICAgICBlbmRUaW1lID0gZXZlbnQudGltZXN0YW1wO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBcyBsb25nIGFzIHRoZXJlIGFyZSBfYW55XyBldmVudHMgaW4gdGhlIGxvZyBncm91cCBgZmlsdGVyTG9nRXZlbnRzYCB3aWxsIHJldHVybiBhIG5leHRUb2tlbi5cbiAgICAgIC8vIFRoaXMgaXMgdHJ1ZSBldmVuIGlmIHRoZXNlIGV2ZW50cyBhcmUgYmVmb3JlIGBzdGFydFRpbWVgLiBTbyBpZiB3ZSBoYXZlIDEwMCBldmVudHMgYW5kIGEgbmV4dFRva2VuXG4gICAgICAvLyB0aGVuIGFzc3VtZSB0aGF0IHdlIGhhdmUgaGl0IHRoZSBsaW1pdCBhbmQgbGV0IHRoZSB1c2VyIGtub3cgc29tZSBtZXNzYWdlcyBoYXZlIGJlZW4gc3VwcmVzc2VkLlxuICAgICAgLy8gV2UgYXJlIGVzc2VudGlhbGx5IHNob3dpbmcgdGhlbSBhIHNhbXBsaW5nICgxMDAwMCBldmVudHMgcHJpbnRlZCBvdXQgaXMgbm90IHZlcnkgdXNlZnVsKVxuICAgICAgaWYgKGZpbHRlcmVkRXZlbnRzLmxlbmd0aCA9PT0gMTAwICYmIHJlc3BvbnNlLm5leHRUb2tlbikge1xuICAgICAgICBldmVudHMucHVzaCh7XG4gICAgICAgICAgbWVzc2FnZTogJz4+PiBgd2F0Y2hgIHNob3dzIG9ubHkgdGhlIGZpcnN0IDEwMCBsb2cgbWVzc2FnZXMgLSB0aGUgcmVzdCBoYXZlIGJlZW4gdHJ1bmNhdGVkLi4uJyxcbiAgICAgICAgICBsb2dHcm91cE5hbWUsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShlbmRUaW1lKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gd2l0aCBMYW1iZGEgZnVuY3Rpb25zIHRoZSBDbG91ZFdhdGNoIGlzIG5vdCBjcmVhdGVkXG4gICAgICAvLyB1bnRpbCBzb21ldGhpbmcgaXMgbG9nZ2VkLCBzbyBqdXN0IGtlZXAgcG9sbGluZyB1bnRpbFxuICAgICAgLy8gdGhlcmUgaXMgc29tdGhpbmcgdG8gZmluZFxuICAgICAgaWYgKGUuY29kZSA9PT0gJ1Jlc291cmNlTm90Rm91bmRFeGNlcHRpb24nKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGxvZ0dyb3Vwc0FjY2Vzc1NldHRpbmdzLmxvZ0dyb3Vwc1N0YXJ0VGltZXNbbG9nR3JvdXBOYW1lXSA9IGVuZFRpbWUgKyAxO1xuICAgIHJldHVybiBldmVudHM7XG4gIH1cbn1cbiJdfQ==