"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableLambdaFunctionChange = void 0;
const stream_1 = require("stream");
const AWS = require("aws-sdk");
const util_1 = require("../../util");
const evaluate_cloudformation_template_1 = require("../evaluate-cloudformation-template");
const common_1 = require("./common");
// namespace object imports won't work in the bundle for function exports
// eslint-disable-next-line @typescript-eslint/no-require-imports
const archiver = require('archiver');
/**
 * Returns `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if the change cannot be short-circuited,
 * `ChangeHotswapImpact.IRRELEVANT` if the change is irrelevant from a short-circuit perspective
 * (like a change to CDKMetadata),
 * or a LambdaFunctionResource if the change can be short-circuited.
 */
async function isHotswappableLambdaFunctionChange(logicalId, change, evaluateCfnTemplate) {
    var _a;
    // if the change is for a Lambda Version,
    // ignore it by returning an empty hotswap operation -
    // we will publish a new version when we get to hotswapping the actual Function this Version points to, below
    // (Versions can't be changed in CloudFormation anyway, they're immutable)
    if (change.newValue.Type === 'AWS::Lambda::Version') {
        return common_1.ChangeHotswapImpact.IRRELEVANT;
    }
    // we handle Aliases specially too
    if (change.newValue.Type === 'AWS::Lambda::Alias') {
        return checkAliasHasVersionOnlyChange(change);
    }
    const lambdaCodeChange = await isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate);
    if (typeof lambdaCodeChange === 'string') {
        return lambdaCodeChange;
    }
    const functionName = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, (_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.FunctionName);
    if (!functionName) {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    const functionArn = await evaluateCfnTemplate.evaluateCfnExpression({
        'Fn::Sub': 'arn:${AWS::Partition}:lambda:${AWS::Region}:${AWS::AccountId}:function:' + functionName,
    });
    // find all Lambda Versions that reference this Function
    const versionsReferencingFunction = evaluateCfnTemplate.findReferencesTo(logicalId)
        .filter(r => r.Type === 'AWS::Lambda::Version');
    // find all Lambda Aliases that reference the above Versions
    const aliasesReferencingVersions = util_1.flatMap(versionsReferencingFunction, v => evaluateCfnTemplate.findReferencesTo(v.LogicalId));
    const aliasesNames = await Promise.all(aliasesReferencingVersions.map(a => { var _a; return evaluateCfnTemplate.evaluateCfnExpression((_a = a.Properties) === null || _a === void 0 ? void 0 : _a.Name); }));
    return new LambdaFunctionHotswapOperation({
        physicalName: functionName,
        functionArn: functionArn,
        resource: lambdaCodeChange,
        publishVersion: versionsReferencingFunction.length > 0,
        aliasesNames,
    });
}
exports.isHotswappableLambdaFunctionChange = isHotswappableLambdaFunctionChange;
/**
 * Returns  is a given Alias change is only in the 'FunctionVersion' property,
 * and `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` is the change is for any other property.
 */
function checkAliasHasVersionOnlyChange(change) {
    for (const updatedPropName in change.propertyUpdates) {
        if (updatedPropName !== 'FunctionVersion') {
            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    return common_1.ChangeHotswapImpact.IRRELEVANT;
}
/**
 * Returns `ChangeHotswapImpact.IRRELEVANT` if the change is not for a AWS::Lambda::Function,
 * but doesn't prevent short-circuiting
 * (like a change to CDKMetadata resource),
 * `ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT` if the change is to a AWS::Lambda::Function,
 * but not only to its Code property,
 * or a LambdaFunctionCode if the change is to a AWS::Lambda::Function,
 * and only affects its Code property.
 */
async function isLambdaFunctionCodeOnlyChange(change, evaluateCfnTemplate) {
    var _a;
    const newResourceType = change.newValue.Type;
    if (newResourceType !== 'AWS::Lambda::Function') {
        return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
    }
    /*
     * At first glance, we would want to initialize these using the "previous" values (change.oldValue),
     * in case only one of them changed, like the key, and the Bucket stayed the same.
     * However, that actually fails for old-style synthesis, which uses CFN Parameters!
     * Because the names of the Parameters depend on the hash of the Asset,
     * the Parameters used for the "old" values no longer exist in `assetParams` at this point,
     * which means we don't have the correct values available to evaluate the CFN expression with.
     * Fortunately, the diff will always include both the s3Bucket and s3Key parts of the Lambda's Code property,
     * even if only one of them was actually changed,
     * which means we don't need the "old" values at all, and we can safely initialize these with just `''`.
     */
    const propertyUpdates = change.propertyUpdates;
    let code = undefined;
    let tags = undefined;
    for (const updatedPropName in propertyUpdates) {
        const updatedProp = propertyUpdates[updatedPropName];
        switch (updatedPropName) {
            case 'Code':
                let foundCodeDifference = false;
                let s3Bucket, s3Key, imageUri, functionCodeZip;
                for (const newPropName in updatedProp.newValue) {
                    switch (newPropName) {
                        case 'S3Bucket':
                            foundCodeDifference = true;
                            s3Bucket = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'S3Key':
                            foundCodeDifference = true;
                            s3Key = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'ImageUri':
                            foundCodeDifference = true;
                            imageUri = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            break;
                        case 'ZipFile':
                            foundCodeDifference = true;
                            // We must create a zip package containing a file with the inline code
                            const functionCode = await evaluateCfnTemplate.evaluateCfnExpression(updatedProp.newValue[newPropName]);
                            const functionRuntime = await evaluateCfnTemplate.evaluateCfnExpression((_a = change.newValue.Properties) === null || _a === void 0 ? void 0 : _a.Runtime);
                            if (!functionRuntime) {
                                return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
                            }
                            // file extension must be chosen depending on the runtime
                            const codeFileExt = determineCodeFileExtFromRuntime(functionRuntime);
                            functionCodeZip = await zipString(`index.${codeFileExt}`, functionCode);
                            break;
                        default:
                            return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
                    }
                }
                if (foundCodeDifference) {
                    code = {
                        s3Bucket,
                        s3Key,
                        imageUri,
                        functionCodeZip,
                    };
                }
                break;
            case 'Tags':
                /*
                 * Tag updates are a bit odd; they manifest as two lists, are flagged only as
                 * `isDifferent`, and we have to reconcile them.
                 */
                const tagUpdates = {};
                if (updatedProp === null || updatedProp === void 0 ? void 0 : updatedProp.isDifferent) {
                    updatedProp.newValue.forEach((tag) => {
                        tagUpdates[tag.Key] = tag.Value;
                    });
                    updatedProp.oldValue.forEach((tag) => {
                        if (tagUpdates[tag.Key] === undefined) {
                            tagUpdates[tag.Key] = TagDeletion.DELETE;
                        }
                    });
                    tags = { tagUpdates };
                }
                break;
            default:
                return common_1.ChangeHotswapImpact.REQUIRES_FULL_DEPLOYMENT;
        }
    }
    return code || tags ? { code, tags } : common_1.ChangeHotswapImpact.IRRELEVANT;
}
var TagDeletion;
(function (TagDeletion) {
    TagDeletion[TagDeletion["DELETE"] = -1] = "DELETE";
})(TagDeletion || (TagDeletion = {}));
class LambdaFunctionHotswapOperation {
    constructor(lambdaFunctionResource) {
        this.lambdaFunctionResource = lambdaFunctionResource;
        this.service = 'lambda-function';
        this.resourceNames = [
            `Lambda Function '${lambdaFunctionResource.physicalName}'`,
            // add Version here if we're publishing a new one
            ...(lambdaFunctionResource.publishVersion ? [`Lambda Version for Function '${lambdaFunctionResource.physicalName}'`] : []),
            // add any Aliases that we are hotswapping here
            ...lambdaFunctionResource.aliasesNames.map(alias => `Lambda Alias '${alias}' for Function '${lambdaFunctionResource.physicalName}'`),
        ];
    }
    async apply(sdk) {
        const lambda = sdk.lambda();
        const resource = this.lambdaFunctionResource.resource;
        const operations = [];
        if (resource.code !== undefined) {
            const updateFunctionCodeResponse = await lambda.updateFunctionCode({
                FunctionName: this.lambdaFunctionResource.physicalName,
                S3Bucket: resource.code.s3Bucket,
                S3Key: resource.code.s3Key,
                ImageUri: resource.code.imageUri,
                ZipFile: resource.code.functionCodeZip,
            }).promise();
            await this.waitForLambdasCodeUpdateToFinish(updateFunctionCodeResponse, lambda);
            // only if the code changed is there any point in publishing a new Version
            if (this.lambdaFunctionResource.publishVersion) {
                const publishVersionPromise = lambda.publishVersion({
                    FunctionName: this.lambdaFunctionResource.physicalName,
                }).promise();
                if (this.lambdaFunctionResource.aliasesNames.length > 0) {
                    // we need to wait for the Version to finish publishing
                    const versionUpdate = await publishVersionPromise;
                    for (const alias of this.lambdaFunctionResource.aliasesNames) {
                        operations.push(lambda.updateAlias({
                            FunctionName: this.lambdaFunctionResource.physicalName,
                            Name: alias,
                            FunctionVersion: versionUpdate.Version,
                        }).promise());
                    }
                }
                else {
                    operations.push(publishVersionPromise);
                }
            }
        }
        if (resource.tags !== undefined) {
            const tagsToDelete = Object.entries(resource.tags.tagUpdates)
                .filter(([_key, val]) => val === TagDeletion.DELETE)
                .map(([key, _val]) => key);
            const tagsToSet = {};
            Object.entries(resource.tags.tagUpdates)
                .filter(([_key, val]) => val !== TagDeletion.DELETE)
                .forEach(([tagName, tagValue]) => {
                tagsToSet[tagName] = tagValue;
            });
            if (tagsToDelete.length > 0) {
                operations.push(lambda.untagResource({
                    Resource: this.lambdaFunctionResource.functionArn,
                    TagKeys: tagsToDelete,
                }).promise());
            }
            if (Object.keys(tagsToSet).length > 0) {
                operations.push(lambda.tagResource({
                    Resource: this.lambdaFunctionResource.functionArn,
                    Tags: tagsToSet,
                }).promise());
            }
        }
        // run all of our updates in parallel
        return Promise.all(operations);
    }
    /**
     * After a Lambda Function is updated, it cannot be updated again until the
     * `State=Active` and the `LastUpdateStatus=Successful`.
     *
     * Depending on the configuration of the Lambda Function this could happen relatively quickly
     * or very slowly. For example, Zip based functions _not_ in a VPC can take ~1 second whereas VPC
     * or Container functions can take ~25 seconds (and 'idle' VPC functions can take minutes).
     */
    async waitForLambdasCodeUpdateToFinish(currentFunctionConfiguration, lambda) {
        var _a;
        const functionIsInVpcOrUsesDockerForCode = ((_a = currentFunctionConfiguration.VpcConfig) === null || _a === void 0 ? void 0 : _a.VpcId) ||
            currentFunctionConfiguration.PackageType === 'Image';
        // if the function is deployed in a VPC or if it is a container image function
        // then the update will take much longer and we can wait longer between checks
        // otherwise, the update will be quick, so a 1-second delay is fine
        const delaySeconds = functionIsInVpcOrUsesDockerForCode ? 5 : 1;
        // configure a custom waiter to wait for the function update to complete
        lambda.api.waiters.updateFunctionCodeToFinish = {
            name: 'UpdateFunctionCodeToFinish',
            operation: 'getFunction',
            // equates to 1 minute for zip function not in a VPC and
            // 5 minutes for container functions or function in a VPC
            maxAttempts: 60,
            delay: delaySeconds,
            acceptors: [
                {
                    matcher: 'path',
                    argument: "Configuration.LastUpdateStatus == 'Successful' && Configuration.State == 'Active'",
                    expected: true,
                    state: 'success',
                },
                {
                    matcher: 'path',
                    argument: 'Configuration.LastUpdateStatus',
                    expected: 'Failed',
                    state: 'failure',
                },
            ],
        };
        const updateFunctionCodeWaiter = new AWS.ResourceWaiter(lambda, 'updateFunctionCodeToFinish');
        await updateFunctionCodeWaiter.wait({
            FunctionName: this.lambdaFunctionResource.physicalName,
        }).promise();
    }
}
/**
 * Compress a string as a file, returning a promise for the zip buffer
 * https://github.com/archiverjs/node-archiver/issues/342
 */
function zipString(fileName, rawString) {
    return new Promise((resolve, reject) => {
        const buffers = [];
        const converter = new stream_1.Writable();
        converter._write = (chunk, _, callback) => {
            buffers.push(chunk);
            process.nextTick(callback);
        };
        converter.on('finish', () => {
            resolve(Buffer.concat(buffers));
        });
        const archive = archiver('zip');
        archive.on('error', (err) => {
            reject(err);
        });
        archive.pipe(converter);
        archive.append(rawString, {
            name: fileName,
            date: new Date('1980-01-01T00:00:00.000Z'),
        });
        void archive.finalize();
    });
}
/**
 * Get file extension from Lambda runtime string.
 * We use this extension to create a deployment package from Lambda inline code.
 */
function determineCodeFileExtFromRuntime(runtime) {
    if (runtime.startsWith('node')) {
        return 'js';
    }
    if (runtime.startsWith('python')) {
        return 'py';
    }
    // Currently inline code only supports Node.js and Python, ignoring other runtimes.
    // https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-properties-lambda-function-code.html#aws-properties-lambda-function-code-properties
    throw new evaluate_cloudformation_template_1.CfnEvaluationException(`runtime ${runtime} is unsupported, only node.js and python runtimes are currently supported.`);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImxhbWJkYS1mdW5jdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsbUNBQWtDO0FBQ2xDLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFFckMsMEZBQTZHO0FBQzdHLHFDQUFtSDtBQUVuSCx5RUFBeUU7QUFDekUsaUVBQWlFO0FBQ2pFLE1BQU0sUUFBUSxHQUFHLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUVyQzs7Ozs7R0FLRztBQUNJLEtBQUssVUFBVSxrQ0FBa0MsQ0FDdEQsU0FBaUIsRUFBRSxNQUFtQyxFQUFFLG1CQUFtRDs7SUFFM0cseUNBQXlDO0lBQ3pDLHNEQUFzRDtJQUN0RCw2R0FBNkc7SUFDN0csMEVBQTBFO0lBQzFFLElBQUksTUFBTSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEtBQUssc0JBQXNCLEVBQUU7UUFDbkQsT0FBTyw0QkFBbUIsQ0FBQyxVQUFVLENBQUM7S0FDdkM7SUFFRCxrQ0FBa0M7SUFDbEMsSUFBSSxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksS0FBSyxvQkFBb0IsRUFBRTtRQUNqRCxPQUFPLDhCQUE4QixDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQy9DO0lBRUQsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLDhCQUE4QixDQUFDLE1BQU0sRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO0lBQzNGLElBQUksT0FBTyxnQkFBZ0IsS0FBSyxRQUFRLEVBQUU7UUFDeEMsT0FBTyxnQkFBZ0IsQ0FBQztLQUN6QjtJQUVELE1BQU0sWUFBWSxHQUFHLE1BQU0sbUJBQW1CLENBQUMsNkJBQTZCLENBQUMsU0FBUyxRQUFFLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSwwQ0FBRSxZQUFZLENBQUMsQ0FBQztJQUNsSSxJQUFJLENBQUMsWUFBWSxFQUFFO1FBQ2pCLE9BQU8sNEJBQW1CLENBQUMsd0JBQXdCLENBQUM7S0FDckQ7SUFFRCxNQUFNLFdBQVcs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LENBQUMsRUFBRSxDQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUU7WUFDMUIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQztRQUNsQyxDQUFDLENBQUMsQ0FBQztRQUVILE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUVoQyxPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQVEsRUFBRSxFQUFFO1lBQy9CLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUNkLENBQUMsQ0FBQyxDQUFDO1FBRUgsT0FBTyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUV4QixPQUFPLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRTtZQUN4QixJQUFJLEVBQUUsUUFBUTtZQUNkLElBQUksRUFBRSxJQUFJLElBQUksQ0FBQywwQkFBMEIsQ0FBQztTQUMzQyxDQUFDLENBQUM7UUFFSCxLQUFLLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMxQixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFTLCtCQUErQixDQUFDLE9BQWU7SUFDdEQsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQzlCLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsUUFBUSxDQUFDLEVBQUU7UUFDaEMsT0FBTyxJQUFJLENBQUM7S0FDYjtJQUNELG1GQUFtRjtJQUNuRix5SkFBeUo7SUFDekosTUFBTSxJQUFJLHlEQUFzQixDQUFDLFdBQVcsT0FBTyw0RUFBNEUsQ0FBQyxDQUFDO0FBQ25JLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXcml0YWJsZSB9IGZyb20gJ3N0cmVhbSc7XG5pbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBmbGF0TWFwIH0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQgeyBJU0RLIH0gZnJvbSAnLi4vYXdzLWF1dGgnO1xuaW1wb3J0IHsgQ2ZuRXZhbHVhdGlvbkV4Y2VwdGlvbiwgRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlIH0gZnJvbSAnLi4vZXZhbHVhdGUtY2xvdWRmb3JtYXRpb24tdGVtcGxhdGUnO1xuaW1wb3J0IHsgQ2hhbmdlSG90c3dhcEltcGFjdCwgQ2hhbmdlSG90c3dhcFJlc3VsdCwgSG90c3dhcE9wZXJhdGlvbiwgSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlIH0gZnJvbSAnLi9jb21tb24nO1xuXG4vLyBuYW1lc3BhY2Ugb2JqZWN0IGltcG9ydHMgd29uJ3Qgd29yayBpbiB0aGUgYnVuZGxlIGZvciBmdW5jdGlvbiBleHBvcnRzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgYXJjaGl2ZXIgPSByZXF1aXJlKCdhcmNoaXZlcicpO1xuXG4vKipcbiAqIFJldHVybnMgYENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UYCBpZiB0aGUgY2hhbmdlIGNhbm5vdCBiZSBzaG9ydC1jaXJjdWl0ZWQsXG4gKiBgQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UYCBpZiB0aGUgY2hhbmdlIGlzIGlycmVsZXZhbnQgZnJvbSBhIHNob3J0LWNpcmN1aXQgcGVyc3BlY3RpdmVcbiAqIChsaWtlIGEgY2hhbmdlIHRvIENES01ldGFkYXRhKSxcbiAqIG9yIGEgTGFtYmRhRnVuY3Rpb25SZXNvdXJjZSBpZiB0aGUgY2hhbmdlIGNhbiBiZSBzaG9ydC1jaXJjdWl0ZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0hvdHN3YXBwYWJsZUxhbWJkYUZ1bmN0aW9uQ2hhbmdlKFxuICBsb2dpY2FsSWQ6IHN0cmluZywgY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUsIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSxcbik6IFByb21pc2U8Q2hhbmdlSG90c3dhcFJlc3VsdD4ge1xuICAvLyBpZiB0aGUgY2hhbmdlIGlzIGZvciBhIExhbWJkYSBWZXJzaW9uLFxuICAvLyBpZ25vcmUgaXQgYnkgcmV0dXJuaW5nIGFuIGVtcHR5IGhvdHN3YXAgb3BlcmF0aW9uIC1cbiAgLy8gd2Ugd2lsbCBwdWJsaXNoIGEgbmV3IHZlcnNpb24gd2hlbiB3ZSBnZXQgdG8gaG90c3dhcHBpbmcgdGhlIGFjdHVhbCBGdW5jdGlvbiB0aGlzIFZlcnNpb24gcG9pbnRzIHRvLCBiZWxvd1xuICAvLyAoVmVyc2lvbnMgY2FuJ3QgYmUgY2hhbmdlZCBpbiBDbG91ZEZvcm1hdGlvbiBhbnl3YXksIHRoZXkncmUgaW1tdXRhYmxlKVxuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgPT09ICdBV1M6OkxhbWJkYTo6VmVyc2lvbicpIHtcbiAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UO1xuICB9XG5cbiAgLy8gd2UgaGFuZGxlIEFsaWFzZXMgc3BlY2lhbGx5IHRvb1xuICBpZiAoY2hhbmdlLm5ld1ZhbHVlLlR5cGUgPT09ICdBV1M6OkxhbWJkYTo6QWxpYXMnKSB7XG4gICAgcmV0dXJuIGNoZWNrQWxpYXNIYXNWZXJzaW9uT25seUNoYW5nZShjaGFuZ2UpO1xuICB9XG5cbiAgY29uc3QgbGFtYmRhQ29kZUNoYW5nZSA9IGF3YWl0IGlzTGFtYmRhRnVuY3Rpb25Db2RlT25seUNoYW5nZShjaGFuZ2UsIGV2YWx1YXRlQ2ZuVGVtcGxhdGUpO1xuICBpZiAodHlwZW9mIGxhbWJkYUNvZGVDaGFuZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGxhbWJkYUNvZGVDaGFuZ2U7XG4gIH1cblxuICBjb25zdCBmdW5jdGlvbk5hbWUgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmVzdGFibGlzaFJlc291cmNlUGh5c2ljYWxOYW1lKGxvZ2ljYWxJZCwgY2hhbmdlLm5ld1ZhbHVlLlByb3BlcnRpZXM/LkZ1bmN0aW9uTmFtZSk7XG4gIGlmICghZnVuY3Rpb25OYW1lKSB7XG4gICAgcmV0dXJuIENoYW5nZUhvdHN3YXBJbXBhY3QuUkVRVUlSRVNfRlVMTF9ERVBMT1lNRU5UO1xuICB9XG5cbiAgY29uc3QgZnVuY3Rpb25Bcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih7XG4gICAgJ0ZuOjpTdWInOiAnYXJuOiR7QVdTOjpQYXJ0aXRpb259OmxhbWJkYToke0FXUzo6UmVnaW9ufToke0FXUzo6QWNjb3VudElkfTpmdW5jdGlvbjonICsgZnVuY3Rpb25OYW1lLFxuICB9KTtcblxuICAvLyBmaW5kIGFsbCBMYW1iZGEgVmVyc2lvbnMgdGhhdCByZWZlcmVuY2UgdGhpcyBGdW5jdGlvblxuICBjb25zdCB2ZXJzaW9uc1JlZmVyZW5jaW5nRnVuY3Rpb24gPSBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRSZWZlcmVuY2VzVG8obG9naWNhbElkKVxuICAgIC5maWx0ZXIociA9PiByLlR5cGUgPT09ICdBV1M6OkxhbWJkYTo6VmVyc2lvbicpO1xuICAvLyBmaW5kIGFsbCBMYW1iZGEgQWxpYXNlcyB0aGF0IHJlZmVyZW5jZSB0aGUgYWJvdmUgVmVyc2lvbnNcbiAgY29uc3QgYWxpYXNlc1JlZmVyZW5jaW5nVmVyc2lvbnMgPSBmbGF0TWFwKHZlcnNpb25zUmVmZXJlbmNpbmdGdW5jdGlvbiwgdiA9PlxuICAgIGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZmluZFJlZmVyZW5jZXNUbyh2LkxvZ2ljYWxJZCkpO1xuICBjb25zdCBhbGlhc2VzTmFtZXMgPSBhd2FpdCBQcm9taXNlLmFsbChhbGlhc2VzUmVmZXJlbmNpbmdWZXJzaW9ucy5tYXAoYSA9PlxuICAgIGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKGEuUHJvcGVydGllcz8uTmFtZSkpKTtcblxuICByZXR1cm4gbmV3IExhbWJkYUZ1bmN0aW9uSG90c3dhcE9wZXJhdGlvbih7XG4gICAgcGh5c2ljYWxOYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgZnVuY3Rpb25Bcm46IGZ1bmN0aW9uQXJuLFxuICAgIHJlc291cmNlOiBsYW1iZGFDb2RlQ2hhbmdlLFxuICAgIHB1Ymxpc2hWZXJzaW9uOiB2ZXJzaW9uc1JlZmVyZW5jaW5nRnVuY3Rpb24ubGVuZ3RoID4gMCxcbiAgICBhbGlhc2VzTmFtZXMsXG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgIGlzIGEgZ2l2ZW4gQWxpYXMgY2hhbmdlIGlzIG9ubHkgaW4gdGhlICdGdW5jdGlvblZlcnNpb24nIHByb3BlcnR5LFxuICogYW5kIGBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVGAgaXMgdGhlIGNoYW5nZSBpcyBmb3IgYW55IG90aGVyIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBjaGVja0FsaWFzSGFzVmVyc2lvbk9ubHlDaGFuZ2UoY2hhbmdlOiBIb3Rzd2FwcGFibGVDaGFuZ2VDYW5kaWRhdGUpOiBDaGFuZ2VIb3Rzd2FwUmVzdWx0IHtcbiAgZm9yIChjb25zdCB1cGRhdGVkUHJvcE5hbWUgaW4gY2hhbmdlLnByb3BlcnR5VXBkYXRlcykge1xuICAgIGlmICh1cGRhdGVkUHJvcE5hbWUgIT09ICdGdW5jdGlvblZlcnNpb24nKSB7XG4gICAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlQ7XG59XG5cbi8qKlxuICogUmV0dXJucyBgQ2hhbmdlSG90c3dhcEltcGFjdC5JUlJFTEVWQU5UYCBpZiB0aGUgY2hhbmdlIGlzIG5vdCBmb3IgYSBBV1M6OkxhbWJkYTo6RnVuY3Rpb24sXG4gKiBidXQgZG9lc24ndCBwcmV2ZW50IHNob3J0LWNpcmN1aXRpbmdcbiAqIChsaWtlIGEgY2hhbmdlIHRvIENES01ldGFkYXRhIHJlc291cmNlKSxcbiAqIGBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVGAgaWYgdGhlIGNoYW5nZSBpcyB0byBhIEFXUzo6TGFtYmRhOjpGdW5jdGlvbixcbiAqIGJ1dCBub3Qgb25seSB0byBpdHMgQ29kZSBwcm9wZXJ0eSxcbiAqIG9yIGEgTGFtYmRhRnVuY3Rpb25Db2RlIGlmIHRoZSBjaGFuZ2UgaXMgdG8gYSBBV1M6OkxhbWJkYTo6RnVuY3Rpb24sXG4gKiBhbmQgb25seSBhZmZlY3RzIGl0cyBDb2RlIHByb3BlcnR5LlxuICovXG5hc3luYyBmdW5jdGlvbiBpc0xhbWJkYUZ1bmN0aW9uQ29kZU9ubHlDaGFuZ2UoXG4gIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLCBldmFsdWF0ZUNmblRlbXBsYXRlOiBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUsXG4pOiBQcm9taXNlPExhbWJkYUZ1bmN0aW9uQ2hhbmdlIHwgQ2hhbmdlSG90c3dhcEltcGFjdD4ge1xuICBjb25zdCBuZXdSZXNvdXJjZVR5cGUgPSBjaGFuZ2UubmV3VmFsdWUuVHlwZTtcbiAgaWYgKG5ld1Jlc291cmNlVHlwZSAhPT0gJ0FXUzo6TGFtYmRhOjpGdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQ2hhbmdlSG90c3dhcEltcGFjdC5SRVFVSVJFU19GVUxMX0RFUExPWU1FTlQ7XG4gIH1cblxuICAvKlxuICAgKiBBdCBmaXJzdCBnbGFuY2UsIHdlIHdvdWxkIHdhbnQgdG8gaW5pdGlhbGl6ZSB0aGVzZSB1c2luZyB0aGUgXCJwcmV2aW91c1wiIHZhbHVlcyAoY2hhbmdlLm9sZFZhbHVlKSxcbiAgICogaW4gY2FzZSBvbmx5IG9uZSBvZiB0aGVtIGNoYW5nZWQsIGxpa2UgdGhlIGtleSwgYW5kIHRoZSBCdWNrZXQgc3RheWVkIHRoZSBzYW1lLlxuICAgKiBIb3dldmVyLCB0aGF0IGFjdHVhbGx5IGZhaWxzIGZvciBvbGQtc3R5bGUgc3ludGhlc2lzLCB3aGljaCB1c2VzIENGTiBQYXJhbWV0ZXJzIVxuICAgKiBCZWNhdXNlIHRoZSBuYW1lcyBvZiB0aGUgUGFyYW1ldGVycyBkZXBlbmQgb24gdGhlIGhhc2ggb2YgdGhlIEFzc2V0LFxuICAgKiB0aGUgUGFyYW1ldGVycyB1c2VkIGZvciB0aGUgXCJvbGRcIiB2YWx1ZXMgbm8gbG9uZ2VyIGV4aXN0IGluIGBhc3NldFBhcmFtc2AgYXQgdGhpcyBwb2ludCxcbiAgICogd2hpY2ggbWVhbnMgd2UgZG9uJ3QgaGF2ZSB0aGUgY29ycmVjdCB2YWx1ZXMgYXZhaWxhYmxlIHRvIGV2YWx1YXRlIHRoZSBDRk4gZXhwcmVzc2lvbiB3aXRoLlxuICAgKiBGb3J0dW5hdGVseSwgdGhlIGRpZmYgd2lsbCBhbHdheXMgaW5jbHVkZSBib3RoIHRoZSBzM0J1Y2tldCBhbmQgczNLZXkgcGFydHMgb2YgdGhlIExhbWJkYSdzIENvZGUgcHJvcGVydHksXG4gICAqIGV2ZW4gaWYgb25seSBvbmUgb2YgdGhlbSB3YXMgYWN0dWFsbHkgY2hhbmdlZCxcbiAgICogd2hpY2ggbWVhbnMgd2UgZG9uJ3QgbmVlZCB0aGUgXCJvbGRcIiB2YWx1ZXMgYXQgYWxsLCBhbmQgd2UgY2FuIHNhZmVseSBpbml0aWFsaXplIHRoZXNlIHdpdGgganVzdCBgJydgLlxuICAgKi9cbiAgY29uc3QgcHJvcGVydHlVcGRhdGVzID0gY2hhbmdlLnByb3BlcnR5VXBkYXRlcztcbiAgbGV0IGNvZGU6IExhbWJkYUZ1bmN0aW9uQ29kZSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgbGV0IHRhZ3M6IExhbWJkYUZ1bmN0aW9uVGFncyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICBmb3IgKGNvbnN0IHVwZGF0ZWRQcm9wTmFtZSBpbiBwcm9wZXJ0eVVwZGF0ZXMpIHtcbiAgICBjb25zdCB1cGRhdGVkUHJvcCA9IHByb3BlcnR5VXBkYXRlc1t1cGRhdGVkUHJvcE5hbWVdO1xuXG4gICAgc3dpdGNoICh1cGRhdGVkUHJvcE5hbWUpIHtcbiAgICAgIGNhc2UgJ0NvZGUnOlxuICAgICAgICBsZXQgZm91bmRDb2RlRGlmZmVyZW5jZSA9IGZhbHNlO1xuICAgICAgICBsZXQgczNCdWNrZXQsIHMzS2V5LCBpbWFnZVVyaSwgZnVuY3Rpb25Db2RlWmlwO1xuXG4gICAgICAgIGZvciAoY29uc3QgbmV3UHJvcE5hbWUgaW4gdXBkYXRlZFByb3AubmV3VmFsdWUpIHtcbiAgICAgICAgICBzd2l0Y2ggKG5ld1Byb3BOYW1lKSB7XG4gICAgICAgICAgICBjYXNlICdTM0J1Y2tldCc6XG4gICAgICAgICAgICAgIGZvdW5kQ29kZURpZmZlcmVuY2UgPSB0cnVlO1xuICAgICAgICAgICAgICBzM0J1Y2tldCA9IGF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHVwZGF0ZWRQcm9wLm5ld1ZhbHVlW25ld1Byb3BOYW1lXSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnUzNLZXknOlxuICAgICAgICAgICAgICBmb3VuZENvZGVEaWZmZXJlbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgczNLZXkgPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmV2YWx1YXRlQ2ZuRXhwcmVzc2lvbih1cGRhdGVkUHJvcC5uZXdWYWx1ZVtuZXdQcm9wTmFtZV0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0ltYWdlVXJpJzpcbiAgICAgICAgICAgICAgZm91bmRDb2RlRGlmZmVyZW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgIGltYWdlVXJpID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWVbbmV3UHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdaaXBGaWxlJzpcbiAgICAgICAgICAgICAgZm91bmRDb2RlRGlmZmVyZW5jZSA9IHRydWU7XG4gICAgICAgICAgICAgIC8vIFdlIG11c3QgY3JlYXRlIGEgemlwIHBhY2thZ2UgY29udGFpbmluZyBhIGZpbGUgd2l0aCB0aGUgaW5saW5lIGNvZGVcbiAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25Db2RlID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24odXBkYXRlZFByb3AubmV3VmFsdWVbbmV3UHJvcE5hbWVdKTtcbiAgICAgICAgICAgICAgY29uc3QgZnVuY3Rpb25SdW50aW1lID0gYXdhaXQgZXZhbHVhdGVDZm5UZW1wbGF0ZS5ldmFsdWF0ZUNmbkV4cHJlc3Npb24oY2hhbmdlLm5ld1ZhbHVlLlByb3BlcnRpZXM/LlJ1bnRpbWUpO1xuICAgICAgICAgICAgICBpZiAoIWZ1bmN0aW9uUnVudGltZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBmaWxlIGV4dGVuc2lvbiBtdXN0IGJlIGNob3NlbiBkZXBlbmRpbmcgb24gdGhlIHJ1bnRpbWVcbiAgICAgICAgICAgICAgY29uc3QgY29kZUZpbGVFeHQgPSBkZXRlcm1pbmVDb2RlRmlsZUV4dEZyb21SdW50aW1lKGZ1bmN0aW9uUnVudGltZSk7XG4gICAgICAgICAgICAgIGZ1bmN0aW9uQ29kZVppcCA9IGF3YWl0IHppcFN0cmluZyhgaW5kZXguJHtjb2RlRmlsZUV4dH1gLCBmdW5jdGlvbkNvZGUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kQ29kZURpZmZlcmVuY2UpIHtcbiAgICAgICAgICBjb2RlID0ge1xuICAgICAgICAgICAgczNCdWNrZXQsXG4gICAgICAgICAgICBzM0tleSxcbiAgICAgICAgICAgIGltYWdlVXJpLFxuICAgICAgICAgICAgZnVuY3Rpb25Db2RlWmlwLFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdUYWdzJzpcbiAgICAgICAgLypcbiAgICAgICAgICogVGFnIHVwZGF0ZXMgYXJlIGEgYml0IG9kZDsgdGhleSBtYW5pZmVzdCBhcyB0d28gbGlzdHMsIGFyZSBmbGFnZ2VkIG9ubHkgYXNcbiAgICAgICAgICogYGlzRGlmZmVyZW50YCwgYW5kIHdlIGhhdmUgdG8gcmVjb25jaWxlIHRoZW0uXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB0YWdVcGRhdGVzOiB7IFt0YWc6IHN0cmluZ106IHN0cmluZyB8IFRhZ0RlbGV0aW9uIH0gPSB7fTtcbiAgICAgICAgaWYgKHVwZGF0ZWRQcm9wPy5pc0RpZmZlcmVudCkge1xuICAgICAgICAgIHVwZGF0ZWRQcm9wLm5ld1ZhbHVlLmZvckVhY2goKHRhZzogQ2ZuRGlmZlRhZ1ZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0YWdVcGRhdGVzW3RhZy5LZXldID0gdGFnLlZhbHVlO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgdXBkYXRlZFByb3Aub2xkVmFsdWUuZm9yRWFjaCgodGFnOiBDZm5EaWZmVGFnVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICh0YWdVcGRhdGVzW3RhZy5LZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgdGFnVXBkYXRlc1t0YWcuS2V5XSA9IFRhZ0RlbGV0aW9uLkRFTEVURTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIHRhZ3MgPSB7IHRhZ1VwZGF0ZXMgfTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LlJFUVVJUkVTX0ZVTExfREVQTE9ZTUVOVDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29kZSB8fCB0YWdzID8geyBjb2RlLCB0YWdzIH0gOiBDaGFuZ2VIb3Rzd2FwSW1wYWN0LklSUkVMRVZBTlQ7XG59XG5cbmludGVyZmFjZSBDZm5EaWZmVGFnVmFsdWUge1xuICByZWFkb25seSBLZXk6IHN0cmluZztcbiAgcmVhZG9ubHkgVmFsdWU6IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIExhbWJkYUZ1bmN0aW9uQ29kZSB7XG4gIHJlYWRvbmx5IHMzQnVja2V0Pzogc3RyaW5nO1xuICByZWFkb25seSBzM0tleT86IHN0cmluZztcbiAgcmVhZG9ubHkgaW1hZ2VVcmk/OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGZ1bmN0aW9uQ29kZVppcD86IEJ1ZmZlcjtcbn1cblxuZW51bSBUYWdEZWxldGlvbiB7XG4gIERFTEVURSA9IC0xLFxufVxuXG5pbnRlcmZhY2UgTGFtYmRhRnVuY3Rpb25UYWdzIHtcbiAgcmVhZG9ubHkgdGFnVXBkYXRlczogeyBbdGFnIDogc3RyaW5nXSA6IHN0cmluZyB8IFRhZ0RlbGV0aW9uIH07XG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvbkNoYW5nZSB7XG4gIHJlYWRvbmx5IGNvZGU/OiBMYW1iZGFGdW5jdGlvbkNvZGU7XG4gIHJlYWRvbmx5IHRhZ3M/OiBMYW1iZGFGdW5jdGlvblRhZ3M7XG59XG5cbmludGVyZmFjZSBMYW1iZGFGdW5jdGlvblJlc291cmNlIHtcbiAgcmVhZG9ubHkgcGh5c2ljYWxOYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGZ1bmN0aW9uQXJuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHJlc291cmNlOiBMYW1iZGFGdW5jdGlvbkNoYW5nZTtcbiAgcmVhZG9ubHkgcHVibGlzaFZlcnNpb246IGJvb2xlYW47XG4gIHJlYWRvbmx5IGFsaWFzZXNOYW1lczogc3RyaW5nW107XG59XG5cbmNsYXNzIExhbWJkYUZ1bmN0aW9uSG90c3dhcE9wZXJhdGlvbiBpbXBsZW1lbnRzIEhvdHN3YXBPcGVyYXRpb24ge1xuICBwdWJsaWMgcmVhZG9ubHkgc2VydmljZSA9ICdsYW1iZGEtZnVuY3Rpb24nO1xuICBwdWJsaWMgcmVhZG9ubHkgcmVzb3VyY2VOYW1lczogc3RyaW5nW107XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBsYW1iZGFGdW5jdGlvblJlc291cmNlOiBMYW1iZGFGdW5jdGlvblJlc291cmNlKSB7XG4gICAgdGhpcy5yZXNvdXJjZU5hbWVzID0gW1xuICAgICAgYExhbWJkYSBGdW5jdGlvbiAnJHtsYW1iZGFGdW5jdGlvblJlc291cmNlLnBoeXNpY2FsTmFtZX0nYCxcbiAgICAgIC8vIGFkZCBWZXJzaW9uIGhlcmUgaWYgd2UncmUgcHVibGlzaGluZyBhIG5ldyBvbmVcbiAgICAgIC4uLihsYW1iZGFGdW5jdGlvblJlc291cmNlLnB1Ymxpc2hWZXJzaW9uID8gW2BMYW1iZGEgVmVyc2lvbiBmb3IgRnVuY3Rpb24gJyR7bGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWV9J2BdIDogW10pLFxuICAgICAgLy8gYWRkIGFueSBBbGlhc2VzIHRoYXQgd2UgYXJlIGhvdHN3YXBwaW5nIGhlcmVcbiAgICAgIC4uLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UuYWxpYXNlc05hbWVzLm1hcChhbGlhcyA9PiBgTGFtYmRhIEFsaWFzICcke2FsaWFzfScgZm9yIEZ1bmN0aW9uICcke2xhbWJkYUZ1bmN0aW9uUmVzb3VyY2UucGh5c2ljYWxOYW1lfSdgKSxcbiAgICBdO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGFwcGx5KHNkazogSVNESyk6IFByb21pc2U8YW55PiB7XG4gICAgY29uc3QgbGFtYmRhID0gc2RrLmxhbWJkYSgpO1xuICAgIGNvbnN0IHJlc291cmNlID0gdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLnJlc291cmNlO1xuICAgIGNvbnN0IG9wZXJhdGlvbnM6IFByb21pc2U8YW55PltdID0gW107XG5cbiAgICBpZiAocmVzb3VyY2UuY29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB1cGRhdGVGdW5jdGlvbkNvZGVSZXNwb25zZSA9IGF3YWl0IGxhbWJkYS51cGRhdGVGdW5jdGlvbkNvZGUoe1xuICAgICAgICBGdW5jdGlvbk5hbWU6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWUsXG4gICAgICAgIFMzQnVja2V0OiByZXNvdXJjZS5jb2RlLnMzQnVja2V0LFxuICAgICAgICBTM0tleTogcmVzb3VyY2UuY29kZS5zM0tleSxcbiAgICAgICAgSW1hZ2VVcmk6IHJlc291cmNlLmNvZGUuaW1hZ2VVcmksXG4gICAgICAgIFppcEZpbGU6IHJlc291cmNlLmNvZGUuZnVuY3Rpb25Db2RlWmlwLFxuICAgICAgfSkucHJvbWlzZSgpO1xuXG4gICAgICBhd2FpdCB0aGlzLndhaXRGb3JMYW1iZGFzQ29kZVVwZGF0ZVRvRmluaXNoKHVwZGF0ZUZ1bmN0aW9uQ29kZVJlc3BvbnNlLCBsYW1iZGEpO1xuXG4gICAgICAvLyBvbmx5IGlmIHRoZSBjb2RlIGNoYW5nZWQgaXMgdGhlcmUgYW55IHBvaW50IGluIHB1Ymxpc2hpbmcgYSBuZXcgVmVyc2lvblxuICAgICAgaWYgKHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5wdWJsaXNoVmVyc2lvbikge1xuICAgICAgICBjb25zdCBwdWJsaXNoVmVyc2lvblByb21pc2UgPSBsYW1iZGEucHVibGlzaFZlcnNpb24oe1xuICAgICAgICAgIEZ1bmN0aW9uTmFtZTogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLnBoeXNpY2FsTmFtZSxcbiAgICAgICAgfSkucHJvbWlzZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmxhbWJkYUZ1bmN0aW9uUmVzb3VyY2UuYWxpYXNlc05hbWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAvLyB3ZSBuZWVkIHRvIHdhaXQgZm9yIHRoZSBWZXJzaW9uIHRvIGZpbmlzaCBwdWJsaXNoaW5nXG4gICAgICAgICAgY29uc3QgdmVyc2lvblVwZGF0ZSA9IGF3YWl0IHB1Ymxpc2hWZXJzaW9uUHJvbWlzZTtcblxuICAgICAgICAgIGZvciAoY29uc3QgYWxpYXMgb2YgdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLmFsaWFzZXNOYW1lcykge1xuICAgICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhbWJkYS51cGRhdGVBbGlhcyh7XG4gICAgICAgICAgICAgIEZ1bmN0aW9uTmFtZTogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLnBoeXNpY2FsTmFtZSxcbiAgICAgICAgICAgICAgTmFtZTogYWxpYXMsXG4gICAgICAgICAgICAgIEZ1bmN0aW9uVmVyc2lvbjogdmVyc2lvblVwZGF0ZS5WZXJzaW9uLFxuICAgICAgICAgICAgfSkucHJvbWlzZSgpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3BlcmF0aW9ucy5wdXNoKHB1Ymxpc2hWZXJzaW9uUHJvbWlzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmVzb3VyY2UudGFncyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCB0YWdzVG9EZWxldGU6IHN0cmluZ1tdID0gT2JqZWN0LmVudHJpZXMocmVzb3VyY2UudGFncy50YWdVcGRhdGVzKVxuICAgICAgICAuZmlsdGVyKChbX2tleSwgdmFsXSkgPT4gdmFsID09PSBUYWdEZWxldGlvbi5ERUxFVEUpXG4gICAgICAgIC5tYXAoKFtrZXksIF92YWxdKSA9PiBrZXkpO1xuXG4gICAgICBjb25zdCB0YWdzVG9TZXQ6IHsgW3RhZzogc3RyaW5nXTogc3RyaW5nIH0gPSB7fTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKHJlc291cmNlLnRhZ3MhLnRhZ1VwZGF0ZXMpXG4gICAgICAgIC5maWx0ZXIoKFtfa2V5LCB2YWxdKSA9PiB2YWwgIT09IFRhZ0RlbGV0aW9uLkRFTEVURSlcbiAgICAgICAgLmZvckVhY2goKFt0YWdOYW1lLCB0YWdWYWx1ZV0pID0+IHtcbiAgICAgICAgICB0YWdzVG9TZXRbdGFnTmFtZV0gPSB0YWdWYWx1ZSBhcyBzdHJpbmc7XG4gICAgICAgIH0pO1xuXG4gICAgICBpZiAodGFnc1RvRGVsZXRlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgb3BlcmF0aW9ucy5wdXNoKGxhbWJkYS51bnRhZ1Jlc291cmNlKHtcbiAgICAgICAgICBSZXNvdXJjZTogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLmZ1bmN0aW9uQXJuLFxuICAgICAgICAgIFRhZ0tleXM6IHRhZ3NUb0RlbGV0ZSxcbiAgICAgICAgfSkucHJvbWlzZSgpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHRhZ3NUb1NldCkubGVuZ3RoID4gMCkge1xuICAgICAgICBvcGVyYXRpb25zLnB1c2gobGFtYmRhLnRhZ1Jlc291cmNlKHtcbiAgICAgICAgICBSZXNvdXJjZTogdGhpcy5sYW1iZGFGdW5jdGlvblJlc291cmNlLmZ1bmN0aW9uQXJuLFxuICAgICAgICAgIFRhZ3M6IHRhZ3NUb1NldCxcbiAgICAgICAgfSkucHJvbWlzZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBydW4gYWxsIG9mIG91ciB1cGRhdGVzIGluIHBhcmFsbGVsXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKG9wZXJhdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFmdGVyIGEgTGFtYmRhIEZ1bmN0aW9uIGlzIHVwZGF0ZWQsIGl0IGNhbm5vdCBiZSB1cGRhdGVkIGFnYWluIHVudGlsIHRoZVxuICAgKiBgU3RhdGU9QWN0aXZlYCBhbmQgdGhlIGBMYXN0VXBkYXRlU3RhdHVzPVN1Y2Nlc3NmdWxgLlxuICAgKlxuICAgKiBEZXBlbmRpbmcgb24gdGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIExhbWJkYSBGdW5jdGlvbiB0aGlzIGNvdWxkIGhhcHBlbiByZWxhdGl2ZWx5IHF1aWNrbHlcbiAgICogb3IgdmVyeSBzbG93bHkuIEZvciBleGFtcGxlLCBaaXAgYmFzZWQgZnVuY3Rpb25zIF9ub3RfIGluIGEgVlBDIGNhbiB0YWtlIH4xIHNlY29uZCB3aGVyZWFzIFZQQ1xuICAgKiBvciBDb250YWluZXIgZnVuY3Rpb25zIGNhbiB0YWtlIH4yNSBzZWNvbmRzIChhbmQgJ2lkbGUnIFZQQyBmdW5jdGlvbnMgY2FuIHRha2UgbWludXRlcykuXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHdhaXRGb3JMYW1iZGFzQ29kZVVwZGF0ZVRvRmluaXNoKGN1cnJlbnRGdW5jdGlvbkNvbmZpZ3VyYXRpb246IEFXUy5MYW1iZGEuRnVuY3Rpb25Db25maWd1cmF0aW9uLCBsYW1iZGE6IEFXUy5MYW1iZGEpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBmdW5jdGlvbklzSW5WcGNPclVzZXNEb2NrZXJGb3JDb2RlID0gY3VycmVudEZ1bmN0aW9uQ29uZmlndXJhdGlvbi5WcGNDb25maWc/LlZwY0lkIHx8XG4gICAgICAgIGN1cnJlbnRGdW5jdGlvbkNvbmZpZ3VyYXRpb24uUGFja2FnZVR5cGUgPT09ICdJbWFnZSc7XG5cbiAgICAvLyBpZiB0aGUgZnVuY3Rpb24gaXMgZGVwbG95ZWQgaW4gYSBWUEMgb3IgaWYgaXQgaXMgYSBjb250YWluZXIgaW1hZ2UgZnVuY3Rpb25cbiAgICAvLyB0aGVuIHRoZSB1cGRhdGUgd2lsbCB0YWtlIG11Y2ggbG9uZ2VyIGFuZCB3ZSBjYW4gd2FpdCBsb25nZXIgYmV0d2VlbiBjaGVja3NcbiAgICAvLyBvdGhlcndpc2UsIHRoZSB1cGRhdGUgd2lsbCBiZSBxdWljaywgc28gYSAxLXNlY29uZCBkZWxheSBpcyBmaW5lXG4gICAgY29uc3QgZGVsYXlTZWNvbmRzID0gZnVuY3Rpb25Jc0luVnBjT3JVc2VzRG9ja2VyRm9yQ29kZSA/IDUgOiAxO1xuXG4gICAgLy8gY29uZmlndXJlIGEgY3VzdG9tIHdhaXRlciB0byB3YWl0IGZvciB0aGUgZnVuY3Rpb24gdXBkYXRlIHRvIGNvbXBsZXRlXG4gICAgKGxhbWJkYSBhcyBhbnkpLmFwaS53YWl0ZXJzLnVwZGF0ZUZ1bmN0aW9uQ29kZVRvRmluaXNoID0ge1xuICAgICAgbmFtZTogJ1VwZGF0ZUZ1bmN0aW9uQ29kZVRvRmluaXNoJyxcbiAgICAgIG9wZXJhdGlvbjogJ2dldEZ1bmN0aW9uJyxcbiAgICAgIC8vIGVxdWF0ZXMgdG8gMSBtaW51dGUgZm9yIHppcCBmdW5jdGlvbiBub3QgaW4gYSBWUEMgYW5kXG4gICAgICAvLyA1IG1pbnV0ZXMgZm9yIGNvbnRhaW5lciBmdW5jdGlvbnMgb3IgZnVuY3Rpb24gaW4gYSBWUENcbiAgICAgIG1heEF0dGVtcHRzOiA2MCxcbiAgICAgIGRlbGF5OiBkZWxheVNlY29uZHMsXG4gICAgICBhY2NlcHRvcnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIG1hdGNoZXI6ICdwYXRoJyxcbiAgICAgICAgICBhcmd1bWVudDogXCJDb25maWd1cmF0aW9uLkxhc3RVcGRhdGVTdGF0dXMgPT0gJ1N1Y2Nlc3NmdWwnICYmIENvbmZpZ3VyYXRpb24uU3RhdGUgPT0gJ0FjdGl2ZSdcIixcbiAgICAgICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgICAgICBzdGF0ZTogJ3N1Y2Nlc3MnLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgbWF0Y2hlcjogJ3BhdGgnLFxuICAgICAgICAgIGFyZ3VtZW50OiAnQ29uZmlndXJhdGlvbi5MYXN0VXBkYXRlU3RhdHVzJyxcbiAgICAgICAgICBleHBlY3RlZDogJ0ZhaWxlZCcsXG4gICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgfSxcbiAgICAgIF0sXG4gICAgfTtcblxuICAgIGNvbnN0IHVwZGF0ZUZ1bmN0aW9uQ29kZVdhaXRlciA9IG5ldyAoQVdTIGFzIGFueSkuUmVzb3VyY2VXYWl0ZXIobGFtYmRhLCAndXBkYXRlRnVuY3Rpb25Db2RlVG9GaW5pc2gnKTtcbiAgICBhd2FpdCB1cGRhdGVGdW5jdGlvbkNvZGVXYWl0ZXIud2FpdCh7XG4gICAgICBGdW5jdGlvbk5hbWU6IHRoaXMubGFtYmRhRnVuY3Rpb25SZXNvdXJjZS5waHlzaWNhbE5hbWUsXG4gICAgfSkucHJvbWlzZSgpO1xuICB9XG59XG5cbi8qKlxuICogQ29tcHJlc3MgYSBzdHJpbmcgYXMgYSBmaWxlLCByZXR1cm5pbmcgYSBwcm9taXNlIGZvciB0aGUgemlwIGJ1ZmZlclxuICogaHR0cHM6Ly9naXRodWIuY29tL2FyY2hpdmVyanMvbm9kZS1hcmNoaXZlci9pc3N1ZXMvMzQyXG4gKi9cbmZ1bmN0aW9uIHppcFN0cmluZyhmaWxlTmFtZTogc3RyaW5nLCByYXdTdHJpbmc6IHN0cmluZyk6IFByb21pc2U8QnVmZmVyPiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgY29uc3QgYnVmZmVyczogQnVmZmVyW10gPSBbXTtcblxuICAgIGNvbnN0IGNvbnZlcnRlciA9IG5ldyBXcml0YWJsZSgpO1xuXG4gICAgY29udmVydGVyLl93cml0ZSA9IChjaHVuazogQnVmZmVyLCBfOiBzdHJpbmcsIGNhbGxiYWNrOiAoKSA9PiB2b2lkKSA9PiB7XG4gICAgICBidWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFjayk7XG4gICAgfTtcblxuICAgIGNvbnZlcnRlci5vbignZmluaXNoJywgKCkgPT4ge1xuICAgICAgcmVzb2x2ZShCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpKTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGFyY2hpdmUgPSBhcmNoaXZlcignemlwJyk7XG5cbiAgICBhcmNoaXZlLm9uKCdlcnJvcicsIChlcnI6IGFueSkgPT4ge1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfSk7XG5cbiAgICBhcmNoaXZlLnBpcGUoY29udmVydGVyKTtcblxuICAgIGFyY2hpdmUuYXBwZW5kKHJhd1N0cmluZywge1xuICAgICAgbmFtZTogZmlsZU5hbWUsXG4gICAgICBkYXRlOiBuZXcgRGF0ZSgnMTk4MC0wMS0wMVQwMDowMDowMC4wMDBaJyksIC8vIEFkZCBkYXRlIHRvIG1ha2UgcmVzdWx0aW5nIHppcCBmaWxlIGRldGVybWluaXN0aWNcbiAgICB9KTtcblxuICAgIHZvaWQgYXJjaGl2ZS5maW5hbGl6ZSgpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgZmlsZSBleHRlbnNpb24gZnJvbSBMYW1iZGEgcnVudGltZSBzdHJpbmcuXG4gKiBXZSB1c2UgdGhpcyBleHRlbnNpb24gdG8gY3JlYXRlIGEgZGVwbG95bWVudCBwYWNrYWdlIGZyb20gTGFtYmRhIGlubGluZSBjb2RlLlxuICovXG5mdW5jdGlvbiBkZXRlcm1pbmVDb2RlRmlsZUV4dEZyb21SdW50aW1lKHJ1bnRpbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmIChydW50aW1lLnN0YXJ0c1dpdGgoJ25vZGUnKSkge1xuICAgIHJldHVybiAnanMnO1xuICB9XG4gIGlmIChydW50aW1lLnN0YXJ0c1dpdGgoJ3B5dGhvbicpKSB7XG4gICAgcmV0dXJuICdweSc7XG4gIH1cbiAgLy8gQ3VycmVudGx5IGlubGluZSBjb2RlIG9ubHkgc3VwcG9ydHMgTm9kZS5qcyBhbmQgUHl0aG9uLCBpZ25vcmluZyBvdGhlciBydW50aW1lcy5cbiAgLy8gaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0Nsb3VkRm9ybWF0aW9uL2xhdGVzdC9Vc2VyR3VpZGUvYXdzLXByb3BlcnRpZXMtbGFtYmRhLWZ1bmN0aW9uLWNvZGUuaHRtbCNhd3MtcHJvcGVydGllcy1sYW1iZGEtZnVuY3Rpb24tY29kZS1wcm9wZXJ0aWVzXG4gIHRocm93IG5ldyBDZm5FdmFsdWF0aW9uRXhjZXB0aW9uKGBydW50aW1lICR7cnVudGltZX0gaXMgdW5zdXBwb3J0ZWQsIG9ubHkgbm9kZS5qcyBhbmQgcHl0aG9uIHJ1bnRpbWVzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkLmApO1xufVxuIl19