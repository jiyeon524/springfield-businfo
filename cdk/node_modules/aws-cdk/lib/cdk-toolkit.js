"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CdkToolkit = void 0;
const path = require("path");
const util_1 = require("util");
const chalk = require("chalk");
const chokidar = require("chokidar");
const fs = require("fs-extra");
const promptly = require("promptly");
const environments_1 = require("../lib/api/cxapp/environments");
const cloud_assembly_1 = require("./api/cxapp/cloud-assembly");
const find_cloudwatch_logs_1 = require("./api/logs/find-cloudwatch-logs");
const logs_monitor_1 = require("./api/logs/logs-monitor");
const diff_1 = require("./diff");
const logging_1 = require("./logging");
const serialize_1 = require("./serialize");
const settings_1 = require("./settings");
const util_2 = require("./util");
/**
 * Toolkit logic
 *
 * The toolkit runs the `cloudExecutable` to obtain a cloud assembly and
 * deploys applies them to `cloudFormation`.
 */
class CdkToolkit {
    constructor(props) {
        this.props = props;
    }
    async metadata(stackName, json) {
        var _a;
        const stacks = await this.selectSingleStackByName(stackName);
        logging_1.data(serialize_1.serializeStructure((_a = stacks.firstStack.manifest.metadata) !== null && _a !== void 0 ? _a : {}, json));
    }
    async acknowledge(noticeId) {
        var _a;
        const acks = (_a = this.props.configuration.context.get('acknowledged-issue-numbers')) !== null && _a !== void 0 ? _a : [];
        acks.push(Number(noticeId));
        this.props.configuration.context.set('acknowledged-issue-numbers', acks);
        await this.props.configuration.saveContext();
    }
    async diff(options) {
        const stacks = await this.selectStacksForDiff(options.stackNames, options.exclusively);
        const strict = !!options.strict;
        const contextLines = options.contextLines || 3;
        const stream = options.stream || process.stderr;
        let diffs = 0;
        if (options.templatePath !== undefined) {
            // Compare single stack against fixed template
            if (stacks.stackCount !== 1) {
                throw new Error('Can only select one stack when comparing to fixed template. Use --exclusively to avoid selecting multiple stacks.');
            }
            if (!await fs.pathExists(options.templatePath)) {
                throw new Error(`There is no file at ${options.templatePath}`);
            }
            const template = serialize_1.deserializeStructure(await fs.readFile(options.templatePath, { encoding: 'UTF-8' }));
            diffs = options.securityOnly
                ? util_2.numberFromBool(diff_1.printSecurityDiff(template, stacks.firstStack, diff_1.RequireApproval.Broadening))
                : diff_1.printStackDiff(template, stacks.firstStack, strict, contextLines, stream);
        }
        else {
            // Compare N stacks against deployed templates
            for (const stack of stacks.stackArtifacts) {
                stream.write(util_1.format('Stack %s\n', chalk.bold(stack.displayName)));
                const currentTemplate = await this.props.cloudFormation.readCurrentTemplateWithNestedStacks(stack);
                diffs += options.securityOnly
                    ? util_2.numberFromBool(diff_1.printSecurityDiff(currentTemplate, stack, diff_1.RequireApproval.Broadening))
                    : diff_1.printStackDiff(currentTemplate, stack, strict, contextLines, stream);
            }
        }
        return diffs && options.fail ? 1 : 0;
    }
    async deploy(options) {
        var _a;
        if (options.watch) {
            return this.watch(options);
        }
        const startSynthTime = new Date().getTime();
        const stacks = await this.selectStacksForDeploy(options.selector, options.exclusively, options.cacheCloudAssembly);
        const elapsedSynthTime = new Date().getTime() - startSynthTime;
        logging_1.print('\n✨  Synthesis time: %ss\n', formatTime(elapsedSynthTime));
        const requireApproval = (_a = options.requireApproval) !== null && _a !== void 0 ? _a : diff_1.RequireApproval.Broadening;
        const parameterMap = { '*': {} };
        for (const key in options.parameters) {
            if (options.parameters.hasOwnProperty(key)) {
                const [stack, parameter] = key.split(':', 2);
                if (!parameter) {
                    parameterMap['*'][stack] = options.parameters[key];
                }
                else {
                    if (!parameterMap[stack]) {
                        parameterMap[stack] = {};
                    }
                    parameterMap[stack][parameter] = options.parameters[key];
                }
            }
        }
        if (options.hotswap) {
            logging_1.warning('⚠️ The --hotswap flag deliberately introduces CloudFormation drift to speed up deployments');
            logging_1.warning('⚠️ It should only be used for development - never use it for your production Stacks!');
        }
        const stackOutputs = {};
        const outputsFile = options.outputsFile;
        for (const stack of stacks.stackArtifacts) {
            if (stacks.stackCount !== 1) {
                logging_1.highlight(stack.displayName);
            }
            if (!stack.environment) {
                // eslint-disable-next-line max-len
                throw new Error(`Stack ${stack.displayName} does not define an environment, and AWS credentials could not be obtained from standard locations or no region was configured.`);
            }
            if (Object.keys(stack.template.Resources || {}).length === 0) { // The generated stack has no resources
                if (!await this.props.cloudFormation.stackExists({ stack })) {
                    logging_1.warning('%s: stack has no resources, skipping deployment.', chalk.bold(stack.displayName));
                }
                else {
                    logging_1.warning('%s: stack has no resources, deleting existing stack.', chalk.bold(stack.displayName));
                    await this.destroy({
                        selector: { patterns: [stack.stackName] },
                        exclusively: true,
                        force: true,
                        roleArn: options.roleArn,
                        fromDeploy: true,
                    });
                }
                continue;
            }
            if (requireApproval !== diff_1.RequireApproval.Never) {
                const currentTemplate = await this.props.cloudFormation.readCurrentTemplate(stack);
                if (diff_1.printSecurityDiff(currentTemplate, stack, requireApproval)) {
                    // only talk to user if STDIN is a terminal (otherwise, fail)
                    if (!process.stdin.isTTY) {
                        throw new Error('"--require-approval" is enabled and stack includes security-sensitive updates, ' +
                            'but terminal (TTY) is not attached so we are unable to get a confirmation from the user');
                    }
                    const confirmed = await promptly.confirm('Do you wish to deploy these changes (y/n)?');
                    if (!confirmed) {
                        throw new Error('Aborted by user');
                    }
                }
            }
            logging_1.print('%s: deploying...', chalk.bold(stack.displayName));
            const startDeployTime = new Date().getTime();
            let tags = options.tags;
            if (!tags || tags.length === 0) {
                tags = tagsForStack(stack);
            }
            let elapsedDeployTime = 0;
            try {
                const result = await this.props.cloudFormation.deployStack({
                    stack,
                    deployName: stack.stackName,
                    roleArn: options.roleArn,
                    toolkitStackName: options.toolkitStackName,
                    reuseAssets: options.reuseAssets,
                    notificationArns: options.notificationArns,
                    tags,
                    execute: options.execute,
                    changeSetName: options.changeSetName,
                    force: options.force,
                    parameters: Object.assign({}, parameterMap['*'], parameterMap[stack.stackName]),
                    usePreviousParameters: options.usePreviousParameters,
                    progress: options.progress,
                    ci: options.ci,
                    rollback: options.rollback,
                    hotswap: options.hotswap,
                    extraUserAgent: options.extraUserAgent,
                });
                const message = result.noOp
                    ? ' ✅  %s (no changes)'
                    : ' ✅  %s';
                logging_1.success('\n' + message, stack.displayName);
                elapsedDeployTime = new Date().getTime() - startDeployTime;
                logging_1.print('\n✨  Deployment time: %ss\n', formatTime(elapsedDeployTime));
                if (Object.keys(result.outputs).length > 0) {
                    logging_1.print('Outputs:');
                    stackOutputs[stack.stackName] = result.outputs;
                }
                for (const name of Object.keys(result.outputs).sort()) {
                    const value = result.outputs[name];
                    logging_1.print('%s.%s = %s', chalk.cyan(stack.id), chalk.cyan(name), chalk.underline(chalk.cyan(value)));
                }
                logging_1.print('Stack ARN:');
                logging_1.data(result.stackArn);
            }
            catch (e) {
                logging_1.error('\n ❌  %s failed: %s', chalk.bold(stack.displayName), e);
                throw e;
            }
            finally {
                if (options.cloudWatchLogMonitor) {
                    const foundLogGroupsResult = await find_cloudwatch_logs_1.findCloudWatchLogGroups(this.props.sdkProvider, stack);
                    options.cloudWatchLogMonitor.addLogGroups(foundLogGroupsResult.env, foundLogGroupsResult.sdk, foundLogGroupsResult.logGroupNames);
                }
                // If an outputs file has been specified, create the file path and write stack outputs to it once.
                // Outputs are written after all stacks have been deployed. If a stack deployment fails,
                // all of the outputs from successfully deployed stacks before the failure will still be written.
                if (outputsFile) {
                    fs.ensureFileSync(outputsFile);
                    await fs.writeJson(outputsFile, stackOutputs, {
                        spaces: 2,
                        encoding: 'utf8',
                    });
                }
            }
            logging_1.print('\n✨  Total time: %ss\n', formatTime(elapsedSynthTime + elapsedDeployTime));
        }
    }
    async watch(options) {
        const rootDir = path.dirname(path.resolve(settings_1.PROJECT_CONFIG));
        logging_1.debug("root directory used for 'watch' is: %s", rootDir);
        const watchSettings = this.props.configuration.settings.get(['watch']);
        if (!watchSettings) {
            throw new Error("Cannot use the 'watch' command without specifying at least one directory to monitor. " +
                'Make sure to add a "watch" key to your cdk.json');
        }
        // For the "include" subkey under the "watch" key, the behavior is:
        // 1. No "watch" setting? We error out.
        // 2. "watch" setting without an "include" key? We default to observing "./**".
        // 3. "watch" setting with an empty "include" key? We default to observing "./**".
        // 4. Non-empty "include" key? Just use the "include" key.
        const watchIncludes = this.patternsArrayForWatch(watchSettings.include, { rootDir, returnRootDirIfEmpty: true });
        logging_1.debug("'include' patterns for 'watch': %s", watchIncludes);
        // For the "exclude" subkey under the "watch" key,
        // the behavior is to add some default excludes in addition to the ones specified by the user:
        // 1. The CDK output directory.
        // 2. Any file whose name starts with a dot.
        // 3. Any directory's content whose name starts with a dot.
        // 4. Any node_modules and its content (even if it's not a JS/TS project, you might be using a local aws-cli package)
        const outputDir = this.props.configuration.settings.get(['output']);
        const watchExcludes = this.patternsArrayForWatch(watchSettings.exclude, { rootDir, returnRootDirIfEmpty: false }).concat(`${outputDir}/**`, '**/.*', '**/.*/**', '**/node_modules/**');
        logging_1.debug("'exclude' patterns for 'watch': %s", watchExcludes);
        // Since 'cdk deploy' is a relatively slow operation for a 'watch' process,
        // introduce a concurrency latch that tracks the state.
        // This way, if file change events arrive when a 'cdk deploy' is still executing,
        // we will batch them, and trigger another 'cdk deploy' after the current one finishes,
        // making sure 'cdk deploy's  always execute one at a time.
        // Here's a diagram showing the state transitions:
        // --------------                --------    file changed     --------------    file changed     --------------  file changed
        // |            |  ready event   |      | ------------------> |            | ------------------> |            | --------------|
        // | pre-ready  | -------------> | open |                     | deploying  |                     |   queued   |               |
        // |            |                |      | <------------------ |            | <------------------ |            | <-------------|
        // --------------                --------  'cdk deploy' done  --------------  'cdk deploy' done  --------------
        let latch = 'pre-ready';
        const cloudWatchLogMonitor = options.traceLogs ? new logs_monitor_1.CloudWatchLogEventMonitor() : undefined;
        const deployAndWatch = async () => {
            latch = 'deploying';
            cloudWatchLogMonitor === null || cloudWatchLogMonitor === void 0 ? void 0 : cloudWatchLogMonitor.deactivate();
            await this.invokeDeployFromWatch(options, cloudWatchLogMonitor);
            // If latch is still 'deploying' after the 'await', that's fine,
            // but if it's 'queued', that means we need to deploy again
            while (latch === 'queued') {
                // TypeScript doesn't realize latch can change between 'awaits',
                // and thinks the above 'while' condition is always 'false' without the cast
                latch = 'deploying';
                logging_1.print("Detected file changes during deployment. Invoking 'cdk deploy' again");
                await this.invokeDeployFromWatch(options, cloudWatchLogMonitor);
            }
            latch = 'open';
            cloudWatchLogMonitor === null || cloudWatchLogMonitor === void 0 ? void 0 : cloudWatchLogMonitor.activate();
        };
        chokidar.watch(watchIncludes, {
            ignored: watchExcludes,
            cwd: rootDir,
        }).on('ready', async () => {
            latch = 'open';
            logging_1.debug("'watch' received the 'ready' event. From now on, all file changes will trigger a deployment");
            logging_1.print("Triggering initial 'cdk deploy'");
            await deployAndWatch();
        }).on('all', async (event, filePath) => {
            if (latch === 'pre-ready') {
                logging_1.print(`'watch' is observing ${event === 'addDir' ? 'directory' : 'the file'} '%s' for changes`, filePath);
            }
            else if (latch === 'open') {
                logging_1.print("Detected change to '%s' (type: %s). Triggering 'cdk deploy'", filePath, event);
                await deployAndWatch();
            }
            else { // this means latch is either 'deploying' or 'queued'
                latch = 'queued';
                logging_1.print("Detected change to '%s' (type: %s) while 'cdk deploy' is still running. " +
                    'Will queue for another deployment after this one finishes', filePath, event);
            }
        });
    }
    async destroy(options) {
        let stacks = await this.selectStacksForDestroy(options.selector, options.exclusively);
        // The stacks will have been ordered for deployment, so reverse them for deletion.
        stacks = stacks.reversed();
        if (!options.force) {
            // eslint-disable-next-line max-len
            const confirmed = await promptly.confirm(`Are you sure you want to delete: ${chalk.blue(stacks.stackArtifacts.map(s => s.hierarchicalId).join(', '))} (y/n)?`);
            if (!confirmed) {
                return;
            }
        }
        const action = options.fromDeploy ? 'deploy' : 'destroy';
        for (const stack of stacks.stackArtifacts) {
            logging_1.success('%s: destroying...', chalk.blue(stack.displayName));
            try {
                await this.props.cloudFormation.destroyStack({
                    stack,
                    deployName: stack.stackName,
                    roleArn: options.roleArn,
                });
                logging_1.success(`\n ✅  %s: ${action}ed`, chalk.blue(stack.displayName));
            }
            catch (e) {
                logging_1.error(`\n ❌  %s: ${action} failed`, chalk.blue(stack.displayName), e);
                throw e;
            }
        }
    }
    async list(selectors, options = {}) {
        var _a;
        const stacks = await this.selectStacksForList(selectors);
        // if we are in "long" mode, emit the array as-is (JSON/YAML)
        if (options.long) {
            const long = [];
            for (const stack of stacks.stackArtifacts) {
                long.push({
                    id: stack.hierarchicalId,
                    name: stack.stackName,
                    environment: stack.environment,
                });
            }
            logging_1.data(serialize_1.serializeStructure(long, (_a = options.json) !== null && _a !== void 0 ? _a : false));
            return 0;
        }
        // just print stack IDs
        for (const stack of stacks.stackArtifacts) {
            logging_1.data(stack.hierarchicalId);
        }
        return 0; // exit-code
    }
    /**
     * Synthesize the given set of stacks (called when the user runs 'cdk synth')
     *
     * INPUT: Stack names can be supplied using a glob filter. If no stacks are
     * given, all stacks from the application are implictly selected.
     *
     * OUTPUT: If more than one stack ends up being selected, an output directory
     * should be supplied, where the templates will be written.
     */
    async synth(stackNames, exclusively, quiet, autoValidate, json) {
        const stacks = await this.selectStacksForDiff(stackNames, exclusively, autoValidate);
        // if we have a single stack, print it to STDOUT
        if (stacks.stackCount === 1) {
            if (!quiet) {
                logging_1.data(serialize_1.serializeStructure(stacks.firstStack.template, json !== null && json !== void 0 ? json : false));
            }
            return undefined;
        }
        // This is a slight hack; in integ mode we allow multiple stacks to be synthesized to stdout sequentially.
        // This is to make it so that we can support multi-stack integ test expectations, without so drastically
        // having to change the synthesis format that we have to rerun all integ tests.
        //
        // Because this feature is not useful to consumers (the output is missing
        // the stack names), it's not exposed as a CLI flag. Instead, it's hidden
        // behind an environment variable.
        const isIntegMode = process.env.CDK_INTEG_MODE === '1';
        if (isIntegMode) {
            logging_1.data(serialize_1.serializeStructure(stacks.stackArtifacts.map(s => s.template), json !== null && json !== void 0 ? json : false));
        }
        // not outputting template to stdout, let's explain things to the user a little bit...
        logging_1.success(`Successfully synthesized to ${chalk.blue(path.resolve(stacks.assembly.directory))}`);
        logging_1.print(`Supply a stack id (${stacks.stackArtifacts.map(s => chalk.green(s.hierarchicalId)).join(', ')}) to display its template.`);
        return undefined;
    }
    /**
     * Bootstrap the CDK Toolkit stack in the accounts used by the specified stack(s).
     *
     * @param environmentSpecs environment names that need to have toolkit support
     *             provisioned, as a glob filter. If none is provided,
     *             all stacks are implicitly selected.
     * @param toolkitStackName the name to be used for the CDK Toolkit stack.
     */
    async bootstrap(userEnvironmentSpecs, bootstrapper, options) {
        // If there is an '--app' argument and an environment looks like a glob, we
        // select the environments from the app. Otherwise use what the user said.
        // By default glob for everything
        const environmentSpecs = userEnvironmentSpecs.length > 0 ? [...userEnvironmentSpecs] : ['**'];
        // Partition into globs and non-globs (this will mutate environmentSpecs).
        const globSpecs = util_2.partition(environmentSpecs, environments_1.looksLikeGlob);
        if (globSpecs.length > 0 && !this.props.cloudExecutable.hasApp) {
            if (userEnvironmentSpecs.length > 0) {
                // User did request this glob
                throw new Error(`'${globSpecs}' is not an environment name. Specify an environment name like 'aws://123456789012/us-east-1', or run in a directory with 'cdk.json' to use wildcards.`);
            }
            else {
                // User did not request anything
                throw new Error('Specify an environment name like \'aws://123456789012/us-east-1\', or run in a directory with \'cdk.json\'.');
            }
        }
        const environments = [
            ...environments_1.environmentsFromDescriptors(environmentSpecs),
        ];
        // If there is an '--app' argument, select the environments from the app.
        if (this.props.cloudExecutable.hasApp) {
            environments.push(...await environments_1.globEnvironmentsFromStacks(await this.selectStacksForList([]), globSpecs, this.props.sdkProvider));
        }
        await Promise.all(environments.map(async (environment) => {
            logging_1.success(' ⏳  Bootstrapping environment %s...', chalk.blue(environment.name));
            try {
                const result = await bootstrapper.bootstrapEnvironment(environment, this.props.sdkProvider, options);
                const message = result.noOp
                    ? ' ✅  Environment %s bootstrapped (no changes).'
                    : ' ✅  Environment %s bootstrapped.';
                logging_1.success(message, chalk.blue(environment.name));
            }
            catch (e) {
                logging_1.error(' ❌  Environment %s failed bootstrapping: %s', chalk.blue(environment.name), e);
                throw e;
            }
        }));
    }
    async selectStacksForList(patterns) {
        const assembly = await this.assembly();
        const stacks = await assembly.selectStacks({ patterns }, { defaultBehavior: cloud_assembly_1.DefaultSelection.AllStacks });
        // No validation
        return stacks;
    }
    async selectStacksForDeploy(selector, exclusively, cacheCloudAssembly) {
        const assembly = await this.assembly(cacheCloudAssembly);
        const stacks = await assembly.selectStacks(selector, {
            extend: exclusively ? cloud_assembly_1.ExtendedStackSelection.None : cloud_assembly_1.ExtendedStackSelection.Upstream,
            defaultBehavior: cloud_assembly_1.DefaultSelection.OnlySingle,
        });
        this.validateStacksSelected(stacks, selector.patterns);
        this.validateStacks(stacks);
        return stacks;
    }
    async selectStacksForDiff(stackNames, exclusively, autoValidate) {
        const assembly = await this.assembly();
        const selectedForDiff = await assembly.selectStacks({ patterns: stackNames }, {
            extend: exclusively ? cloud_assembly_1.ExtendedStackSelection.None : cloud_assembly_1.ExtendedStackSelection.Upstream,
            defaultBehavior: cloud_assembly_1.DefaultSelection.MainAssembly,
        });
        const allStacks = await this.selectStacksForList([]);
        const autoValidateStacks = autoValidate
            ? allStacks.filter(art => { var _a; return (_a = art.validateOnSynth) !== null && _a !== void 0 ? _a : false; })
            : new cloud_assembly_1.StackCollection(assembly, []);
        this.validateStacksSelected(selectedForDiff.concat(autoValidateStacks), stackNames);
        this.validateStacks(selectedForDiff.concat(autoValidateStacks));
        return selectedForDiff;
    }
    async selectStacksForDestroy(selector, exclusively) {
        const assembly = await this.assembly();
        const stacks = await assembly.selectStacks(selector, {
            extend: exclusively ? cloud_assembly_1.ExtendedStackSelection.None : cloud_assembly_1.ExtendedStackSelection.Downstream,
            defaultBehavior: cloud_assembly_1.DefaultSelection.OnlySingle,
        });
        // No validation
        return stacks;
    }
    /**
     * Validate the stacks for errors and warnings according to the CLI's current settings
     */
    validateStacks(stacks) {
        stacks.processMetadataMessages({
            ignoreErrors: this.props.ignoreErrors,
            strict: this.props.strict,
            verbose: this.props.verbose,
        });
    }
    /**
     * Validate that if a user specified a stack name there exists at least 1 stack selected
     */
    validateStacksSelected(stacks, stackNames) {
        if (stackNames.length != 0 && stacks.stackCount == 0) {
            throw new Error(`No stacks match the name(s) ${stackNames}`);
        }
    }
    /**
     * Select a single stack by its name
     */
    async selectSingleStackByName(stackName) {
        const assembly = await this.assembly();
        const stacks = await assembly.selectStacks({ patterns: [stackName] }, {
            extend: cloud_assembly_1.ExtendedStackSelection.None,
            defaultBehavior: cloud_assembly_1.DefaultSelection.None,
        });
        // Could have been a glob so check that we evaluated to exactly one
        if (stacks.stackCount > 1) {
            throw new Error(`This command requires exactly one stack and we matched more than one: ${stacks.stackIds}`);
        }
        return assembly.stackById(stacks.firstStack.id);
    }
    assembly(cacheCloudAssembly) {
        return this.props.cloudExecutable.synthesize(cacheCloudAssembly);
    }
    patternsArrayForWatch(patterns, options) {
        const patternsArray = patterns !== undefined
            ? (Array.isArray(patterns) ? patterns : [patterns])
            : [];
        return patternsArray.length > 0
            ? patternsArray
            : (options.returnRootDirIfEmpty ? [options.rootDir] : []);
    }
    async invokeDeployFromWatch(options, cloudWatchLogMonitor) {
        // 'watch' has different defaults than regular 'deploy'
        const hotswap = options.hotswap === undefined ? true : options.hotswap;
        const deployOptions = {
            ...options,
            requireApproval: diff_1.RequireApproval.Never,
            // if 'watch' is called by invoking 'cdk deploy --watch',
            // we need to make sure to not call 'deploy' with 'watch' again,
            // as that would lead to a cycle
            watch: false,
            cloudWatchLogMonitor,
            cacheCloudAssembly: false,
            hotswap: hotswap,
            extraUserAgent: `cdk-watch/hotswap-${hotswap ? 'on' : 'off'}`,
        };
        try {
            await this.deploy(deployOptions);
        }
        catch (e) {
            // just continue - deploy will show the error
        }
    }
}
exports.CdkToolkit = CdkToolkit;
/**
 * @returns an array with the tags available in the stack metadata.
 */
function tagsForStack(stack) {
    return Object.entries(stack.tags).map(([Key, Value]) => ({ Key, Value }));
}
/**
 * Formats time in milliseconds (which we get from 'Date.getTime()')
 * to a human-readable time; returns time in seconds rounded to 2
 * decimal places.
 */
function formatTime(num) {
    return roundPercentage(millisecondsToSeconds(num));
}
/**
 * Rounds a decimal number to two decimal points.
 * The function is useful for fractions that need to be outputted as percentages.
 */
function roundPercentage(num) {
    return Math.round(100 * num) / 100;
}
/**
 * Given a time in miliseconds, return an equivalent amount in seconds.
 */
function millisecondsToSeconds(num) {
    return num / 1000;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2RrLXRvb2xraXQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjZGstdG9vbGtpdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSw2QkFBNkI7QUFDN0IsK0JBQThCO0FBRTlCLCtCQUErQjtBQUMvQixxQ0FBcUM7QUFDckMsK0JBQStCO0FBQy9CLHFDQUFxQztBQUNyQyxnRUFBdUg7QUFJdkgsK0RBQXFJO0FBRXJJLDBFQUEwRTtBQUMxRSwwREFBb0U7QUFFcEUsaUNBQTRFO0FBQzVFLHVDQUFtRjtBQUNuRiwyQ0FBdUU7QUFDdkUseUNBQTJEO0FBQzNELGlDQUFtRDtBQThDbkQ7Ozs7O0dBS0c7QUFDSCxNQUFhLFVBQVU7SUFDckIsWUFBNkIsS0FBc0I7UUFBdEIsVUFBSyxHQUFMLEtBQUssQ0FBaUI7SUFDbkQsQ0FBQztJQUVNLEtBQUssQ0FBQyxRQUFRLENBQUMsU0FBaUIsRUFBRSxJQUFhOztRQUNwRCxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyx1QkFBdUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUM3RCxjQUFJLENBQUMsOEJBQWtCLE9BQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxRQUFRLENBQUMsUUFBUSxtQ0FBSSxFQUFFLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUM1RSxDQUFDO0lBRU0sS0FBSyxDQUFDLFdBQVcsQ0FBQyxRQUFnQjs7UUFDdkMsTUFBTSxJQUFJLFNBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyw0QkFBNEIsQ0FBQyxtQ0FBSSxFQUFFLENBQUM7UUFDdEYsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQztRQUM1QixJQUFJLENBQUMsS0FBSyxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLDRCQUE0QixFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ3pFLE1BQU0sSUFBSSxDQUFDLEtBQUss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VSxDQUFDLEdBQVc7SUFDN0IsT0FBTyxlQUFlLENBQUMscUJBQXFCLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztBQUNyRCxDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsU0FBUyxlQUFlLENBQUMsR0FBVztJQUNsQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsR0FBRyxHQUFHLEdBQUcsQ0FBQyxHQUFHLEdBQUcsQ0FBQztBQUNyQyxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLHFCQUFxQixDQUFDLEdBQVc7SUFDeEMsT0FBTyxHQUFHLEdBQUcsSUFBSSxDQUFDO0FBQ3BCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAndXRpbCc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY2hhbGsgZnJvbSAnY2hhbGsnO1xuaW1wb3J0ICogYXMgY2hva2lkYXIgZnJvbSAnY2hva2lkYXInO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMtZXh0cmEnO1xuaW1wb3J0ICogYXMgcHJvbXB0bHkgZnJvbSAncHJvbXB0bHknO1xuaW1wb3J0IHsgZW52aXJvbm1lbnRzRnJvbURlc2NyaXB0b3JzLCBnbG9iRW52aXJvbm1lbnRzRnJvbVN0YWNrcywgbG9va3NMaWtlR2xvYiB9IGZyb20gJy4uL2xpYi9hcGkvY3hhcHAvZW52aXJvbm1lbnRzJztcbmltcG9ydCB7IFNka1Byb3ZpZGVyIH0gZnJvbSAnLi9hcGkvYXdzLWF1dGgnO1xuaW1wb3J0IHsgQm9vdHN0cmFwcGVyLCBCb290c3RyYXBFbnZpcm9ubWVudE9wdGlvbnMgfSBmcm9tICcuL2FwaS9ib290c3RyYXAnO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25EZXBsb3ltZW50cyB9IGZyb20gJy4vYXBpL2Nsb3VkZm9ybWF0aW9uLWRlcGxveW1lbnRzJztcbmltcG9ydCB7IENsb3VkQXNzZW1ibHksIERlZmF1bHRTZWxlY3Rpb24sIEV4dGVuZGVkU3RhY2tTZWxlY3Rpb24sIFN0YWNrQ29sbGVjdGlvbiwgU3RhY2tTZWxlY3RvciB9IGZyb20gJy4vYXBpL2N4YXBwL2Nsb3VkLWFzc2VtYmx5JztcbmltcG9ydCB7IENsb3VkRXhlY3V0YWJsZSB9IGZyb20gJy4vYXBpL2N4YXBwL2Nsb3VkLWV4ZWN1dGFibGUnO1xuaW1wb3J0IHsgZmluZENsb3VkV2F0Y2hMb2dHcm91cHMgfSBmcm9tICcuL2FwaS9sb2dzL2ZpbmQtY2xvdWR3YXRjaC1sb2dzJztcbmltcG9ydCB7IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IgfSBmcm9tICcuL2FwaS9sb2dzL2xvZ3MtbW9uaXRvcic7XG5pbXBvcnQgeyBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MgfSBmcm9tICcuL2FwaS91dGlsL2Nsb3VkZm9ybWF0aW9uL3N0YWNrLWFjdGl2aXR5LW1vbml0b3InO1xuaW1wb3J0IHsgcHJpbnRTZWN1cml0eURpZmYsIHByaW50U3RhY2tEaWZmLCBSZXF1aXJlQXBwcm92YWwgfSBmcm9tICcuL2RpZmYnO1xuaW1wb3J0IHsgZGF0YSwgZGVidWcsIGVycm9yLCBoaWdobGlnaHQsIHByaW50LCBzdWNjZXNzLCB3YXJuaW5nIH0gZnJvbSAnLi9sb2dnaW5nJztcbmltcG9ydCB7IGRlc2VyaWFsaXplU3RydWN0dXJlLCBzZXJpYWxpemVTdHJ1Y3R1cmUgfSBmcm9tICcuL3NlcmlhbGl6ZSc7XG5pbXBvcnQgeyBDb25maWd1cmF0aW9uLCBQUk9KRUNUX0NPTkZJRyB9IGZyb20gJy4vc2V0dGluZ3MnO1xuaW1wb3J0IHsgbnVtYmVyRnJvbUJvb2wsIHBhcnRpdGlvbiB9IGZyb20gJy4vdXRpbCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2RrVG9vbGtpdFByb3BzIHtcblxuICAvKipcbiAgICogVGhlIENsb3VkIEV4ZWN1dGFibGVcbiAgICovXG4gIGNsb3VkRXhlY3V0YWJsZTogQ2xvdWRFeGVjdXRhYmxlO1xuXG4gIC8qKlxuICAgKiBUaGUgcHJvdmlzaW9uaW5nIGVuZ2luZSB1c2VkIHRvIGFwcGx5IGNoYW5nZXMgdG8gdGhlIGNsb3VkXG4gICAqL1xuICBjbG91ZEZvcm1hdGlvbjogQ2xvdWRGb3JtYXRpb25EZXBsb3ltZW50cztcblxuICAvKipcbiAgICogV2hldGhlciB0byBiZSB2ZXJib3NlXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB2ZXJib3NlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRG9uJ3Qgc3RvcCBvbiBlcnJvciBtZXRhZGF0YVxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgaWdub3JlRXJyb3JzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogVHJlYXQgd2FybmluZ3MgaW4gbWV0YWRhdGEgYXMgZXJyb3JzXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzdHJpY3Q/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBcHBsaWNhdGlvbiBjb25maWd1cmF0aW9uIChzZXR0aW5ncyBhbmQgY29udGV4dClcbiAgICovXG4gIGNvbmZpZ3VyYXRpb246IENvbmZpZ3VyYXRpb247XG5cbiAgLyoqXG4gICAqIEFXUyBvYmplY3QgKHVzZWQgYnkgc3ludGhlc2l6ZXIgYW5kIGNvbnRleHRwcm92aWRlcilcbiAgICovXG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcjtcbn1cblxuLyoqXG4gKiBUb29sa2l0IGxvZ2ljXG4gKlxuICogVGhlIHRvb2xraXQgcnVucyB0aGUgYGNsb3VkRXhlY3V0YWJsZWAgdG8gb2J0YWluIGEgY2xvdWQgYXNzZW1ibHkgYW5kXG4gKiBkZXBsb3lzIGFwcGxpZXMgdGhlbSB0byBgY2xvdWRGb3JtYXRpb25gLlxuICovXG5leHBvcnQgY2xhc3MgQ2RrVG9vbGtpdCB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IENka1Rvb2xraXRQcm9wcykge1xuICB9XG5cbiAgcHVibGljIGFzeW5jIG1ldGFkYXRhKHN0YWNrTmFtZTogc3RyaW5nLCBqc29uOiBib29sZWFuKSB7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgdGhpcy5zZWxlY3RTaW5nbGVTdGFja0J5TmFtZShzdGFja05hbWUpO1xuICAgIGRhdGEoc2VyaWFsaXplU3RydWN0dXJlKHN0YWNrcy5maXJzdFN0YWNrLm1hbmlmZXN0Lm1ldGFkYXRhID8/IHt9LCBqc29uKSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgYWNrbm93bGVkZ2Uobm90aWNlSWQ6IHN0cmluZykge1xuICAgIGNvbnN0IGFja3MgPSB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uY29udGV4dC5nZXQoJ2Fja25vd2xlZGdlZC1pc3N1ZS1udW1iZXJzJykgPz8gW107XG4gICAgYWNrcy5wdXNoKE51bWJlcihub3RpY2VJZCkpO1xuICAgIHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5jb250ZXh0LnNldCgnYWNrbm93bGVkZ2VkLWlzc3VlLW51bWJlcnMnLCBhY2tzKTtcbiAgICBhd2FpdCB0aGlzLnByb3BzLmNvbmZpZ3VyYXRpb24uc2F2ZUNvbnRleHQoKTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBkaWZmKG9wdGlvbnM6IERpZmZPcHRpb25zKTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCB0aGlzLnNlbGVjdFN0YWNrc0ZvckRpZmYob3B0aW9ucy5zdGFja05hbWVzLCBvcHRpb25zLmV4Y2x1c2l2ZWx5KTtcblxuICAgIGNvbnN0IHN0cmljdCA9ICEhb3B0aW9ucy5zdHJpY3Q7XG4gICAgY29uc3QgY29udGV4dExpbmVzID0gb3B0aW9ucy5jb250ZXh0TGluZXMgfHwgMztcbiAgICBjb25zdCBzdHJlYW0gPSBvcHRpb25zLnN0cmVhbSB8fCBwcm9jZXNzLnN0ZGVycjtcblxuICAgIGxldCBkaWZmcyA9IDA7XG4gICAgaWYgKG9wdGlvbnMudGVtcGxhdGVQYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIENvbXBhcmUgc2luZ2xlIHN0YWNrIGFnYWluc3QgZml4ZWQgdGVtcGxhdGVcbiAgICAgIGlmIChzdGFja3Muc3RhY2tDb3VudCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbiBvbmx5IHNlbGVjdCBvbmUgc3RhY2sgd2hlbiBjb21wYXJpbmcgdG8gZml4ZWQgdGVtcGxhdGUuIFVzZSAtLWV4Y2x1c2l2ZWx5IHRvIGF2b2lkIHNlbGVjdGluZyBtdWx0aXBsZSBzdGFja3MuJyk7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXdhaXQgZnMucGF0aEV4aXN0cyhvcHRpb25zLnRlbXBsYXRlUGF0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGVyZSBpcyBubyBmaWxlIGF0ICR7b3B0aW9ucy50ZW1wbGF0ZVBhdGh9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IGRlc2VyaWFsaXplU3RydWN0dXJlKGF3YWl0IGZzLnJlYWRGaWxlKG9wdGlvbnMudGVtcGxhdGVQYXRoLCB7IGVuY29kaW5nOiAnVVRGLTgnIH0pKTtcbiAgICAgIGRpZmZzID0gb3B0aW9ucy5zZWN1cml0eU9ubHlcbiAgICAgICAgPyBudW1iZXJGcm9tQm9vbChwcmludFNlY3VyaXR5RGlmZih0ZW1wbGF0ZSwgc3RhY2tzLmZpcnN0U3RhY2ssIFJlcXVpcmVBcHByb3ZhbC5Ccm9hZGVuaW5nKSlcbiAgICAgICAgOiBwcmludFN0YWNrRGlmZih0ZW1wbGF0ZSwgc3RhY2tzLmZpcnN0U3RhY2ssIHN0cmljdCwgY29udGV4dExpbmVzLCBzdHJlYW0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDb21wYXJlIE4gc3RhY2tzIGFnYWluc3QgZGVwbG95ZWQgdGVtcGxhdGVzXG4gICAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcy5zdGFja0FydGlmYWN0cykge1xuICAgICAgICBzdHJlYW0ud3JpdGUoZm9ybWF0KCdTdGFjayAlc1xcbicsIGNoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpKSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUZW1wbGF0ZSA9IGF3YWl0IHRoaXMucHJvcHMuY2xvdWRGb3JtYXRpb24ucmVhZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3Moc3RhY2spO1xuICAgICAgICBkaWZmcyArPSBvcHRpb25zLnNlY3VyaXR5T25seVxuICAgICAgICAgID8gbnVtYmVyRnJvbUJvb2wocHJpbnRTZWN1cml0eURpZmYoY3VycmVudFRlbXBsYXRlLCBzdGFjaywgUmVxdWlyZUFwcHJvdmFsLkJyb2FkZW5pbmcpKVxuICAgICAgICAgIDogcHJpbnRTdGFja0RpZmYoY3VycmVudFRlbXBsYXRlLCBzdGFjaywgc3RyaWN0LCBjb250ZXh0TGluZXMsIHN0cmVhbSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpZmZzICYmIG9wdGlvbnMuZmFpbCA/IDEgOiAwO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlcGxveShvcHRpb25zOiBEZXBsb3lPcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMud2F0Y2gpIHtcbiAgICAgIHJldHVybiB0aGlzLndhdGNoKG9wdGlvbnMpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0U3ludGhUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgdGhpcy5zZWxlY3RTdGFja3NGb3JEZXBsb3kob3B0aW9ucy5zZWxlY3Rvciwgb3B0aW9ucy5leGNsdXNpdmVseSwgb3B0aW9ucy5jYWNoZUNsb3VkQXNzZW1ibHkpO1xuICAgIGNvbnN0IGVsYXBzZWRTeW50aFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0U3ludGhUaW1lO1xuICAgIHByaW50KCdcXG7inKggIFN5bnRoZXNpcyB0aW1lOiAlc3NcXG4nLCBmb3JtYXRUaW1lKGVsYXBzZWRTeW50aFRpbWUpKTtcblxuICAgIGNvbnN0IHJlcXVpcmVBcHByb3ZhbCA9IG9wdGlvbnMucmVxdWlyZUFwcHJvdmFsID8/IFJlcXVpcmVBcHByb3ZhbC5Ccm9hZGVuaW5nO1xuXG4gICAgY29uc3QgcGFyYW1ldGVyTWFwOiB7IFtuYW1lOiBzdHJpbmddOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfSB9ID0geyAnKic6IHt9IH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5wYXJhbWV0ZXJzKSB7XG4gICAgICBpZiAob3B0aW9ucy5wYXJhbWV0ZXJzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgY29uc3QgW3N0YWNrLCBwYXJhbWV0ZXJdID0ga2V5LnNwbGl0KCc6JywgMik7XG4gICAgICAgIGlmICghcGFyYW1ldGVyKSB7XG4gICAgICAgICAgcGFyYW1ldGVyTWFwWycqJ11bc3RhY2tdID0gb3B0aW9ucy5wYXJhbWV0ZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFwYXJhbWV0ZXJNYXBbc3RhY2tdKSB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJNYXBbc3RhY2tdID0ge307XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmFtZXRlck1hcFtzdGFja11bcGFyYW1ldGVyXSA9IG9wdGlvbnMucGFyYW1ldGVyc1trZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuaG90c3dhcCkge1xuICAgICAgd2FybmluZygn4pqg77iPIFRoZSAtLWhvdHN3YXAgZmxhZyBkZWxpYmVyYXRlbHkgaW50cm9kdWNlcyBDbG91ZEZvcm1hdGlvbiBkcmlmdCB0byBzcGVlZCB1cCBkZXBsb3ltZW50cycpO1xuICAgICAgd2FybmluZygn4pqg77iPIEl0IHNob3VsZCBvbmx5IGJlIHVzZWQgZm9yIGRldmVsb3BtZW50IC0gbmV2ZXIgdXNlIGl0IGZvciB5b3VyIHByb2R1Y3Rpb24gU3RhY2tzIScpO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YWNrT3V0cHV0czogeyBba2V5OiBzdHJpbmddOiBhbnkgfSA9IHsgfTtcbiAgICBjb25zdCBvdXRwdXRzRmlsZSA9IG9wdGlvbnMub3V0cHV0c0ZpbGU7XG5cbiAgICBmb3IgKGNvbnN0IHN0YWNrIG9mIHN0YWNrcy5zdGFja0FydGlmYWN0cykge1xuICAgICAgaWYgKHN0YWNrcy5zdGFja0NvdW50ICE9PSAxKSB7IGhpZ2hsaWdodChzdGFjay5kaXNwbGF5TmFtZSk7IH1cbiAgICAgIGlmICghc3RhY2suZW52aXJvbm1lbnQpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBTdGFjayAke3N0YWNrLmRpc3BsYXlOYW1lfSBkb2VzIG5vdCBkZWZpbmUgYW4gZW52aXJvbm1lbnQsIGFuZCBBV1MgY3JlZGVudGlhbHMgY291bGQgbm90IGJlIG9idGFpbmVkIGZyb20gc3RhbmRhcmQgbG9jYXRpb25zIG9yIG5vIHJlZ2lvbiB3YXMgY29uZmlndXJlZC5gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKE9iamVjdC5rZXlzKHN0YWNrLnRlbXBsYXRlLlJlc291cmNlcyB8fCB7fSkubGVuZ3RoID09PSAwKSB7IC8vIFRoZSBnZW5lcmF0ZWQgc3RhY2sgaGFzIG5vIHJlc291cmNlc1xuICAgICAgICBpZiAoIWF3YWl0IHRoaXMucHJvcHMuY2xvdWRGb3JtYXRpb24uc3RhY2tFeGlzdHMoeyBzdGFjayB9KSkge1xuICAgICAgICAgIHdhcm5pbmcoJyVzOiBzdGFjayBoYXMgbm8gcmVzb3VyY2VzLCBza2lwcGluZyBkZXBsb3ltZW50LicsIGNoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKCclczogc3RhY2sgaGFzIG5vIHJlc291cmNlcywgZGVsZXRpbmcgZXhpc3Rpbmcgc3RhY2suJywgY2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgIGF3YWl0IHRoaXMuZGVzdHJveSh7XG4gICAgICAgICAgICBzZWxlY3RvcjogeyBwYXR0ZXJuczogW3N0YWNrLnN0YWNrTmFtZV0gfSxcbiAgICAgICAgICAgIGV4Y2x1c2l2ZWx5OiB0cnVlLFxuICAgICAgICAgICAgZm9yY2U6IHRydWUsXG4gICAgICAgICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICAgICAgICBmcm9tRGVwbG95OiB0cnVlLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVxdWlyZUFwcHJvdmFsICE9PSBSZXF1aXJlQXBwcm92YWwuTmV2ZXIpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFRlbXBsYXRlID0gYXdhaXQgdGhpcy5wcm9wcy5jbG91ZEZvcm1hdGlvbi5yZWFkQ3VycmVudFRlbXBsYXRlKHN0YWNrKTtcbiAgICAgICAgaWYgKHByaW50U2VjdXJpdHlEaWZmKGN1cnJlbnRUZW1wbGF0ZSwgc3RhY2ssIHJlcXVpcmVBcHByb3ZhbCkpIHtcblxuICAgICAgICAgIC8vIG9ubHkgdGFsayB0byB1c2VyIGlmIFNURElOIGlzIGEgdGVybWluYWwgKG90aGVyd2lzZSwgZmFpbClcbiAgICAgICAgICBpZiAoIXByb2Nlc3Muc3RkaW4uaXNUVFkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgJ1wiLS1yZXF1aXJlLWFwcHJvdmFsXCIgaXMgZW5hYmxlZCBhbmQgc3RhY2sgaW5jbHVkZXMgc2VjdXJpdHktc2Vuc2l0aXZlIHVwZGF0ZXMsICcgK1xuICAgICAgICAgICAgICAnYnV0IHRlcm1pbmFsIChUVFkpIGlzIG5vdCBhdHRhY2hlZCBzbyB3ZSBhcmUgdW5hYmxlIHRvIGdldCBhIGNvbmZpcm1hdGlvbiBmcm9tIHRoZSB1c2VyJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgY29uZmlybWVkID0gYXdhaXQgcHJvbXB0bHkuY29uZmlybSgnRG8geW91IHdpc2ggdG8gZGVwbG95IHRoZXNlIGNoYW5nZXMgKHkvbik/Jyk7XG4gICAgICAgICAgaWYgKCFjb25maXJtZWQpIHsgdGhyb3cgbmV3IEVycm9yKCdBYm9ydGVkIGJ5IHVzZXInKTsgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHByaW50KCclczogZGVwbG95aW5nLi4uJywgY2hhbGsuYm9sZChzdGFjay5kaXNwbGF5TmFtZSkpO1xuICAgICAgY29uc3Qgc3RhcnREZXBsb3lUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgICAgIGxldCB0YWdzID0gb3B0aW9ucy50YWdzO1xuICAgICAgaWYgKCF0YWdzIHx8IHRhZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRhZ3MgPSB0YWdzRm9yU3RhY2soc3RhY2spO1xuICAgICAgfVxuXG4gICAgICBsZXQgZWxhcHNlZERlcGxveVRpbWUgPSAwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5wcm9wcy5jbG91ZEZvcm1hdGlvbi5kZXBsb3lTdGFjayh7XG4gICAgICAgICAgc3RhY2ssXG4gICAgICAgICAgZGVwbG95TmFtZTogc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICAgIHJvbGVBcm46IG9wdGlvbnMucm9sZUFybixcbiAgICAgICAgICB0b29sa2l0U3RhY2tOYW1lOiBvcHRpb25zLnRvb2xraXRTdGFja05hbWUsXG4gICAgICAgICAgcmV1c2VBc3NldHM6IG9wdGlvbnMucmV1c2VBc3NldHMsXG4gICAgICAgICAgbm90aWZpY2F0aW9uQXJuczogb3B0aW9ucy5ub3RpZmljYXRpb25Bcm5zLFxuICAgICAgICAgIHRhZ3MsXG4gICAgICAgICAgZXhlY3V0ZTogb3B0aW9ucy5leGVjdXRlLFxuICAgICAgICAgIGNoYW5nZVNldE5hbWU6IG9wdGlvbnMuY2hhbmdlU2V0TmFtZSxcbiAgICAgICAgICBmb3JjZTogb3B0aW9ucy5mb3JjZSxcbiAgICAgICAgICBwYXJhbWV0ZXJzOiBPYmplY3QuYXNzaWduKHt9LCBwYXJhbWV0ZXJNYXBbJyonXSwgcGFyYW1ldGVyTWFwW3N0YWNrLnN0YWNrTmFtZV0pLFxuICAgICAgICAgIHVzZVByZXZpb3VzUGFyYW1ldGVyczogb3B0aW9ucy51c2VQcmV2aW91c1BhcmFtZXRlcnMsXG4gICAgICAgICAgcHJvZ3Jlc3M6IG9wdGlvbnMucHJvZ3Jlc3MsXG4gICAgICAgICAgY2k6IG9wdGlvbnMuY2ksXG4gICAgICAgICAgcm9sbGJhY2s6IG9wdGlvbnMucm9sbGJhY2ssXG4gICAgICAgICAgaG90c3dhcDogb3B0aW9ucy5ob3Rzd2FwLFxuICAgICAgICAgIGV4dHJhVXNlckFnZW50OiBvcHRpb25zLmV4dHJhVXNlckFnZW50LFxuICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVzdWx0Lm5vT3BcbiAgICAgICAgICA/ICcg4pyFICAlcyAobm8gY2hhbmdlcyknXG4gICAgICAgICAgOiAnIOKchSAgJXMnO1xuXG4gICAgICAgIHN1Y2Nlc3MoJ1xcbicgKyBtZXNzYWdlLCBzdGFjay5kaXNwbGF5TmFtZSk7XG4gICAgICAgIGVsYXBzZWREZXBsb3lUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgLSBzdGFydERlcGxveVRpbWU7XG4gICAgICAgIHByaW50KCdcXG7inKggIERlcGxveW1lbnQgdGltZTogJXNzXFxuJywgZm9ybWF0VGltZShlbGFwc2VkRGVwbG95VGltZSkpO1xuXG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXN1bHQub3V0cHV0cykubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHByaW50KCdPdXRwdXRzOicpO1xuXG4gICAgICAgICAgc3RhY2tPdXRwdXRzW3N0YWNrLnN0YWNrTmFtZV0gPSByZXN1bHQub3V0cHV0cztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBPYmplY3Qua2V5cyhyZXN1bHQub3V0cHV0cykuc29ydCgpKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHQub3V0cHV0c1tuYW1lXTtcbiAgICAgICAgICBwcmludCgnJXMuJXMgPSAlcycsIGNoYWxrLmN5YW4oc3RhY2suaWQpLCBjaGFsay5jeWFuKG5hbWUpLCBjaGFsay51bmRlcmxpbmUoY2hhbGsuY3lhbih2YWx1ZSkpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHByaW50KCdTdGFjayBBUk46Jyk7XG5cbiAgICAgICAgZGF0YShyZXN1bHQuc3RhY2tBcm4pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBlcnJvcignXFxuIOKdjCAgJXMgZmFpbGVkOiAlcycsIGNoYWxrLmJvbGQoc3RhY2suZGlzcGxheU5hbWUpLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNsb3VkV2F0Y2hMb2dNb25pdG9yKSB7XG4gICAgICAgICAgY29uc3QgZm91bmRMb2dHcm91cHNSZXN1bHQgPSBhd2FpdCBmaW5kQ2xvdWRXYXRjaExvZ0dyb3Vwcyh0aGlzLnByb3BzLnNka1Byb3ZpZGVyLCBzdGFjayk7XG4gICAgICAgICAgb3B0aW9ucy5jbG91ZFdhdGNoTG9nTW9uaXRvci5hZGRMb2dHcm91cHMoZm91bmRMb2dHcm91cHNSZXN1bHQuZW52LCBmb3VuZExvZ0dyb3Vwc1Jlc3VsdC5zZGssIGZvdW5kTG9nR3JvdXBzUmVzdWx0LmxvZ0dyb3VwTmFtZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGFuIG91dHB1dHMgZmlsZSBoYXMgYmVlbiBzcGVjaWZpZWQsIGNyZWF0ZSB0aGUgZmlsZSBwYXRoIGFuZCB3cml0ZSBzdGFjayBvdXRwdXRzIHRvIGl0IG9uY2UuXG4gICAgICAgIC8vIE91dHB1dHMgYXJlIHdyaXR0ZW4gYWZ0ZXIgYWxsIHN0YWNrcyBoYXZlIGJlZW4gZGVwbG95ZWQuIElmIGEgc3RhY2sgZGVwbG95bWVudCBmYWlscyxcbiAgICAgICAgLy8gYWxsIG9mIHRoZSBvdXRwdXRzIGZyb20gc3VjY2Vzc2Z1bGx5IGRlcGxveWVkIHN0YWNrcyBiZWZvcmUgdGhlIGZhaWx1cmUgd2lsbCBzdGlsbCBiZSB3cml0dGVuLlxuICAgICAgICBpZiAob3V0cHV0c0ZpbGUpIHtcbiAgICAgICAgICBmcy5lbnN1cmVGaWxlU3luYyhvdXRwdXRzRmlsZSk7XG4gICAgICAgICAgYXdhaXQgZnMud3JpdGVKc29uKG91dHB1dHNGaWxlLCBzdGFja091dHB1dHMsIHtcbiAgICAgICAgICAgIHNwYWNlczogMixcbiAgICAgICAgICAgIGVuY29kaW5nOiAndXRmOCcsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByaW50KCdcXG7inKggIFRvdGFsIHRpbWU6ICVzc1xcbicsIGZvcm1hdFRpbWUoZWxhcHNlZFN5bnRoVGltZSArIGVsYXBzZWREZXBsb3lUaW1lKSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIGFzeW5jIHdhdGNoKG9wdGlvbnM6IFdhdGNoT3B0aW9ucykge1xuICAgIGNvbnN0IHJvb3REaXIgPSBwYXRoLmRpcm5hbWUocGF0aC5yZXNvbHZlKFBST0pFQ1RfQ09ORklHKSk7XG4gICAgZGVidWcoXCJyb290IGRpcmVjdG9yeSB1c2VkIGZvciAnd2F0Y2gnIGlzOiAlc1wiLCByb290RGlyKTtcblxuICAgIGNvbnN0IHdhdGNoU2V0dGluZ3M6IHsgaW5jbHVkZT86IHN0cmluZyB8IHN0cmluZ1tdLCBleGNsdWRlOiBzdHJpbmcgfCBzdHJpbmcgW10gfSB8IHVuZGVmaW5lZCA9XG4gICAgICAgIHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWyd3YXRjaCddKTtcbiAgICBpZiAoIXdhdGNoU2V0dGluZ3MpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgdGhlICd3YXRjaCcgY29tbWFuZCB3aXRob3V0IHNwZWNpZnlpbmcgYXQgbGVhc3Qgb25lIGRpcmVjdG9yeSB0byBtb25pdG9yLiBcIiArXG4gICAgICAgICdNYWtlIHN1cmUgdG8gYWRkIGEgXCJ3YXRjaFwiIGtleSB0byB5b3VyIGNkay5qc29uJyk7XG4gICAgfVxuXG4gICAgLy8gRm9yIHRoZSBcImluY2x1ZGVcIiBzdWJrZXkgdW5kZXIgdGhlIFwid2F0Y2hcIiBrZXksIHRoZSBiZWhhdmlvciBpczpcbiAgICAvLyAxLiBObyBcIndhdGNoXCIgc2V0dGluZz8gV2UgZXJyb3Igb3V0LlxuICAgIC8vIDIuIFwid2F0Y2hcIiBzZXR0aW5nIHdpdGhvdXQgYW4gXCJpbmNsdWRlXCIga2V5PyBXZSBkZWZhdWx0IHRvIG9ic2VydmluZyBcIi4vKipcIi5cbiAgICAvLyAzLiBcIndhdGNoXCIgc2V0dGluZyB3aXRoIGFuIGVtcHR5IFwiaW5jbHVkZVwiIGtleT8gV2UgZGVmYXVsdCB0byBvYnNlcnZpbmcgXCIuLyoqXCIuXG4gICAgLy8gNC4gTm9uLWVtcHR5IFwiaW5jbHVkZVwiIGtleT8gSnVzdCB1c2UgdGhlIFwiaW5jbHVkZVwiIGtleS5cbiAgICBjb25zdCB3YXRjaEluY2x1ZGVzID0gdGhpcy5wYXR0ZXJuc0FycmF5Rm9yV2F0Y2god2F0Y2hTZXR0aW5ncy5pbmNsdWRlLCB7IHJvb3REaXIsIHJldHVyblJvb3REaXJJZkVtcHR5OiB0cnVlIH0pO1xuICAgIGRlYnVnKFwiJ2luY2x1ZGUnIHBhdHRlcm5zIGZvciAnd2F0Y2gnOiAlc1wiLCB3YXRjaEluY2x1ZGVzKTtcblxuICAgIC8vIEZvciB0aGUgXCJleGNsdWRlXCIgc3Via2V5IHVuZGVyIHRoZSBcIndhdGNoXCIga2V5LFxuICAgIC8vIHRoZSBiZWhhdmlvciBpcyB0byBhZGQgc29tZSBkZWZhdWx0IGV4Y2x1ZGVzIGluIGFkZGl0aW9uIHRvIHRoZSBvbmVzIHNwZWNpZmllZCBieSB0aGUgdXNlcjpcbiAgICAvLyAxLiBUaGUgQ0RLIG91dHB1dCBkaXJlY3RvcnkuXG4gICAgLy8gMi4gQW55IGZpbGUgd2hvc2UgbmFtZSBzdGFydHMgd2l0aCBhIGRvdC5cbiAgICAvLyAzLiBBbnkgZGlyZWN0b3J5J3MgY29udGVudCB3aG9zZSBuYW1lIHN0YXJ0cyB3aXRoIGEgZG90LlxuICAgIC8vIDQuIEFueSBub2RlX21vZHVsZXMgYW5kIGl0cyBjb250ZW50IChldmVuIGlmIGl0J3Mgbm90IGEgSlMvVFMgcHJvamVjdCwgeW91IG1pZ2h0IGJlIHVzaW5nIGEgbG9jYWwgYXdzLWNsaSBwYWNrYWdlKVxuICAgIGNvbnN0IG91dHB1dERpciA9IHRoaXMucHJvcHMuY29uZmlndXJhdGlvbi5zZXR0aW5ncy5nZXQoWydvdXRwdXQnXSk7XG4gICAgY29uc3Qgd2F0Y2hFeGNsdWRlcyA9IHRoaXMucGF0dGVybnNBcnJheUZvcldhdGNoKHdhdGNoU2V0dGluZ3MuZXhjbHVkZSwgeyByb290RGlyLCByZXR1cm5Sb290RGlySWZFbXB0eTogZmFsc2UgfSkuY29uY2F0KFxuICAgICAgYCR7b3V0cHV0RGlyfS8qKmAsXG4gICAgICAnKiovLionLFxuICAgICAgJyoqLy4qLyoqJyxcbiAgICAgICcqKi9ub2RlX21vZHVsZXMvKionLFxuICAgICk7XG4gICAgZGVidWcoXCInZXhjbHVkZScgcGF0dGVybnMgZm9yICd3YXRjaCc6ICVzXCIsIHdhdGNoRXhjbHVkZXMpO1xuXG4gICAgLy8gU2luY2UgJ2NkayBkZXBsb3knIGlzIGEgcmVsYXRpdmVseSBzbG93IG9wZXJhdGlvbiBmb3IgYSAnd2F0Y2gnIHByb2Nlc3MsXG4gICAgLy8gaW50cm9kdWNlIGEgY29uY3VycmVuY3kgbGF0Y2ggdGhhdCB0cmFja3MgdGhlIHN0YXRlLlxuICAgIC8vIFRoaXMgd2F5LCBpZiBmaWxlIGNoYW5nZSBldmVudHMgYXJyaXZlIHdoZW4gYSAnY2RrIGRlcGxveScgaXMgc3RpbGwgZXhlY3V0aW5nLFxuICAgIC8vIHdlIHdpbGwgYmF0Y2ggdGhlbSwgYW5kIHRyaWdnZXIgYW5vdGhlciAnY2RrIGRlcGxveScgYWZ0ZXIgdGhlIGN1cnJlbnQgb25lIGZpbmlzaGVzLFxuICAgIC8vIG1ha2luZyBzdXJlICdjZGsgZGVwbG95J3MgIGFsd2F5cyBleGVjdXRlIG9uZSBhdCBhIHRpbWUuXG4gICAgLy8gSGVyZSdzIGEgZGlhZ3JhbSBzaG93aW5nIHRoZSBzdGF0ZSB0cmFuc2l0aW9uczpcbiAgICAvLyAtLS0tLS0tLS0tLS0tLSAgICAgICAgICAgICAgICAtLS0tLS0tLSAgICBmaWxlIGNoYW5nZWQgICAgIC0tLS0tLS0tLS0tLS0tICAgIGZpbGUgY2hhbmdlZCAgICAgLS0tLS0tLS0tLS0tLS0gIGZpbGUgY2hhbmdlZFxuICAgIC8vIHwgICAgICAgICAgICB8ICByZWFkeSBldmVudCAgIHwgICAgICB8IC0tLS0tLS0tLS0tLS0tLS0tLT4gfCAgICAgICAgICAgIHwgLS0tLS0tLS0tLS0tLS0tLS0tPiB8ICAgICAgICAgICAgfCAtLS0tLS0tLS0tLS0tLXxcbiAgICAvLyB8IHByZS1yZWFkeSAgfCAtLS0tLS0tLS0tLS0tPiB8IG9wZW4gfCAgICAgICAgICAgICAgICAgICAgIHwgZGVwbG95aW5nICB8ICAgICAgICAgICAgICAgICAgICAgfCAgIHF1ZXVlZCAgIHwgICAgICAgICAgICAgICB8XG4gICAgLy8gfCAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgfCAgICAgIHwgPC0tLS0tLS0tLS0tLS0tLS0tLSB8ICAgICAgICAgICAgfCA8LS0tLS0tLS0tLS0tLS0tLS0tIHwgICAgICAgICAgICB8IDwtLS0tLS0tLS0tLS0tfFxuICAgIC8vIC0tLS0tLS0tLS0tLS0tICAgICAgICAgICAgICAgIC0tLS0tLS0tICAnY2RrIGRlcGxveScgZG9uZSAgLS0tLS0tLS0tLS0tLS0gICdjZGsgZGVwbG95JyBkb25lICAtLS0tLS0tLS0tLS0tLVxuICAgIGxldCBsYXRjaDogJ3ByZS1yZWFkeScgfCAnb3BlbicgfCAnZGVwbG95aW5nJyB8ICdxdWV1ZWQnID0gJ3ByZS1yZWFkeSc7XG5cbiAgICBjb25zdCBjbG91ZFdhdGNoTG9nTW9uaXRvciA9IG9wdGlvbnMudHJhY2VMb2dzID8gbmV3IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IoKSA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBkZXBsb3lBbmRXYXRjaCA9IGFzeW5jICgpID0+IHtcbiAgICAgIGxhdGNoID0gJ2RlcGxveWluZyc7XG4gICAgICBjbG91ZFdhdGNoTG9nTW9uaXRvcj8uZGVhY3RpdmF0ZSgpO1xuXG4gICAgICBhd2FpdCB0aGlzLmludm9rZURlcGxveUZyb21XYXRjaChvcHRpb25zLCBjbG91ZFdhdGNoTG9nTW9uaXRvcik7XG5cbiAgICAgIC8vIElmIGxhdGNoIGlzIHN0aWxsICdkZXBsb3lpbmcnIGFmdGVyIHRoZSAnYXdhaXQnLCB0aGF0J3MgZmluZSxcbiAgICAgIC8vIGJ1dCBpZiBpdCdzICdxdWV1ZWQnLCB0aGF0IG1lYW5zIHdlIG5lZWQgdG8gZGVwbG95IGFnYWluXG4gICAgICB3aGlsZSAoKGxhdGNoIGFzICdkZXBsb3lpbmcnIHwgJ3F1ZXVlZCcpID09PSAncXVldWVkJykge1xuICAgICAgICAvLyBUeXBlU2NyaXB0IGRvZXNuJ3QgcmVhbGl6ZSBsYXRjaCBjYW4gY2hhbmdlIGJldHdlZW4gJ2F3YWl0cycsXG4gICAgICAgIC8vIGFuZCB0aGlua3MgdGhlIGFib3ZlICd3aGlsZScgY29uZGl0aW9uIGlzIGFsd2F5cyAnZmFsc2UnIHdpdGhvdXQgdGhlIGNhc3RcbiAgICAgICAgbGF0Y2ggPSAnZGVwbG95aW5nJztcbiAgICAgICAgcHJpbnQoXCJEZXRlY3RlZCBmaWxlIGNoYW5nZXMgZHVyaW5nIGRlcGxveW1lbnQuIEludm9raW5nICdjZGsgZGVwbG95JyBhZ2FpblwiKTtcbiAgICAgICAgYXdhaXQgdGhpcy5pbnZva2VEZXBsb3lGcm9tV2F0Y2gob3B0aW9ucywgY2xvdWRXYXRjaExvZ01vbml0b3IpO1xuICAgICAgfVxuICAgICAgbGF0Y2ggPSAnb3Blbic7XG4gICAgICBjbG91ZFdhdGNoTG9nTW9uaXRvcj8uYWN0aXZhdGUoKTtcbiAgICB9O1xuXG4gICAgY2hva2lkYXIud2F0Y2god2F0Y2hJbmNsdWRlcywge1xuICAgICAgaWdub3JlZDogd2F0Y2hFeGNsdWRlcyxcbiAgICAgIGN3ZDogcm9vdERpcixcbiAgICAgIC8vIGlnbm9yZUluaXRpYWw6IHRydWUsXG4gICAgfSkub24oJ3JlYWR5JywgYXN5bmMgKCkgPT4ge1xuICAgICAgbGF0Y2ggPSAnb3Blbic7XG4gICAgICBkZWJ1ZyhcIid3YXRjaCcgcmVjZWl2ZWQgdGhlICdyZWFkeScgZXZlbnQuIEZyb20gbm93IG9uLCBhbGwgZmlsZSBjaGFuZ2VzIHdpbGwgdHJpZ2dlciBhIGRlcGxveW1lbnRcIik7XG4gICAgICBwcmludChcIlRyaWdnZXJpbmcgaW5pdGlhbCAnY2RrIGRlcGxveSdcIik7XG4gICAgICBhd2FpdCBkZXBsb3lBbmRXYXRjaCgpO1xuICAgIH0pLm9uKCdhbGwnLCBhc3luYyAoZXZlbnQ6ICdhZGQnIHwgJ2FkZERpcicgfCAnY2hhbmdlJyB8ICd1bmxpbmsnIHwgJ3VubGlua0RpcicsIGZpbGVQYXRoPzogc3RyaW5nKSA9PiB7XG4gICAgICBpZiAobGF0Y2ggPT09ICdwcmUtcmVhZHknKSB7XG4gICAgICAgIHByaW50KGAnd2F0Y2gnIGlzIG9ic2VydmluZyAke2V2ZW50ID09PSAnYWRkRGlyJyA/ICdkaXJlY3RvcnknIDogJ3RoZSBmaWxlJ30gJyVzJyBmb3IgY2hhbmdlc2AsIGZpbGVQYXRoKTtcbiAgICAgIH0gZWxzZSBpZiAobGF0Y2ggPT09ICdvcGVuJykge1xuICAgICAgICBwcmludChcIkRldGVjdGVkIGNoYW5nZSB0byAnJXMnICh0eXBlOiAlcykuIFRyaWdnZXJpbmcgJ2NkayBkZXBsb3knXCIsIGZpbGVQYXRoLCBldmVudCk7XG4gICAgICAgIGF3YWl0IGRlcGxveUFuZFdhdGNoKCk7XG4gICAgICB9IGVsc2UgeyAvLyB0aGlzIG1lYW5zIGxhdGNoIGlzIGVpdGhlciAnZGVwbG95aW5nJyBvciAncXVldWVkJ1xuICAgICAgICBsYXRjaCA9ICdxdWV1ZWQnO1xuICAgICAgICBwcmludChcIkRldGVjdGVkIGNoYW5nZSB0byAnJXMnICh0eXBlOiAlcykgd2hpbGUgJ2NkayBkZXBsb3knIGlzIHN0aWxsIHJ1bm5pbmcuIFwiICtcbiAgICAgICAgICAgICdXaWxsIHF1ZXVlIGZvciBhbm90aGVyIGRlcGxveW1lbnQgYWZ0ZXIgdGhpcyBvbmUgZmluaXNoZXMnLCBmaWxlUGF0aCwgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlc3Ryb3kob3B0aW9uczogRGVzdHJveU9wdGlvbnMpIHtcbiAgICBsZXQgc3RhY2tzID0gYXdhaXQgdGhpcy5zZWxlY3RTdGFja3NGb3JEZXN0cm95KG9wdGlvbnMuc2VsZWN0b3IsIG9wdGlvbnMuZXhjbHVzaXZlbHkpO1xuXG4gICAgLy8gVGhlIHN0YWNrcyB3aWxsIGhhdmUgYmVlbiBvcmRlcmVkIGZvciBkZXBsb3ltZW50LCBzbyByZXZlcnNlIHRoZW0gZm9yIGRlbGV0aW9uLlxuICAgIHN0YWNrcyA9IHN0YWNrcy5yZXZlcnNlZCgpO1xuXG4gICAgaWYgKCFvcHRpb25zLmZvcmNlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgY29uc3QgY29uZmlybWVkID0gYXdhaXQgcHJvbXB0bHkuY29uZmlybShgQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIGRlbGV0ZTogJHtjaGFsay5ibHVlKHN0YWNrcy5zdGFja0FydGlmYWN0cy5tYXAocyA9PiBzLmhpZXJhcmNoaWNhbElkKS5qb2luKCcsICcpKX0gKHkvbik/YCk7XG4gICAgICBpZiAoIWNvbmZpcm1lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgYWN0aW9uID0gb3B0aW9ucy5mcm9tRGVwbG95ID8gJ2RlcGxveScgOiAnZGVzdHJveSc7XG4gICAgZm9yIChjb25zdCBzdGFjayBvZiBzdGFja3Muc3RhY2tBcnRpZmFjdHMpIHtcbiAgICAgIHN1Y2Nlc3MoJyVzOiBkZXN0cm95aW5nLi4uJywgY2hhbGsuYmx1ZShzdGFjay5kaXNwbGF5TmFtZSkpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgdGhpcy5wcm9wcy5jbG91ZEZvcm1hdGlvbi5kZXN0cm95U3RhY2soe1xuICAgICAgICAgIHN0YWNrLFxuICAgICAgICAgIGRlcGxveU5hbWU6IHN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICByb2xlQXJuOiBvcHRpb25zLnJvbGVBcm4sXG4gICAgICAgIH0pO1xuICAgICAgICBzdWNjZXNzKGBcXG4g4pyFICAlczogJHthY3Rpb259ZWRgLCBjaGFsay5ibHVlKHN0YWNrLmRpc3BsYXlOYW1lKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGVycm9yKGBcXG4g4p2MICAlczogJHthY3Rpb259IGZhaWxlZGAsIGNoYWxrLmJsdWUoc3RhY2suZGlzcGxheU5hbWUpLCBlKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgbGlzdChzZWxlY3RvcnM6IHN0cmluZ1tdLCBvcHRpb25zOiB7IGxvbmc/OiBib29sZWFuLCBqc29uPzogYm9vbGVhbiB9ID0geyB9KTogUHJvbWlzZTxudW1iZXI+IHtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCB0aGlzLnNlbGVjdFN0YWNrc0Zvckxpc3Qoc2VsZWN0b3JzKTtcblxuICAgIC8vIGlmIHdlIGFyZSBpbiBcImxvbmdcIiBtb2RlLCBlbWl0IHRoZSBhcnJheSBhcy1pcyAoSlNPTi9ZQU1MKVxuICAgIGlmIChvcHRpb25zLmxvbmcpIHtcbiAgICAgIGNvbnN0IGxvbmcgPSBbXTtcbiAgICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzLnN0YWNrQXJ0aWZhY3RzKSB7XG4gICAgICAgIGxvbmcucHVzaCh7XG4gICAgICAgICAgaWQ6IHN0YWNrLmhpZXJhcmNoaWNhbElkLFxuICAgICAgICAgIG5hbWU6IHN0YWNrLnN0YWNrTmFtZSxcbiAgICAgICAgICBlbnZpcm9ubWVudDogc3RhY2suZW52aXJvbm1lbnQsXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgZGF0YShzZXJpYWxpemVTdHJ1Y3R1cmUobG9uZywgb3B0aW9ucy5qc29uID8/IGZhbHNlKSk7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBqdXN0IHByaW50IHN0YWNrIElEc1xuICAgIGZvciAoY29uc3Qgc3RhY2sgb2Ygc3RhY2tzLnN0YWNrQXJ0aWZhY3RzKSB7XG4gICAgICBkYXRhKHN0YWNrLmhpZXJhcmNoaWNhbElkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gMDsgLy8gZXhpdC1jb2RlXG4gIH1cblxuICAvKipcbiAgICogU3ludGhlc2l6ZSB0aGUgZ2l2ZW4gc2V0IG9mIHN0YWNrcyAoY2FsbGVkIHdoZW4gdGhlIHVzZXIgcnVucyAnY2RrIHN5bnRoJylcbiAgICpcbiAgICogSU5QVVQ6IFN0YWNrIG5hbWVzIGNhbiBiZSBzdXBwbGllZCB1c2luZyBhIGdsb2IgZmlsdGVyLiBJZiBubyBzdGFja3MgYXJlXG4gICAqIGdpdmVuLCBhbGwgc3RhY2tzIGZyb20gdGhlIGFwcGxpY2F0aW9uIGFyZSBpbXBsaWN0bHkgc2VsZWN0ZWQuXG4gICAqXG4gICAqIE9VVFBVVDogSWYgbW9yZSB0aGFuIG9uZSBzdGFjayBlbmRzIHVwIGJlaW5nIHNlbGVjdGVkLCBhbiBvdXRwdXQgZGlyZWN0b3J5XG4gICAqIHNob3VsZCBiZSBzdXBwbGllZCwgd2hlcmUgdGhlIHRlbXBsYXRlcyB3aWxsIGJlIHdyaXR0ZW4uXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgc3ludGgoc3RhY2tOYW1lczogc3RyaW5nW10sIGV4Y2x1c2l2ZWx5OiBib29sZWFuLCBxdWlldDogYm9vbGVhbiwgYXV0b1ZhbGlkYXRlPzogYm9vbGVhbiwganNvbj86IGJvb2xlYW4pOiBQcm9taXNlPGFueT4ge1xuICAgIGNvbnN0IHN0YWNrcyA9IGF3YWl0IHRoaXMuc2VsZWN0U3RhY2tzRm9yRGlmZihzdGFja05hbWVzLCBleGNsdXNpdmVseSwgYXV0b1ZhbGlkYXRlKTtcblxuICAgIC8vIGlmIHdlIGhhdmUgYSBzaW5nbGUgc3RhY2ssIHByaW50IGl0IHRvIFNURE9VVFxuICAgIGlmIChzdGFja3Muc3RhY2tDb3VudCA9PT0gMSkge1xuICAgICAgaWYgKCFxdWlldCkge1xuICAgICAgICBkYXRhKHNlcmlhbGl6ZVN0cnVjdHVyZShzdGFja3MuZmlyc3RTdGFjay50ZW1wbGF0ZSwganNvbiA/PyBmYWxzZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIGEgc2xpZ2h0IGhhY2s7IGluIGludGVnIG1vZGUgd2UgYWxsb3cgbXVsdGlwbGUgc3RhY2tzIHRvIGJlIHN5bnRoZXNpemVkIHRvIHN0ZG91dCBzZXF1ZW50aWFsbHkuXG4gICAgLy8gVGhpcyBpcyB0byBtYWtlIGl0IHNvIHRoYXQgd2UgY2FuIHN1cHBvcnQgbXVsdGktc3RhY2sgaW50ZWcgdGVzdCBleHBlY3RhdGlvbnMsIHdpdGhvdXQgc28gZHJhc3RpY2FsbHlcbiAgICAvLyBoYXZpbmcgdG8gY2hhbmdlIHRoZSBzeW50aGVzaXMgZm9ybWF0IHRoYXQgd2UgaGF2ZSB0byByZXJ1biBhbGwgaW50ZWcgdGVzdHMuXG4gICAgLy9cbiAgICAvLyBCZWNhdXNlIHRoaXMgZmVhdHVyZSBpcyBub3QgdXNlZnVsIHRvIGNvbnN1bWVycyAodGhlIG91dHB1dCBpcyBtaXNzaW5nXG4gICAgLy8gdGhlIHN0YWNrIG5hbWVzKSwgaXQncyBub3QgZXhwb3NlZCBhcyBhIENMSSBmbGFnLiBJbnN0ZWFkLCBpdCdzIGhpZGRlblxuICAgIC8vIGJlaGluZCBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAgICBjb25zdCBpc0ludGVnTW9kZSA9IHByb2Nlc3MuZW52LkNES19JTlRFR19NT0RFID09PSAnMSc7XG4gICAgaWYgKGlzSW50ZWdNb2RlKSB7XG4gICAgICBkYXRhKHNlcmlhbGl6ZVN0cnVjdHVyZShzdGFja3Muc3RhY2tBcnRpZmFjdHMubWFwKHMgPT4gcy50ZW1wbGF0ZSksIGpzb24gPz8gZmFsc2UpKTtcbiAgICB9XG5cbiAgICAvLyBub3Qgb3V0cHV0dGluZyB0ZW1wbGF0ZSB0byBzdGRvdXQsIGxldCdzIGV4cGxhaW4gdGhpbmdzIHRvIHRoZSB1c2VyIGEgbGl0dGxlIGJpdC4uLlxuICAgIHN1Y2Nlc3MoYFN1Y2Nlc3NmdWxseSBzeW50aGVzaXplZCB0byAke2NoYWxrLmJsdWUocGF0aC5yZXNvbHZlKHN0YWNrcy5hc3NlbWJseS5kaXJlY3RvcnkpKX1gKTtcbiAgICBwcmludChgU3VwcGx5IGEgc3RhY2sgaWQgKCR7c3RhY2tzLnN0YWNrQXJ0aWZhY3RzLm1hcChzID0+IGNoYWxrLmdyZWVuKHMuaGllcmFyY2hpY2FsSWQpKS5qb2luKCcsICcpfSkgdG8gZGlzcGxheSBpdHMgdGVtcGxhdGUuYCk7XG5cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEJvb3RzdHJhcCB0aGUgQ0RLIFRvb2xraXQgc3RhY2sgaW4gdGhlIGFjY291bnRzIHVzZWQgYnkgdGhlIHNwZWNpZmllZCBzdGFjayhzKS5cbiAgICpcbiAgICogQHBhcmFtIGVudmlyb25tZW50U3BlY3MgZW52aXJvbm1lbnQgbmFtZXMgdGhhdCBuZWVkIHRvIGhhdmUgdG9vbGtpdCBzdXBwb3J0XG4gICAqICAgICAgICAgICAgIHByb3Zpc2lvbmVkLCBhcyBhIGdsb2IgZmlsdGVyLiBJZiBub25lIGlzIHByb3ZpZGVkLFxuICAgKiAgICAgICAgICAgICBhbGwgc3RhY2tzIGFyZSBpbXBsaWNpdGx5IHNlbGVjdGVkLlxuICAgKiBAcGFyYW0gdG9vbGtpdFN0YWNrTmFtZSB0aGUgbmFtZSB0byBiZSB1c2VkIGZvciB0aGUgQ0RLIFRvb2xraXQgc3RhY2suXG4gICAqL1xuICBwdWJsaWMgYXN5bmMgYm9vdHN0cmFwKHVzZXJFbnZpcm9ubWVudFNwZWNzOiBzdHJpbmdbXSwgYm9vdHN0cmFwcGVyOiBCb290c3RyYXBwZXIsIG9wdGlvbnM6IEJvb3RzdHJhcEVudmlyb25tZW50T3B0aW9ucyk6IFByb21pc2U8dm9pZD4ge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuICctLWFwcCcgYXJndW1lbnQgYW5kIGFuIGVudmlyb25tZW50IGxvb2tzIGxpa2UgYSBnbG9iLCB3ZVxuICAgIC8vIHNlbGVjdCB0aGUgZW52aXJvbm1lbnRzIGZyb20gdGhlIGFwcC4gT3RoZXJ3aXNlIHVzZSB3aGF0IHRoZSB1c2VyIHNhaWQuXG5cbiAgICAvLyBCeSBkZWZhdWx0IGdsb2IgZm9yIGV2ZXJ5dGhpbmdcbiAgICBjb25zdCBlbnZpcm9ubWVudFNwZWNzID0gdXNlckVudmlyb25tZW50U3BlY3MubGVuZ3RoID4gMCA/IFsuLi51c2VyRW52aXJvbm1lbnRTcGVjc10gOiBbJyoqJ107XG5cbiAgICAvLyBQYXJ0aXRpb24gaW50byBnbG9icyBhbmQgbm9uLWdsb2JzICh0aGlzIHdpbGwgbXV0YXRlIGVudmlyb25tZW50U3BlY3MpLlxuICAgIGNvbnN0IGdsb2JTcGVjcyA9IHBhcnRpdGlvbihlbnZpcm9ubWVudFNwZWNzLCBsb29rc0xpa2VHbG9iKTtcbiAgICBpZiAoZ2xvYlNwZWNzLmxlbmd0aCA+IDAgJiYgIXRoaXMucHJvcHMuY2xvdWRFeGVjdXRhYmxlLmhhc0FwcCkge1xuICAgICAgaWYgKHVzZXJFbnZpcm9ubWVudFNwZWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVXNlciBkaWQgcmVxdWVzdCB0aGlzIGdsb2JcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAnJHtnbG9iU3BlY3N9JyBpcyBub3QgYW4gZW52aXJvbm1lbnQgbmFtZS4gU3BlY2lmeSBhbiBlbnZpcm9ubWVudCBuYW1lIGxpa2UgJ2F3czovLzEyMzQ1Njc4OTAxMi91cy1lYXN0LTEnLCBvciBydW4gaW4gYSBkaXJlY3Rvcnkgd2l0aCAnY2RrLmpzb24nIHRvIHVzZSB3aWxkY2FyZHMuYCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVc2VyIGRpZCBub3QgcmVxdWVzdCBhbnl0aGluZ1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NwZWNpZnkgYW4gZW52aXJvbm1lbnQgbmFtZSBsaWtlIFxcJ2F3czovLzEyMzQ1Njc4OTAxMi91cy1lYXN0LTFcXCcsIG9yIHJ1biBpbiBhIGRpcmVjdG9yeSB3aXRoIFxcJ2Nkay5qc29uXFwnLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGVudmlyb25tZW50czogY3hhcGkuRW52aXJvbm1lbnRbXSA9IFtcbiAgICAgIC4uLmVudmlyb25tZW50c0Zyb21EZXNjcmlwdG9ycyhlbnZpcm9ubWVudFNwZWNzKSxcbiAgICBdO1xuXG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gJy0tYXBwJyBhcmd1bWVudCwgc2VsZWN0IHRoZSBlbnZpcm9ubWVudHMgZnJvbSB0aGUgYXBwLlxuICAgIGlmICh0aGlzLnByb3BzLmNsb3VkRXhlY3V0YWJsZS5oYXNBcHApIHtcbiAgICAgIGVudmlyb25tZW50cy5wdXNoKC4uLmF3YWl0IGdsb2JFbnZpcm9ubWVudHNGcm9tU3RhY2tzKGF3YWl0IHRoaXMuc2VsZWN0U3RhY2tzRm9yTGlzdChbXSksIGdsb2JTcGVjcywgdGhpcy5wcm9wcy5zZGtQcm92aWRlcikpO1xuICAgIH1cblxuICAgIGF3YWl0IFByb21pc2UuYWxsKGVudmlyb25tZW50cy5tYXAoYXN5bmMgKGVudmlyb25tZW50KSA9PiB7XG4gICAgICBzdWNjZXNzKCcg4o+zICBCb290c3RyYXBwaW5nIGVudmlyb25tZW50ICVzLi4uJywgY2hhbGsuYmx1ZShlbnZpcm9ubWVudC5uYW1lKSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBib290c3RyYXBwZXIuYm9vdHN0cmFwRW52aXJvbm1lbnQoZW52aXJvbm1lbnQsIHRoaXMucHJvcHMuc2RrUHJvdmlkZXIsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gcmVzdWx0Lm5vT3BcbiAgICAgICAgICA/ICcg4pyFICBFbnZpcm9ubWVudCAlcyBib290c3RyYXBwZWQgKG5vIGNoYW5nZXMpLidcbiAgICAgICAgICA6ICcg4pyFICBFbnZpcm9ubWVudCAlcyBib290c3RyYXBwZWQuJztcbiAgICAgICAgc3VjY2VzcyhtZXNzYWdlLCBjaGFsay5ibHVlKGVudmlyb25tZW50Lm5hbWUpKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3IoJyDinYwgIEVudmlyb25tZW50ICVzIGZhaWxlZCBib290c3RyYXBwaW5nOiAlcycsIGNoYWxrLmJsdWUoZW52aXJvbm1lbnQubmFtZSksIGUpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgc2VsZWN0U3RhY2tzRm9yTGlzdChwYXR0ZXJuczogc3RyaW5nW10pIHtcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHRoaXMuYXNzZW1ibHkoKTtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3MoeyBwYXR0ZXJucyB9LCB7IGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5BbGxTdGFja3MgfSk7XG5cbiAgICAvLyBObyB2YWxpZGF0aW9uXG5cbiAgICByZXR1cm4gc3RhY2tzO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzZWxlY3RTdGFja3NGb3JEZXBsb3koc2VsZWN0b3I6IFN0YWNrU2VsZWN0b3IsIGV4Y2x1c2l2ZWx5PzogYm9vbGVhbiwgY2FjaGVDbG91ZEFzc2VtYmx5PzogYm9vbGVhbik6IFByb21pc2U8U3RhY2tDb2xsZWN0aW9uPiB7XG4gICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCB0aGlzLmFzc2VtYmx5KGNhY2hlQ2xvdWRBc3NlbWJseSk7XG4gICAgY29uc3Qgc3RhY2tzID0gYXdhaXQgYXNzZW1ibHkuc2VsZWN0U3RhY2tzKHNlbGVjdG9yLCB7XG4gICAgICBleHRlbmQ6IGV4Y2x1c2l2ZWx5ID8gRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lIDogRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5VcHN0cmVhbSxcbiAgICAgIGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5Pbmx5U2luZ2xlLFxuICAgIH0pO1xuXG4gICAgdGhpcy52YWxpZGF0ZVN0YWNrc1NlbGVjdGVkKHN0YWNrcywgc2VsZWN0b3IucGF0dGVybnMpO1xuICAgIHRoaXMudmFsaWRhdGVTdGFja3Moc3RhY2tzKTtcblxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHNlbGVjdFN0YWNrc0ZvckRpZmYoc3RhY2tOYW1lczogc3RyaW5nW10sIGV4Y2x1c2l2ZWx5PzogYm9vbGVhbiwgYXV0b1ZhbGlkYXRlPzogYm9vbGVhbik6IFByb21pc2U8U3RhY2tDb2xsZWN0aW9uPiB7XG4gICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCB0aGlzLmFzc2VtYmx5KCk7XG5cbiAgICBjb25zdCBzZWxlY3RlZEZvckRpZmYgPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3MoeyBwYXR0ZXJuczogc3RhY2tOYW1lcyB9LCB7XG4gICAgICBleHRlbmQ6IGV4Y2x1c2l2ZWx5ID8gRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5Ob25lIDogRXh0ZW5kZWRTdGFja1NlbGVjdGlvbi5VcHN0cmVhbSxcbiAgICAgIGRlZmF1bHRCZWhhdmlvcjogRGVmYXVsdFNlbGVjdGlvbi5NYWluQXNzZW1ibHksXG4gICAgfSk7XG5cbiAgICBjb25zdCBhbGxTdGFja3MgPSBhd2FpdCB0aGlzLnNlbGVjdFN0YWNrc0Zvckxpc3QoW10pO1xuICAgIGNvbnN0IGF1dG9WYWxpZGF0ZVN0YWNrcyA9IGF1dG9WYWxpZGF0ZVxuICAgICAgPyBhbGxTdGFja3MuZmlsdGVyKGFydCA9PiBhcnQudmFsaWRhdGVPblN5bnRoID8/IGZhbHNlKVxuICAgICAgOiBuZXcgU3RhY2tDb2xsZWN0aW9uKGFzc2VtYmx5LCBbXSk7XG5cbiAgICB0aGlzLnZhbGlkYXRlU3RhY2tzU2VsZWN0ZWQoc2VsZWN0ZWRGb3JEaWZmLmNvbmNhdChhdXRvVmFsaWRhdGVTdGFja3MpLCBzdGFja05hbWVzKTtcbiAgICB0aGlzLnZhbGlkYXRlU3RhY2tzKHNlbGVjdGVkRm9yRGlmZi5jb25jYXQoYXV0b1ZhbGlkYXRlU3RhY2tzKSk7XG5cbiAgICByZXR1cm4gc2VsZWN0ZWRGb3JEaWZmO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBzZWxlY3RTdGFja3NGb3JEZXN0cm95KHNlbGVjdG9yOiBTdGFja1NlbGVjdG9yLCBleGNsdXNpdmVseT86IGJvb2xlYW4pIHtcbiAgICBjb25zdCBhc3NlbWJseSA9IGF3YWl0IHRoaXMuYXNzZW1ibHkoKTtcbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3Moc2VsZWN0b3IsIHtcbiAgICAgIGV4dGVuZDogZXhjbHVzaXZlbHkgPyBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLk5vbmUgOiBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLkRvd25zdHJlYW0sXG4gICAgICBkZWZhdWx0QmVoYXZpb3I6IERlZmF1bHRTZWxlY3Rpb24uT25seVNpbmdsZSxcbiAgICB9KTtcblxuICAgIC8vIE5vIHZhbGlkYXRpb25cblxuICAgIHJldHVybiBzdGFja3M7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhlIHN0YWNrcyBmb3IgZXJyb3JzIGFuZCB3YXJuaW5ncyBhY2NvcmRpbmcgdG8gdGhlIENMSSdzIGN1cnJlbnQgc2V0dGluZ3NcbiAgICovXG4gIHByaXZhdGUgdmFsaWRhdGVTdGFja3Moc3RhY2tzOiBTdGFja0NvbGxlY3Rpb24pIHtcbiAgICBzdGFja3MucHJvY2Vzc01ldGFkYXRhTWVzc2FnZXMoe1xuICAgICAgaWdub3JlRXJyb3JzOiB0aGlzLnByb3BzLmlnbm9yZUVycm9ycyxcbiAgICAgIHN0cmljdDogdGhpcy5wcm9wcy5zdHJpY3QsXG4gICAgICB2ZXJib3NlOiB0aGlzLnByb3BzLnZlcmJvc2UsXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhhdCBpZiBhIHVzZXIgc3BlY2lmaWVkIGEgc3RhY2sgbmFtZSB0aGVyZSBleGlzdHMgYXQgbGVhc3QgMSBzdGFjayBzZWxlY3RlZFxuICAgKi9cbiAgcHJpdmF0ZSB2YWxpZGF0ZVN0YWNrc1NlbGVjdGVkKHN0YWNrczogU3RhY2tDb2xsZWN0aW9uLCBzdGFja05hbWVzOiBzdHJpbmdbXSkge1xuICAgIGlmIChzdGFja05hbWVzLmxlbmd0aCAhPSAwICYmIHN0YWNrcy5zdGFja0NvdW50ID09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gc3RhY2tzIG1hdGNoIHRoZSBuYW1lKHMpICR7c3RhY2tOYW1lc31gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VsZWN0IGEgc2luZ2xlIHN0YWNrIGJ5IGl0cyBuYW1lXG4gICAqL1xuICBwcml2YXRlIGFzeW5jIHNlbGVjdFNpbmdsZVN0YWNrQnlOYW1lKHN0YWNrTmFtZTogc3RyaW5nKSB7XG4gICAgY29uc3QgYXNzZW1ibHkgPSBhd2FpdCB0aGlzLmFzc2VtYmx5KCk7XG5cbiAgICBjb25zdCBzdGFja3MgPSBhd2FpdCBhc3NlbWJseS5zZWxlY3RTdGFja3MoeyBwYXR0ZXJuczogW3N0YWNrTmFtZV0gfSwge1xuICAgICAgZXh0ZW5kOiBFeHRlbmRlZFN0YWNrU2VsZWN0aW9uLk5vbmUsXG4gICAgICBkZWZhdWx0QmVoYXZpb3I6IERlZmF1bHRTZWxlY3Rpb24uTm9uZSxcbiAgICB9KTtcblxuICAgIC8vIENvdWxkIGhhdmUgYmVlbiBhIGdsb2Igc28gY2hlY2sgdGhhdCB3ZSBldmFsdWF0ZWQgdG8gZXhhY3RseSBvbmVcbiAgICBpZiAoc3RhY2tzLnN0YWNrQ291bnQgPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoaXMgY29tbWFuZCByZXF1aXJlcyBleGFjdGx5IG9uZSBzdGFjayBhbmQgd2UgbWF0Y2hlZCBtb3JlIHRoYW4gb25lOiAke3N0YWNrcy5zdGFja0lkc31gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYXNzZW1ibHkuc3RhY2tCeUlkKHN0YWNrcy5maXJzdFN0YWNrLmlkKTtcbiAgfVxuXG4gIHByaXZhdGUgYXNzZW1ibHkoY2FjaGVDbG91ZEFzc2VtYmx5PzogYm9vbGVhbik6IFByb21pc2U8Q2xvdWRBc3NlbWJseT4ge1xuICAgIHJldHVybiB0aGlzLnByb3BzLmNsb3VkRXhlY3V0YWJsZS5zeW50aGVzaXplKGNhY2hlQ2xvdWRBc3NlbWJseSk7XG4gIH1cblxuICBwcml2YXRlIHBhdHRlcm5zQXJyYXlGb3JXYXRjaChwYXR0ZXJuczogc3RyaW5nIHwgc3RyaW5nW10gfCB1bmRlZmluZWQsIG9wdGlvbnM6IHsgcm9vdERpcjogc3RyaW5nLCByZXR1cm5Sb290RGlySWZFbXB0eTogYm9vbGVhbiB9KTogc3RyaW5nW10ge1xuICAgIGNvbnN0IHBhdHRlcm5zQXJyYXk6IHN0cmluZ1tdID0gcGF0dGVybnMgIT09IHVuZGVmaW5lZFxuICAgICAgPyAoQXJyYXkuaXNBcnJheShwYXR0ZXJucykgPyBwYXR0ZXJucyA6IFtwYXR0ZXJuc10pXG4gICAgICA6IFtdO1xuICAgIHJldHVybiBwYXR0ZXJuc0FycmF5Lmxlbmd0aCA+IDBcbiAgICAgID8gcGF0dGVybnNBcnJheVxuICAgICAgOiAob3B0aW9ucy5yZXR1cm5Sb290RGlySWZFbXB0eSA/IFtvcHRpb25zLnJvb3REaXJdIDogW10pO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBpbnZva2VEZXBsb3lGcm9tV2F0Y2gob3B0aW9uczogV2F0Y2hPcHRpb25zLCBjbG91ZFdhdGNoTG9nTW9uaXRvcj86IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAvLyAnd2F0Y2gnIGhhcyBkaWZmZXJlbnQgZGVmYXVsdHMgdGhhbiByZWd1bGFyICdkZXBsb3knXG4gICAgY29uc3QgaG90c3dhcCA9IG9wdGlvbnMuaG90c3dhcCA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IG9wdGlvbnMuaG90c3dhcDtcbiAgICBjb25zdCBkZXBsb3lPcHRpb25zOiBEZXBsb3lPcHRpb25zID0ge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIHJlcXVpcmVBcHByb3ZhbDogUmVxdWlyZUFwcHJvdmFsLk5ldmVyLFxuICAgICAgLy8gaWYgJ3dhdGNoJyBpcyBjYWxsZWQgYnkgaW52b2tpbmcgJ2NkayBkZXBsb3kgLS13YXRjaCcsXG4gICAgICAvLyB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0byBub3QgY2FsbCAnZGVwbG95JyB3aXRoICd3YXRjaCcgYWdhaW4sXG4gICAgICAvLyBhcyB0aGF0IHdvdWxkIGxlYWQgdG8gYSBjeWNsZVxuICAgICAgd2F0Y2g6IGZhbHNlLFxuICAgICAgY2xvdWRXYXRjaExvZ01vbml0b3IsXG4gICAgICBjYWNoZUNsb3VkQXNzZW1ibHk6IGZhbHNlLFxuICAgICAgaG90c3dhcDogaG90c3dhcCxcbiAgICAgIGV4dHJhVXNlckFnZW50OiBgY2RrLXdhdGNoL2hvdHN3YXAtJHtob3Rzd2FwID8gJ29uJyA6ICdvZmYnfWAsXG4gICAgfTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmRlcGxveShkZXBsb3lPcHRpb25zKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAvLyBqdXN0IGNvbnRpbnVlIC0gZGVwbG95IHdpbGwgc2hvdyB0aGUgZXJyb3JcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBEaWZmT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTdGFjayBuYW1lcyB0byBkaWZmXG4gICAqL1xuICBzdGFja05hbWVzOiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogT25seSBzZWxlY3QgdGhlIGdpdmVuIHN0YWNrXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBleGNsdXNpdmVseT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFVzZWQgYSB0ZW1wbGF0ZSBmcm9tIGRpc2sgaW5zdGVhZCBvZiBmcm9tIHRoZSBzZXJ2ZXJcbiAgICpcbiAgICogQGRlZmF1bHQgVXNlIGZyb20gdGhlIHNlcnZlclxuICAgKi9cbiAgdGVtcGxhdGVQYXRoPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTdHJpY3QgZGlmZiBtb2RlXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBzdHJpY3Q/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBIb3cgbWFueSBsaW5lcyBvZiBjb250ZXh0IHRvIHNob3cgaW4gdGhlIGRpZmZcbiAgICpcbiAgICogQGRlZmF1bHQgM1xuICAgKi9cbiAgY29udGV4dExpbmVzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBXaGVyZSB0byB3cml0ZSB0aGUgZGVmYXVsdFxuICAgKlxuICAgKiBAZGVmYXVsdCBzdGRlcnJcbiAgICovXG4gIHN0cmVhbT86IE5vZGVKUy5Xcml0YWJsZVN0cmVhbTtcblxuICAvKipcbiAgICogV2hldGhlciB0byBmYWlsIHdpdGggZXhpdCBjb2RlIDEgaW4gY2FzZSBvZiBkaWZmXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBmYWlsPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT25seSBydW4gZGlmZiBvbiBicm9hZGVuZWQgc2VjdXJpdHkgY2hhbmdlc1xuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgc2VjdXJpdHlPbmx5PzogYm9vbGVhbjtcbn1cblxuaW50ZXJmYWNlIFdhdGNoT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBDcml0ZXJpYSBmb3Igc2VsZWN0aW5nIHN0YWNrcyB0byBkZXBsb3lcbiAgICovXG4gIHNlbGVjdG9yOiBTdGFja1NlbGVjdG9yO1xuXG4gIC8qKlxuICAgKiBPbmx5IHNlbGVjdCB0aGUgZ2l2ZW4gc3RhY2tcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGV4Y2x1c2l2ZWx5PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgdG9vbGtpdCBzdGFjayB0byB1c2UvZGVwbG95XG4gICAqXG4gICAqIEBkZWZhdWx0IENES1Rvb2xraXRcbiAgICovXG4gIHRvb2xraXRTdGFja05hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFJvbGUgdG8gcGFzcyB0byBDbG91ZEZvcm1hdGlvbiBmb3IgZGVwbG95bWVudFxuICAgKi9cbiAgcm9sZUFybj86IHN0cmluZztcblxuICAvKipcbiAgICogUmV1c2UgdGhlIGFzc2V0cyB3aXRoIHRoZSBnaXZlbiBhc3NldCBJRHNcbiAgICovXG4gIHJldXNlQXNzZXRzPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIG5hbWUgdG8gdXNlIGZvciB0aGUgQ2xvdWRGb3JtYXRpb24gY2hhbmdlIHNldC5cbiAgICogSWYgbm90IHByb3ZpZGVkLCBhIG5hbWUgd2lsbCBiZSBnZW5lcmF0ZWQgYXV0b21hdGljYWxseS5cbiAgICovXG4gIGNoYW5nZVNldE5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFsd2F5cyBkZXBsb3ksIGV2ZW4gaWYgdGVtcGxhdGVzIGFyZSBpZGVudGljYWwuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBmb3JjZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgbW9kZSBmb3Igc3RhY2sgZGVwbG95bWVudCBwcm9ncmVzcy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuQmFyIC0gc3RhY2sgZXZlbnRzIHdpbGwgYmUgZGlzcGxheWVkIGZvclxuICAgKiAgIHRoZSByZXNvdXJjZSBjdXJyZW50bHkgYmVpbmcgZGVwbG95ZWQuXG4gICAqL1xuICBwcm9ncmVzcz86IFN0YWNrQWN0aXZpdHlQcm9ncmVzcztcblxuICAvKipcbiAgICogUm9sbGJhY2sgZmFpbGVkIGRlcGxveW1lbnRzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHJvbGxiYWNrPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBwZXJmb3JtIGEgJ2hvdHN3YXAnIGRlcGxveW1lbnQuXG4gICAqIEEgJ2hvdHN3YXAnIGRlcGxveW1lbnQgd2lsbCBhdHRlbXB0IHRvIHNob3J0LWNpcmN1aXQgQ2xvdWRGb3JtYXRpb25cbiAgICogYW5kIHVwZGF0ZSB0aGUgYWZmZWN0ZWQgcmVzb3VyY2VzIGxpa2UgTGFtYmRhIGZ1bmN0aW9ucyBkaXJlY3RseS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBmYWxzZSBmb3IgcmVndWxhciBkZXBsb3ltZW50cywgdHJ1ZSBmb3IgJ3dhdGNoJyBkZXBsb3ltZW50c1xuICAgKi9cbiAgcmVhZG9ubHkgaG90c3dhcD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFRoZSBleHRyYSBzdHJpbmcgdG8gYXBwZW5kIHRvIHRoZSBVc2VyLUFnZW50IGhlYWRlciB3aGVuIHBlcmZvcm1pbmcgQVdTIFNESyBjYWxscy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBub3RoaW5nIGV4dHJhIGlzIGFwcGVuZGVkIHRvIHRoZSBVc2VyLUFnZW50IGhlYWRlclxuICAgKi9cbiAgcmVhZG9ubHkgZXh0cmFVc2VyQWdlbnQ/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2hvdyBDbG91ZFdhdGNoIGxvZ3MgZm9yIGhvdHN3YXBwZWQgcmVzb3VyY2VzXG4gICAqIGxvY2FsbHkgaW4gdGhlIHVzZXJzIHRlcm1pbmFsXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHRyYWNlTG9ncz86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwbG95T3B0aW9ucyBleHRlbmRzIFdhdGNoT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBBUk5zIG9mIFNOUyB0b3BpY3MgdGhhdCBDbG91ZEZvcm1hdGlvbiB3aWxsIG5vdGlmeSB3aXRoIHN0YWNrIHJlbGF0ZWQgZXZlbnRzXG4gICAqL1xuICBub3RpZmljYXRpb25Bcm5zPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIFdoYXQga2luZCBvZiBzZWN1cml0eSBjaGFuZ2VzIHJlcXVpcmUgYXBwcm92YWxcbiAgICpcbiAgICogQGRlZmF1bHQgUmVxdWlyZUFwcHJvdmFsLkJyb2FkZW5pbmdcbiAgICovXG4gIHJlcXVpcmVBcHByb3ZhbD86IFJlcXVpcmVBcHByb3ZhbDtcblxuICAvKipcbiAgICogVGFncyB0byBwYXNzIHRvIENsb3VkRm9ybWF0aW9uIGZvciBkZXBsb3ltZW50XG4gICAqL1xuICB0YWdzPzogVGFnW107XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZXhlY3V0ZSB0aGUgQ2hhbmdlU2V0XG4gICAqIE5vdCBwcm92aWRpbmcgYGV4ZWN1dGVgIHBhcmFtZXRlciB3aWxsIHJlc3VsdCBpbiBleGVjdXRpb24gb2YgQ2hhbmdlU2V0XG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIGV4ZWN1dGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIENsb3VkRm9ybWF0aW9uIGF0IGRlcGxveSB0aW1lXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBwYXJhbWV0ZXJzPzogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG5cbiAgLyoqXG4gICAqIFVzZSBwcmV2aW91cyB2YWx1ZXMgZm9yIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogSWYgbm90IHNldCwgYWxsIHBhcmFtZXRlcnMgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIGV2ZXJ5IGRlcGxveW1lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHVzZVByZXZpb3VzUGFyYW1ldGVycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFBhdGggdG8gZmlsZSB3aGVyZSBzdGFjayBvdXRwdXRzIHdpbGwgYmUgd3JpdHRlbiBhZnRlciBhIHN1Y2Nlc3NmdWwgZGVwbG95IGFzIEpTT05cbiAgICogQGRlZmF1bHQgLSBPdXRwdXRzIGFyZSBub3Qgd3JpdHRlbiB0byBhbnkgZmlsZVxuICAgKi9cbiAgb3V0cHV0c0ZpbGU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2UgYXJlIG9uIGEgQ0kgc3lzdGVtXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBjaT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhpcyAnZGVwbG95JyBjb21tYW5kIHNob3VsZCBhY3R1YWxseSBkZWxlZ2F0ZSB0byB0aGUgJ3dhdGNoJyBjb21tYW5kLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgd2F0Y2g/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHdlIHNob3VsZCBjYWNoZSB0aGUgQ2xvdWQgQXNzZW1ibHkgYWZ0ZXIgdGhlIGZpcnN0IHRpbWUgaXQgaGFzIGJlZW4gc3ludGhlc2l6ZWQuXG4gICAqIFRoZSBkZWZhdWx0IGlzICd0cnVlJywgd2Ugb25seSBkb24ndCB3YW50IHRvIGRvIGl0IGluIGNhc2UgdGhlIGRlcGxveW1lbnQgaXMgdHJpZ2dlcmVkIGJ5XG4gICAqICdjZGsgd2F0Y2gnLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBjYWNoZUNsb3VkQXNzZW1ibHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBbGxvd3MgYWRkaW5nIENsb3VkV2F0Y2ggbG9nIGdyb3VwcyB0byB0aGUgbG9nIG1vbml0b3IgdmlhXG4gICAqIGNsb3VkV2F0Y2hMb2dNb25pdG9yLnNldExvZ0dyb3VwcygpO1xuICAgKlxuICAgKiBAZGVmYXVsdCAtIG5vdCBtb25pdG9yaW5nIENsb3VkV2F0Y2ggbG9nc1xuICAgKi9cbiAgcmVhZG9ubHkgY2xvdWRXYXRjaExvZ01vbml0b3I/OiBDbG91ZFdhdGNoTG9nRXZlbnRNb25pdG9yO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlc3Ryb3lPcHRpb25zIHtcbiAgLyoqXG4gICAqIENyaXRlcmlhIGZvciBzZWxlY3Rpbmcgc3RhY2tzIHRvIGRlcGxveVxuICAgKi9cbiAgc2VsZWN0b3I6IFN0YWNrU2VsZWN0b3I7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZXhjbHVkZSBzdGFja3MgdGhhdCBkZXBlbmQgb24gdGhlIHN0YWNrcyB0byBiZSBkZWxldGVkXG4gICAqL1xuICBleGNsdXNpdmVseTogYm9vbGVhbjtcblxuICAvKipcbiAgICogV2hldGhlciB0byBza2lwIHByb21wdGluZyBmb3IgY29uZmlybWF0aW9uXG4gICAqL1xuICBmb3JjZTogYm9vbGVhbjtcblxuICAvKipcbiAgICogVGhlIGFybiBvZiB0aGUgSUFNIHJvbGUgdG8gdXNlXG4gICAqL1xuICByb2xlQXJuPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBkZXN0cm95IHJlcXVlc3QgY2FtZSBmcm9tIGEgZGVwbG95LlxuICAgKi9cbiAgZnJvbURlcGxveT86IGJvb2xlYW5cbn1cblxuLyoqXG4gKiBAcmV0dXJucyBhbiBhcnJheSB3aXRoIHRoZSB0YWdzIGF2YWlsYWJsZSBpbiB0aGUgc3RhY2sgbWV0YWRhdGEuXG4gKi9cbmZ1bmN0aW9uIHRhZ3NGb3JTdGFjayhzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KTogVGFnW10ge1xuICByZXR1cm4gT2JqZWN0LmVudHJpZXMoc3RhY2sudGFncykubWFwKChbS2V5LCBWYWx1ZV0pID0+ICh7IEtleSwgVmFsdWUgfSkpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRhZyB7XG4gIHJlYWRvbmx5IEtleTogc3RyaW5nO1xuICByZWFkb25seSBWYWx1ZTogc3RyaW5nO1xufVxuXG4vKipcbiAqIEZvcm1hdHMgdGltZSBpbiBtaWxsaXNlY29uZHMgKHdoaWNoIHdlIGdldCBmcm9tICdEYXRlLmdldFRpbWUoKScpXG4gKiB0byBhIGh1bWFuLXJlYWRhYmxlIHRpbWU7IHJldHVybnMgdGltZSBpbiBzZWNvbmRzIHJvdW5kZWQgdG8gMlxuICogZGVjaW1hbCBwbGFjZXMuXG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFRpbWUobnVtOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gcm91bmRQZXJjZW50YWdlKG1pbGxpc2Vjb25kc1RvU2Vjb25kcyhudW0pKTtcbn1cblxuLyoqXG4gKiBSb3VuZHMgYSBkZWNpbWFsIG51bWJlciB0byB0d28gZGVjaW1hbCBwb2ludHMuXG4gKiBUaGUgZnVuY3Rpb24gaXMgdXNlZnVsIGZvciBmcmFjdGlvbnMgdGhhdCBuZWVkIHRvIGJlIG91dHB1dHRlZCBhcyBwZXJjZW50YWdlcy5cbiAqL1xuZnVuY3Rpb24gcm91bmRQZXJjZW50YWdlKG51bTogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIE1hdGgucm91bmQoMTAwICogbnVtKSAvIDEwMDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHRpbWUgaW4gbWlsaXNlY29uZHMsIHJldHVybiBhbiBlcXVpdmFsZW50IGFtb3VudCBpbiBzZWNvbmRzLlxuICovXG5mdW5jdGlvbiBtaWxsaXNlY29uZHNUb1NlY29uZHMobnVtOiBudW1iZXIpOiBudW1iZXIge1xuICByZXR1cm4gbnVtIC8gMTAwMDtcbn1cbiJdfQ==