"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withMocked = exports.withMockedClassSingleton = exports.instanceMockFrom = exports.testStack = exports.testAssembly = exports.MockCloudExecutable = exports.DEFAULT_FAKE_TEMPLATE = void 0;
const fs = require("fs");
const path = require("path");
const cxschema = require("@aws-cdk/cloud-assembly-schema");
const cxapi = require("@aws-cdk/cx-api");
const cloud_executable_1 = require("../lib/api/cxapp/cloud-executable");
const settings_1 = require("../lib/settings");
const mock_sdk_1 = require("./util/mock-sdk");
exports.DEFAULT_FAKE_TEMPLATE = { No: 'Resources' };
class MockCloudExecutable extends cloud_executable_1.CloudExecutable {
    constructor(assembly) {
        const configuration = new settings_1.Configuration();
        const sdkProvider = new mock_sdk_1.MockSdkProvider();
        super({
            configuration,
            sdkProvider,
            synthesizer: () => Promise.resolve(testAssembly(assembly)),
        });
        this.configuration = configuration;
        this.sdkProvider = sdkProvider;
    }
}
exports.MockCloudExecutable = MockCloudExecutable;
function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}
function addAttributes(assembly, builder) {
    var _a;
    for (const stack of assembly.stacks) {
        const templateFile = `${stack.stackName}.template.json`;
        const template = (_a = stack.template) !== null && _a !== void 0 ? _a : exports.DEFAULT_FAKE_TEMPLATE;
        fs.writeFileSync(path.join(builder.outdir, templateFile), JSON.stringify(template, undefined, 2));
        addNestedStacks(templateFile, builder.outdir, template);
        // we call patchStackTags here to simulate the tags formatter
        // that is used when building real manifest files.
        const metadata = patchStackTags({ ...stack.metadata });
        for (const asset of stack.assets || []) {
            metadata[asset.id] = [
                { type: cxschema.ArtifactMetadataEntryType.ASSET, data: asset },
            ];
        }
        for (const missing of assembly.missing || []) {
            builder.addMissing(missing);
        }
        builder.addArtifact(stack.stackName, {
            type: cxschema.ArtifactType.AWS_CLOUDFORMATION_STACK,
            environment: stack.env || 'aws://123456789012/here',
            dependencies: stack.depends,
            metadata,
            properties: {
                ...stack.properties,
                templateFile,
                terminationProtection: stack.terminationProtection,
            },
            displayName: stack.displayName,
        });
    }
}
function addNestedStacks(templatePath, outdir, rootStackTemplate) {
    let template = rootStackTemplate;
    if (!template) {
        const templatePathWithDir = path.join('nested-stack-templates', templatePath);
        template = JSON.parse(fs.readFileSync(path.join(__dirname, templatePathWithDir)).toString());
        fs.writeFileSync(path.join(outdir, templatePath), JSON.stringify(template, undefined, 2));
    }
    for (const logicalId in template.Resources) {
        if (template.Resources[logicalId].Type === 'AWS::CloudFormation::Stack') {
            if (template.Resources[logicalId].Metadata && template.Resources[logicalId].Metadata['aws:asset:path']) {
                const nestedTemplatePath = template.Resources[logicalId].Metadata['aws:asset:path'];
                addNestedStacks(nestedTemplatePath, outdir);
            }
        }
    }
}
function testAssembly(assembly) {
    var _a;
    const builder = new cxapi.CloudAssemblyBuilder();
    addAttributes(assembly, builder);
    if (assembly.nestedAssemblies != null && assembly.nestedAssemblies.length > 0) {
        (_a = assembly.nestedAssemblies) === null || _a === void 0 ? void 0 : _a.forEach((nestedAssembly, i) => {
            const nestedAssemblyBuilder = builder.createNestedAssembly(`nested${i}`, `nested${i}`);
            addAttributes(nestedAssembly, nestedAssemblyBuilder);
            nestedAssemblyBuilder.buildAssembly();
        });
    }
    return builder.buildAssembly();
}
exports.testAssembly = testAssembly;
/**
 * Transform stack tags from how they are decalred in source code (lower cased)
 * to how they are stored on disk (upper cased). In real synthesis this is done
 * by a special tags formatter.
 *
 * @see @aws-cdk/core/lib/stack.ts
 */
function patchStackTags(metadata) {
    const cloned = clone(metadata);
    for (const metadataEntries of Object.values(cloned)) {
        for (const metadataEntry of metadataEntries) {
            if (metadataEntry.type === cxschema.ArtifactMetadataEntryType.STACK_TAGS && metadataEntry.data) {
                const metadataAny = metadataEntry;
                metadataAny.data = metadataAny.data.map((t) => {
                    return { Key: t.key, Value: t.value };
                });
            }
        }
    }
    return cloned;
}
function testStack(stack) {
    const assembly = testAssembly({ stacks: [stack] });
    return assembly.getStackByName(stack.stackName);
}
exports.testStack = testStack;
/**
 * Return a mocked instance of a class, given its constructor
 *
 * I don't understand why jest doesn't provide this by default,
 * but there you go.
 *
 * FIXME: Currently very limited. Doesn't support inheritance, getters or
 * automatic detection of properties (as those exist on instances, not
 * classes).
 */
function instanceMockFrom(ctr) {
    const ret = {};
    for (const methodName of Object.getOwnPropertyNames(ctr.prototype)) {
        ret[methodName] = jest.fn();
    }
    return ret;
}
exports.instanceMockFrom = instanceMockFrom;
/**
 * Run an async block with a class (constructor) replaced with a mock
 *
 * The class constructor will be replaced with a constructor that returns
 * a singleton, and the singleton will be passed to the block so that its
 * methods can be mocked individually.
 *
 * Uses `instanceMockFrom` so is subject to the same limitations that hold
 * for that function.
 */
async function withMockedClassSingleton(obj, key, cb) {
    const original = obj[key];
    try {
        const mock = instanceMockFrom(original);
        obj[key] = jest.fn().mockReturnValue(mock);
        const ret = await cb(mock);
        return ret;
    }
    finally {
        obj[key] = original;
    }
}
exports.withMockedClassSingleton = withMockedClassSingleton;
function withMocked(obj, key, block) {
    const original = obj[key];
    const mockFn = jest.fn();
    obj[key] = mockFn;
    let asyncFinally = false;
    try {
        const ret = block(mockFn);
        if (!isPromise(ret)) {
            return ret;
        }
        asyncFinally = true;
        return ret.finally(() => { obj[key] = original; });
    }
    finally {
        if (!asyncFinally) {
            obj[key] = original;
        }
    }
}
exports.withMocked = withMocked;
function isPromise(object) {
    return Promise.resolve(object) === object;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInV0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QiwyREFBMkQ7QUFDM0QseUNBQXlDO0FBQ3pDLHdFQUFvRTtBQUNwRSw4Q0FBZ0Q7QUFDaEQsOENBQWtEO0FBRXJDLFFBQUEscUJBQXFCLEdBQUcsRUFBRSxFQUFFLEVBQUUsV0FBVyxFQUFFLENBQUM7QUFvQnpELE1BQWEsbUJBQW9CLFNBQVEsa0NBQWU7SUFJdEQsWUFBWSxRQUFzQjtRQUNoQyxNQUFNLGFBQWEsR0FBRyxJQUFJLHdCQUFhLEVBQUUsQ0FBQztRQUMxQyxNQUFNLFdBQVcsR0FBRyxJQUFJLDBCQUFlLEVBQUUsQ0FBQztRQUUxQyxLQUFLLENBQUM7WUFDSixhQUFhO1lBQ2IsV0FBVztZQUNYLFdBQVcsRUFBRSxHQUFHLEVBQUUsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztTQUMzRCxDQUFDLENBQUM7UUFFSCxJQUFJLENBQUMsYUFBYSxHQUFHLGFBQWEsQ0FBQztRQUNuQyxJQUFJLENBQUMsV0FBVyxHQUFHLFdBQVcsQ0FBQztJQUNqQyxDQUFDO0NBQ0Y7QUFqQkQsa0RBaUJDO0FBRUQsU0FBUyxLQUFLLENBQUMsR0FBUTtJQUNyQixPQUFPLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRCxTQUFTLGFBQWEsQ0FBQyxRQUFzQixFQUFFLE9BQW1DOztJQUNoRixLQUFLLE1BQU0sS0FBSyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEVBQUU7UUFDbkMsTUFBTSxZQUFZLEdBQUcsR0FBRyxLQUFLLENBQUMsU0FBUyxnQkFBZ0IsQ0FBQztRQUN4RCxNQUFNLFFBQVEsU0FBRyxLQUFLLENBQUMsUUFBUSxtQ0FBSSw2QkFBcUIsQ0FBQztRQUN6RCxF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LENBQUM7S0FDckI7QUFDSCxDQUFDO0FBZkQsNERBZUM7QUFFRCxTQUFnQixVQUFVLENBQXlDLEdBQU0sRUFBRSxHQUFNLEVBQUUsS0FBbUM7SUFDcEgsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0lBQzFCLE1BQU0sTUFBTSxHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUN4QixHQUFXLENBQUMsR0FBRyxDQUFDLEdBQUcsTUFBTSxDQUFDO0lBRTNCLElBQUksWUFBWSxHQUFZLEtBQUssQ0FBQztJQUNsQyxJQUFJO1FBQ0YsTUFBTSxHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQWEsQ0FBQyxDQUFDO1FBQ2pDLElBQUksQ0FBQyxTQUFTLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFBRSxPQUFPLEdBQUcsQ0FBQztTQUFFO1FBRXBDLFlBQVksR0FBRyxJQUFJLENBQUM7UUFDcEIsT0FBTyxHQUFHLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQVEsQ0FBQztLQUMzRDtZQUFTO1FBQ1IsSUFBSSxDQUFDLFlBQVksRUFBRTtZQUNqQixHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUcsUUFBUSxDQUFDO1NBQ3JCO0tBQ0Y7QUFDSCxDQUFDO0FBakJELGdDQWlCQztBQUVELFNBQVMsU0FBUyxDQUFJLE1BQVc7SUFDL0IsT0FBTyxPQUFPLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLE1BQU0sQ0FBQztBQUM1QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tICdwYXRoJztcbmltcG9ydCAqIGFzIGN4c2NoZW1hIGZyb20gJ0Bhd3MtY2RrL2Nsb3VkLWFzc2VtYmx5LXNjaGVtYSc7XG5pbXBvcnQgKiBhcyBjeGFwaSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0IHsgQ2xvdWRFeGVjdXRhYmxlIH0gZnJvbSAnLi4vbGliL2FwaS9jeGFwcC9jbG91ZC1leGVjdXRhYmxlJztcbmltcG9ydCB7IENvbmZpZ3VyYXRpb24gfSBmcm9tICcuLi9saWIvc2V0dGluZ3MnO1xuaW1wb3J0IHsgTW9ja1Nka1Byb3ZpZGVyIH0gZnJvbSAnLi91dGlsL21vY2stc2RrJztcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRkFLRV9URU1QTEFURSA9IHsgTm86ICdSZXNvdXJjZXMnIH07XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGVzdFN0YWNrQXJ0aWZhY3Qge1xuICBzdGFja05hbWU6IHN0cmluZztcbiAgdGVtcGxhdGU/OiBhbnk7XG4gIGVudj86IHN0cmluZyxcbiAgZGVwZW5kcz86IHN0cmluZ1tdO1xuICBtZXRhZGF0YT86IGN4YXBpLlN0YWNrTWV0YWRhdGE7XG4gIGFzc2V0cz86IGN4c2NoZW1hLkFzc2V0TWV0YWRhdGFFbnRyeVtdO1xuICBwcm9wZXJ0aWVzPzogUGFydGlhbDxjeHNjaGVtYS5Bd3NDbG91ZEZvcm1hdGlvblN0YWNrUHJvcGVydGllcz47XG4gIHRlcm1pbmF0aW9uUHJvdGVjdGlvbj86IGJvb2xlYW47XG4gIGRpc3BsYXlOYW1lPzogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRlc3RBc3NlbWJseSB7XG4gIHN0YWNrczogVGVzdFN0YWNrQXJ0aWZhY3RbXTtcbiAgbWlzc2luZz86IGN4c2NoZW1hLk1pc3NpbmdDb250ZXh0W107XG4gIG5lc3RlZEFzc2VtYmxpZXM/OiBUZXN0QXNzZW1ibHlbXTtcbn1cblxuZXhwb3J0IGNsYXNzIE1vY2tDbG91ZEV4ZWN1dGFibGUgZXh0ZW5kcyBDbG91ZEV4ZWN1dGFibGUge1xuICBwdWJsaWMgcmVhZG9ubHkgY29uZmlndXJhdGlvbjogQ29uZmlndXJhdGlvbjtcbiAgcHVibGljIHJlYWRvbmx5IHNka1Byb3ZpZGVyOiBNb2NrU2RrUHJvdmlkZXI7XG5cbiAgY29uc3RydWN0b3IoYXNzZW1ibHk6IFRlc3RBc3NlbWJseSkge1xuICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBuZXcgQ29uZmlndXJhdGlvbigpO1xuICAgIGNvbnN0IHNka1Byb3ZpZGVyID0gbmV3IE1vY2tTZGtQcm92aWRlcigpO1xuXG4gICAgc3VwZXIoe1xuICAgICAgY29uZmlndXJhdGlvbixcbiAgICAgIHNka1Byb3ZpZGVyLFxuICAgICAgc3ludGhlc2l6ZXI6ICgpID0+IFByb21pc2UucmVzb2x2ZSh0ZXN0QXNzZW1ibHkoYXNzZW1ibHkpKSxcbiAgICB9KTtcblxuICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IGNvbmZpZ3VyYXRpb247XG4gICAgdGhpcy5zZGtQcm92aWRlciA9IHNka1Byb3ZpZGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNsb25lKG9iajogYW55KSB7XG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaikpO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyaWJ1dGVzKGFzc2VtYmx5OiBUZXN0QXNzZW1ibHksIGJ1aWxkZXI6IGN4YXBpLkNsb3VkQXNzZW1ibHlCdWlsZGVyKSB7XG4gIGZvciAoY29uc3Qgc3RhY2sgb2YgYXNzZW1ibHkuc3RhY2tzKSB7XG4gICAgY29uc3QgdGVtcGxhdGVGaWxlID0gYCR7c3RhY2suc3RhY2tOYW1lfS50ZW1wbGF0ZS5qc29uYDtcbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHN0YWNrLnRlbXBsYXRlID8/IERFRkFVTFRfRkFLRV9URU1QTEFURTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihidWlsZGVyLm91dGRpciwgdGVtcGxhdGVGaWxlKSwgSlNPTi5zdHJpbmdpZnkodGVtcGxhdGUsIHVuZGVmaW5lZCwgMikpO1xuICAgIGFkZE5lc3RlZFN0YWNrcyh0ZW1wbGF0ZUZpbGUsIGJ1aWxkZXIub3V0ZGlyLCB0ZW1wbGF0ZSk7XG5cbiAgICAvLyB3ZSBjYWxsIHBhdGNoU3RhY2tUYWdzIGhlcmUgdG8gc2ltdWxhdGUgdGhlIHRhZ3MgZm9ybWF0dGVyXG4gICAgLy8gdGhhdCBpcyB1c2VkIHdoZW4gYnVpbGRpbmcgcmVhbCBtYW5pZmVzdCBmaWxlcy5cbiAgICBjb25zdCBtZXRhZGF0YTogeyBbcGF0aDogc3RyaW5nXTogY3hzY2hlbWEuTWV0YWRhdGFFbnRyeVtdIH0gPSBwYXRjaFN0YWNrVGFncyh7IC4uLnN0YWNrLm1ldGFkYXRhIH0pO1xuICAgIGZvciAoY29uc3QgYXNzZXQgb2Ygc3RhY2suYXNzZXRzIHx8IFtdKSB7XG4gICAgICBtZXRhZGF0YVthc3NldC5pZF0gPSBbXG4gICAgICAgIHsgdHlwZTogY3hzY2hlbWEuQXJ0aWZhY3RNZXRhZGF0YUVudHJ5VHlwZS5BU1NFVCwgZGF0YTogYXNzZXQgfSxcbiAgICAgIF07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBtaXNzaW5nIG9mIGFzc2VtYmx5Lm1pc3NpbmcgfHwgW10pIHtcbiAgICAgIGJ1aWxkZXIuYWRkTWlzc2luZyhtaXNzaW5nKTtcbiAgICB9XG5cbiAgICBidWlsZGVyLmFkZEFydGlmYWN0KHN0YWNrLnN0YWNrTmFtZSwge1xuICAgICAgdHlwZTogY3hzY2hlbWEuQXJ0aWZhY3RUeXBlLkFXU19DTE9VREZPUk1BVElPTl9TVEFDSyxcbiAgICAgIGVudmlyb25tZW50OiBzdGFjay5lbnYgfHwgJ2F3czovLzEyMzQ1Njc4OTAxMi9oZXJlJyxcblxuICAgICAgZGVwZW5kZW5jaWVzOiBzdGFjay5kZXBlbmRzLFxuICAgICAgbWV0YWRhdGEsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIC4uLnN0YWNrLnByb3BlcnRpZXMsXG4gICAgICAgIHRlbXBsYXRlRmlsZSxcbiAgICAgICAgdGVybWluYXRpb25Qcm90ZWN0aW9uOiBzdGFjay50ZXJtaW5hdGlvblByb3RlY3Rpb24sXG4gICAgICB9LFxuICAgICAgZGlzcGxheU5hbWU6IHN0YWNrLmRpc3BsYXlOYW1lLFxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZE5lc3RlZFN0YWNrcyh0ZW1wbGF0ZVBhdGg6IHN0cmluZywgb3V0ZGlyOiBzdHJpbmcsIHJvb3RTdGFja1RlbXBsYXRlPzogYW55KSB7XG4gIGxldCB0ZW1wbGF0ZSA9IHJvb3RTdGFja1RlbXBsYXRlO1xuXG4gIGlmICghdGVtcGxhdGUpIHtcbiAgICBjb25zdCB0ZW1wbGF0ZVBhdGhXaXRoRGlyID0gcGF0aC5qb2luKCduZXN0ZWQtc3RhY2stdGVtcGxhdGVzJywgdGVtcGxhdGVQYXRoKTtcbiAgICB0ZW1wbGF0ZSA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKHBhdGguam9pbihfX2Rpcm5hbWUsIHRlbXBsYXRlUGF0aFdpdGhEaXIpKS50b1N0cmluZygpKTtcbiAgICBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihvdXRkaXIsIHRlbXBsYXRlUGF0aCksIEpTT04uc3RyaW5naWZ5KHRlbXBsYXRlLCB1bmRlZmluZWQsIDIpKTtcbiAgfVxuXG4gIGZvciAoY29uc3QgbG9naWNhbElkIGluIHRlbXBsYXRlLlJlc291cmNlcykge1xuICAgIGlmICh0ZW1wbGF0ZS5SZXNvdXJjZXNbbG9naWNhbElkXS5UeXBlID09PSAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snKSB7XG4gICAgICBpZiAodGVtcGxhdGUuUmVzb3VyY2VzW2xvZ2ljYWxJZF0uTWV0YWRhdGEgJiYgdGVtcGxhdGUuUmVzb3VyY2VzW2xvZ2ljYWxJZF0uTWV0YWRhdGFbJ2F3czphc3NldDpwYXRoJ10pIHtcbiAgICAgICAgY29uc3QgbmVzdGVkVGVtcGxhdGVQYXRoID0gdGVtcGxhdGUuUmVzb3VyY2VzW2xvZ2ljYWxJZF0uTWV0YWRhdGFbJ2F3czphc3NldDpwYXRoJ107XG4gICAgICAgIGFkZE5lc3RlZFN0YWNrcyhuZXN0ZWRUZW1wbGF0ZVBhdGgsIG91dGRpcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0ZXN0QXNzZW1ibHkoYXNzZW1ibHk6IFRlc3RBc3NlbWJseSk6IGN4YXBpLkNsb3VkQXNzZW1ibHkge1xuICBjb25zdCBidWlsZGVyID0gbmV3IGN4YXBpLkNsb3VkQXNzZW1ibHlCdWlsZGVyKCk7XG4gIGFkZEF0dHJpYnV0ZXMoYXNzZW1ibHksIGJ1aWxkZXIpO1xuXG4gIGlmIChhc3NlbWJseS5uZXN0ZWRBc3NlbWJsaWVzICE9IG51bGwgJiYgYXNzZW1ibHkubmVzdGVkQXNzZW1ibGllcy5sZW5ndGggPiAwKSB7XG4gICAgYXNzZW1ibHkubmVzdGVkQXNzZW1ibGllcz8uZm9yRWFjaCgobmVzdGVkQXNzZW1ibHk6IFRlc3RBc3NlbWJseSwgaTogbnVtYmVyKSA9PiB7XG4gICAgICBjb25zdCBuZXN0ZWRBc3NlbWJseUJ1aWxkZXIgPSBidWlsZGVyLmNyZWF0ZU5lc3RlZEFzc2VtYmx5KGBuZXN0ZWQke2l9YCwgYG5lc3RlZCR7aX1gKTtcbiAgICAgIGFkZEF0dHJpYnV0ZXMobmVzdGVkQXNzZW1ibHksIG5lc3RlZEFzc2VtYmx5QnVpbGRlcik7XG4gICAgICBuZXN0ZWRBc3NlbWJseUJ1aWxkZXIuYnVpbGRBc3NlbWJseSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGJ1aWxkZXIuYnVpbGRBc3NlbWJseSgpO1xufVxuXG4vKipcbiAqIFRyYW5zZm9ybSBzdGFjayB0YWdzIGZyb20gaG93IHRoZXkgYXJlIGRlY2FscmVkIGluIHNvdXJjZSBjb2RlIChsb3dlciBjYXNlZClcbiAqIHRvIGhvdyB0aGV5IGFyZSBzdG9yZWQgb24gZGlzayAodXBwZXIgY2FzZWQpLiBJbiByZWFsIHN5bnRoZXNpcyB0aGlzIGlzIGRvbmVcbiAqIGJ5IGEgc3BlY2lhbCB0YWdzIGZvcm1hdHRlci5cbiAqXG4gKiBAc2VlIEBhd3MtY2RrL2NvcmUvbGliL3N0YWNrLnRzXG4gKi9cbmZ1bmN0aW9uIHBhdGNoU3RhY2tUYWdzKG1ldGFkYXRhOiB7IFtwYXRoOiBzdHJpbmddOiBjeHNjaGVtYS5NZXRhZGF0YUVudHJ5W10gfSk6IHsgW3BhdGg6IHN0cmluZ106IGN4c2NoZW1hLk1ldGFkYXRhRW50cnlbXSB9IHtcblxuICBjb25zdCBjbG9uZWQgPSBjbG9uZShtZXRhZGF0YSkgYXMgeyBbcGF0aDogc3RyaW5nXTogY3hzY2hlbWEuTWV0YWRhdGFFbnRyeVtdIH07XG5cbiAgZm9yIChjb25zdCBtZXRhZGF0YUVudHJpZXMgb2YgT2JqZWN0LnZhbHVlcyhjbG9uZWQpKSB7XG4gICAgZm9yIChjb25zdCBtZXRhZGF0YUVudHJ5IG9mIG1ldGFkYXRhRW50cmllcykge1xuICAgICAgaWYgKG1ldGFkYXRhRW50cnkudHlwZSA9PT0gY3hzY2hlbWEuQXJ0aWZhY3RNZXRhZGF0YUVudHJ5VHlwZS5TVEFDS19UQUdTICYmIG1ldGFkYXRhRW50cnkuZGF0YSkge1xuXG4gICAgICAgIGNvbnN0IG1ldGFkYXRhQW55ID0gbWV0YWRhdGFFbnRyeSBhcyBhbnk7XG5cbiAgICAgICAgbWV0YWRhdGFBbnkuZGF0YSA9IG1ldGFkYXRhQW55LmRhdGEubWFwKCh0OiBhbnkpID0+IHtcbiAgICAgICAgICByZXR1cm4geyBLZXk6IHQua2V5LCBWYWx1ZTogdC52YWx1ZSB9O1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNsb25lZDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRlc3RTdGFjayhzdGFjazogVGVzdFN0YWNrQXJ0aWZhY3QpOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Qge1xuICBjb25zdCBhc3NlbWJseSA9IHRlc3RBc3NlbWJseSh7IHN0YWNrczogW3N0YWNrXSB9KTtcbiAgcmV0dXJuIGFzc2VtYmx5LmdldFN0YWNrQnlOYW1lKHN0YWNrLnN0YWNrTmFtZSk7XG59XG5cbi8qKlxuICogUmV0dXJuIGEgbW9ja2VkIGluc3RhbmNlIG9mIGEgY2xhc3MsIGdpdmVuIGl0cyBjb25zdHJ1Y3RvclxuICpcbiAqIEkgZG9uJ3QgdW5kZXJzdGFuZCB3aHkgamVzdCBkb2Vzbid0IHByb3ZpZGUgdGhpcyBieSBkZWZhdWx0LFxuICogYnV0IHRoZXJlIHlvdSBnby5cbiAqXG4gKiBGSVhNRTogQ3VycmVudGx5IHZlcnkgbGltaXRlZC4gRG9lc24ndCBzdXBwb3J0IGluaGVyaXRhbmNlLCBnZXR0ZXJzIG9yXG4gKiBhdXRvbWF0aWMgZGV0ZWN0aW9uIG9mIHByb3BlcnRpZXMgKGFzIHRob3NlIGV4aXN0IG9uIGluc3RhbmNlcywgbm90XG4gKiBjbGFzc2VzKS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGluc3RhbmNlTW9ja0Zyb208QT4oY3RyOiBuZXcgKC4uLmFyZ3M6IGFueVtdKSA9PiBBKTogamVzdC5Nb2NrZWQ8QT4ge1xuICBjb25zdCByZXQ6IGFueSA9IHt9O1xuICBmb3IgKGNvbnN0IG1ldGhvZE5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoY3RyLnByb3RvdHlwZSkpIHtcbiAgICByZXRbbWV0aG9kTmFtZV0gPSBqZXN0LmZuKCk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBSdW4gYW4gYXN5bmMgYmxvY2sgd2l0aCBhIGNsYXNzIChjb25zdHJ1Y3RvcikgcmVwbGFjZWQgd2l0aCBhIG1vY2tcbiAqXG4gKiBUaGUgY2xhc3MgY29uc3RydWN0b3Igd2lsbCBiZSByZXBsYWNlZCB3aXRoIGEgY29uc3RydWN0b3IgdGhhdCByZXR1cm5zXG4gKiBhIHNpbmdsZXRvbiwgYW5kIHRoZSBzaW5nbGV0b24gd2lsbCBiZSBwYXNzZWQgdG8gdGhlIGJsb2NrIHNvIHRoYXQgaXRzXG4gKiBtZXRob2RzIGNhbiBiZSBtb2NrZWQgaW5kaXZpZHVhbGx5LlxuICpcbiAqIFVzZXMgYGluc3RhbmNlTW9ja0Zyb21gIHNvIGlzIHN1YmplY3QgdG8gdGhlIHNhbWUgbGltaXRhdGlvbnMgdGhhdCBob2xkXG4gKiBmb3IgdGhhdCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHdpdGhNb2NrZWRDbGFzc1NpbmdsZXRvbjxBIGV4dGVuZHMgb2JqZWN0LCBLIGV4dGVuZHMga2V5b2YgQSwgQj4oXG4gIG9iajogQSxcbiAga2V5OiBLLFxuICBjYjogKG1vY2s6IEFbS10gZXh0ZW5kcyBqZXN0LkNvbnN0cnVjdGFibGUgPyBqZXN0Lk1vY2tlZDxJbnN0YW5jZVR5cGU8QVtLXT4+IDogbmV2ZXIpID0+IFByb21pc2U8Qj4sXG4pOiBQcm9taXNlPEI+IHtcblxuICBjb25zdCBvcmlnaW5hbCA9IG9ialtrZXldO1xuICB0cnkge1xuICAgIGNvbnN0IG1vY2sgPSBpbnN0YW5jZU1vY2tGcm9tKG9yaWdpbmFsIGFzIGFueSk7XG4gICAgb2JqW2tleV0gPSBqZXN0LmZuKCkubW9ja1JldHVyblZhbHVlKG1vY2spIGFzIGFueTtcbiAgICBjb25zdCByZXQgPSBhd2FpdCBjYihtb2NrIGFzIGFueSk7XG4gICAgcmV0dXJuIHJldDtcbiAgfSBmaW5hbGx5IHtcbiAgICBvYmpba2V5XSA9IG9yaWdpbmFsO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3aXRoTW9ja2VkPEEgZXh0ZW5kcyBvYmplY3QsIEsgZXh0ZW5kcyBrZXlvZiBBLCBCPihvYmo6IEEsIGtleTogSywgYmxvY2s6IChmbjogamVzdC5Nb2NrZWQ8QT5bS10pID0+IEIpOiBCIHtcbiAgY29uc3Qgb3JpZ2luYWwgPSBvYmpba2V5XTtcbiAgY29uc3QgbW9ja0ZuID0gamVzdC5mbigpO1xuICAob2JqIGFzIGFueSlba2V5XSA9IG1vY2tGbjtcblxuICBsZXQgYXN5bmNGaW5hbGx5OiBib29sZWFuID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgY29uc3QgcmV0ID0gYmxvY2sobW9ja0ZuIGFzIGFueSk7XG4gICAgaWYgKCFpc1Byb21pc2UocmV0KSkgeyByZXR1cm4gcmV0OyB9XG5cbiAgICBhc3luY0ZpbmFsbHkgPSB0cnVlO1xuICAgIHJldHVybiByZXQuZmluYWxseSgoKSA9PiB7IG9ialtrZXldID0gb3JpZ2luYWw7IH0pIGFzIGFueTtcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoIWFzeW5jRmluYWxseSkge1xuICAgICAgb2JqW2tleV0gPSBvcmlnaW5hbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNQcm9taXNlPEE+KG9iamVjdDogYW55KTogb2JqZWN0IGlzIFByb21pc2U8QT4ge1xuICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG9iamVjdCkgPT09IG9iamVjdDtcbn1cbiJdfQ==